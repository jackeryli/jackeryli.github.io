[{"content":"Docker container has manys status which shows in the following table:\n   Status Description     created    restarting    running    removing    paused    exited    dead     # Show status=running containers docker ps # Show all containers docker ps -a # Filter status=exit containers docker ps --filter status=exit How to update running container config? # CPU cores num docker update --cpus=1 nginx-test # Restart policy docker update --restart=always nginx-test ","permalink":"https://jacklatte.github.io/posts/docker-useful-commands/","summary":"Docker container has manys status which shows in the following table:\n   Status Description     created    restarting    running    removing    paused    exited    dead     # Show status=running containers docker ps # Show all containers docker ps -a # Filter status=exit containers docker ps --filter status=exit How to update running container config?","title":"Docker Useful Commands"},{"content":"What is docker? Docker uses namespace and cgroup to isolate processes.\nRun nginx with docker docker run -d -p 8080:80 ubuntu/nginx What\u0026rsquo;s the difference of a process running in docker than bare metal ? If we run ps -ef on host computer, it shows that\nUID PID COMMAND root 1 /sbin/init systemd 29 nginx But if we run ps -ef inside container, it shows that\nUID PID COMMAND root 1 nginx The main difference is that PID is different. What makes this differences is that docker uses namespace to create an isolated environment. We can only see the process in the same namespace.\n","permalink":"https://jacklatte.github.io/posts/docker-introduction/","summary":"What is docker? Docker uses namespace and cgroup to isolate processes.\nRun nginx with docker docker run -d -p 8080:80 ubuntu/nginx What\u0026rsquo;s the difference of a process running in docker than bare metal ? If we run ps -ef on host computer, it shows that\nUID PID COMMAND root 1 /sbin/init systemd 29 nginx But if we run ps -ef inside container, it shows that\nUID PID COMMAND root 1 nginx The main difference is that PID is different.","title":"Docker Introduction"},{"content":"Background Most of the services need a image upload services. Some applications like Ptt, Dcard and HackMD use Imgur to store pictures. Imgur provides free spaces for users to upload their images, and it also provides API so that programers can upload images by sending POST request. In this tutorial, we are going to build a imgur upload service.\nPackages Used  gonic/gin: http server bytes: store images encoding/json: process response io: transfer io.Reader to []byte \u0026ldquo;mime/multipart\u0026rdquo;: form data(request)  Code 1. Create a Client struct and constructor to store/initialize token and imgur API URL type Client struct { token string uploadApiUrl string } func NewClient(token string, uploadApiUrl string) *Client{ return \u0026amp;Client{token: token, uploadApiUrl: uploadApiUrl} } 2. Create a UploadImage function We consider to choose type []byte instead of io.Reader for params. The main reason is that we should pass the real data, not the FileReader pointer. Also []byte is easier to write test.\nWorkflows  if image is nil, return error Create a multipart writer for writing form-data CreateFormFile creates fields for form Copy data at the end of the writer Send a POST request to Imugr with the authorization token Decode the response Return the imgur image url  Functions    Package Function     mime/multipart func (w *Writer) CreateFormFile(fieldname, filename string) (io.Writer, error)   io func Copy(dst Writer, src Reader) (written int64, err error)   http func NewRequest(method, url string, body io.Reader) (*Request, error)   io/ioutil func ReadAll(r io.Reader) ([]byte, error)    Code func (client *Client) UploadImage(image []byte) (string, error){ if image == nil { return \u0026#34;\u0026#34;, errors.New(\u0026#34;No Image\u0026#34;) } var buf = new(bytes.Buffer) writer := multipart.NewWriter(buf) part, _ := writer.CreateFormFile(\u0026#34;image\u0026#34;, \u0026#34;filename\u0026#34;) imgReader := bytes.NewReader(image) io.Copy(part, imgReader) writer.Close() req, _ := http.NewRequest(\u0026#34;POST\u0026#34;, client.uploadApiUrl, buf) req.Header.Set(\u0026#34;Content-Type\u0026#34;, writer.FormDataContentType()) req.Header.Set(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer \u0026#34;+client.token) res, _ := http.DefaultClient.Do(req) defer res.Body.Close() body, _ := ioutil.ReadAll(res.Body) dec := json.NewDecoder(bytes.NewReader(body)) var img imageInfoDataWrapper if err := dec.Decode(\u0026amp;img); err != nil { return \u0026#34;\u0026#34;, errors.New(\u0026#34;Fail to decode\u0026#34;) } if !img.Success { return \u0026#34;\u0026#34;, errors.New(\u0026#34;Fail\u0026#34;) } return img.Data.Link, nil } Tests We set token by environment variable.\nThere are two tests:\n Test upload nil image Test upload real image  io.ReadFile() reads file in []byte as input file.\nNeed to check if the return URL is correct (https://i.imgur.com/xxxxx).\npackage upload import ( \u0026#34;testing\u0026#34; \u0026#34;os\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;regexp\u0026#34; ) // Test if upload a nil image, it should return error func TestUploadNilImage(t *testing.T) { client := NewClient(\u0026#34;\u0026#34;, \u0026#34;\u0026#34;) _, err := client.UploadImage(nil) if err == nil { t.Error(\u0026#34;UploadImage() should have an error\u0026#34;) t.Fail() } } // Test if upload real image, it should return success(200) func TestUploadRealImage(t *testing.T) { token := os.Getenv(\u0026#34;IMGUR_UPLOAD_TOKEN\u0026#34;) if token == \u0026#34;\u0026#34; { t.Skip(\u0026#34;IMGUR_UPLOAD_TOKEN is not set.\u0026#34;) } client := NewClient(os.Getenv(\u0026#34;IMGUR_UPLOAD_TOKEN\u0026#34;), \u0026#34;https://api.imgur.com/3/upload\u0026#34;) // Read File to byte \tfile, err := ioutil.ReadFile(\u0026#34;logo.png\u0026#34;) if err != nil { t.Skip(\u0026#34;Can\u0026#39;t read logo.png for test\u0026#34;) } url, err := client.UploadImage(file) if err != nil { t.Errorf(\u0026#34;UploadImage() failed with error: %v\u0026#34;, err) t.Fail() } if matched, _ := regexp.MatchString(`https://i.imgur.com/`, url); !matched { t.Error(\u0026#34;UploadImage() did not return imgur url\u0026#34;) t.Fail() } } Usage we need to pass []byte to UploadImage().\nc.FormData()returns *multipart.FileHeader.\n*multipart.FileHeader.Open() returns io.Reader\nWe use ioutil.ReadAll() to read io.Reader to []byte\n// imgurUploadServer.go package main import ( \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;github.com/jacklatte/arts-nthu-backend/pkg/upload\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;os\u0026#34; \u0026#34;mime/multipart\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { r := gin.Default() r.POST(\u0026#34;/api/v1/upload\u0026#34;, func(c *gin.Context) { type request struct { image *multipart.FileHeader `form:image binding:\u0026#34;required\u0026#34;` } var req request if err := c.ShouldBind(\u0026amp;req); err != nil { c.JSON(http.StatusBadRequest, gin.H{ \u0026#34;message\u0026#34;: \u0026#34;miss data\u0026#34;, }) return } file, err := c.FormFile(\u0026#34;image\u0026#34;) // *Multipart.FileHeader \tif file.Size \u0026lt;=0 { c.JSON(500, gin.H{ \u0026#34;message\u0026#34;: err.Error(), }) } if err != nil { c.JSON(500, gin.H{ \u0026#34;message\u0026#34;: err.Error(), }) } reader, err := file.Open()\t// io.Reader \tif err != nil { c.JSON(500, gin.H{ \u0026#34;message\u0026#34;: err.Error(), }) } buf, err := ioutil.ReadAll(reader)\t// bytes[] \tif err != nil { c.JSON(500, gin.H{ \u0026#34;message\u0026#34;: err.Error(), }) } client := upload.NewClient(os.Getenv(\u0026#34;IMGUR_UPLOAD_TOKEN\u0026#34;), \u0026#34;https://api.imgur.com/3/upload\u0026#34;) imgurUrl, _ := client.UploadImage(buf) c.JSON(200, gin.H{ \u0026#34;url\u0026#34;: imgurUrl, }) return }) r.Run() } ","permalink":"https://jacklatte.github.io/posts/go-imgur/","summary":"Background Most of the services need a image upload services. Some applications like Ptt, Dcard and HackMD use Imgur to store pictures. Imgur provides free spaces for users to upload their images, and it also provides API so that programers can upload images by sending POST request. In this tutorial, we are going to build a imgur upload service.\nPackages Used  gonic/gin: http server bytes: store images encoding/json: process response io: transfer io.","title":"Write a imgur upload service with go"},{"content":"Environment  Ubuntu 16.04  1. Download Nginx Source Code Nginx source code download\nWe download the stable version.\ncd /opt/local wget https://nginx.org/download/nginx-1.16.1.tar.gz tar xvf nginx-1.16.1.tar.gz sudo chown -R \u0026lt;user\u0026gt;:\u0026lt;group\u0026gt; nginx-1.16.1 2. Download nginx-module-vts Nginx-module-vts release\ncd /opt/local wget https://github.com/vozlt/nginx-module-vts/archive/v0.1.18.tar.gz tar xvf v0.1.18.tar.gz 3. Build Nginx source code Check the dependencies and the settings\n./configure Usually you need to install PCRE, zlib, Openssl to support nginx rewrite , gzip and https.\nsudo apt-get install libpcre3 libpcre3-dev sudo apt-get install zlib1g-dev sudo apt-get install openssl libssl-dev ./configure \\ --prefix=/etc/nginx \\ --sbin-path=/usr/sbin/nginx \\ --modules-path=/usr/lib64/nginx/modules \\ --conf-path=/etc/nginx/nginx.conf \\ --error-log-path=/var/log/nginx/error.log \\ --http-log-path=/var/log/nginx/access.log \\ --pid-path=/var/run/nginx.pid \\ --lock-path=/var/run/nginx.lock \\ --http-client-body-temp-path=/var/cache/nginx/client_temp \\ --http-proxy-temp-path=/var/cache/nginx/proxy_temp \\ --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp \\ --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp \\ --http-scgi-temp-path=/var/cache/nginx/scgi_temp \\ --user=www-data \\ --group=www-data \\ --with-compat \\ --with-file-aio \\ --with-threads \\ --with-http_addition_module \\ --with-http_auth_request_module \\ --with-http_dav_module \\ --with-http_flv_module \\ --with-http_gunzip_module \\ --with-http_gzip_static_module \\ --with-http_mp4_module \\ --with-http_random_index_module \\ --with-http_realip_module \\ --with-http_secure_link_module \\ --with-http_slice_module \\ --with-http_ssl_module \\ --with-http_stub_status_module \\ --with-http_sub_module \\ --with-http_v2_module \\ --with-mail \\ --with-mail_ssl_module \\ --with-stream \\ --with-stream_realip_module \\ --with-stream_ssl_module \\ --with-stream_ssl_preread_module \\ --with-http_geoip_module \\ --with-cc-opt=\u0026#39;-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -m64 -mtune=generic -fPIC\u0026#39; \\ --with-ld-opt=\u0026#39;-Wl,-z,relro -Wl,-z,now -pie\u0026#39; \\ --add-dynamic-module=../nginx-module-vts-0.1.18/ it will show the configs we are about to use in Makefile\nConfiguration summary + using threads + using system PCRE library + using system OpenSSL library + using system zlib library nginx path prefix: \u0026#34;/etc/nginx\u0026#34; nginx binary file: \u0026#34;/usr/sbin/nginx\u0026#34; nginx modules path: \u0026#34;/usr/lib64/nginx/modules\u0026#34; nginx configuration prefix: \u0026#34;/etc/nginx\u0026#34; nginx configuration file: \u0026#34;/etc/nginx/nginx.conf\u0026#34; nginx pid file: \u0026#34;/var/run/nginx.pid\u0026#34; nginx error log file: \u0026#34;/var/log/nginx/error.log\u0026#34; nginx http access log file: \u0026#34;/var/log/nginx/access.log\u0026#34; nginx http client request body temporary files: \u0026#34;/var/cache/nginx/client_temp\u0026#34; nginx http proxy temporary files: \u0026#34;/var/cache/nginx/proxy_temp\u0026#34; nginx http fastcgi temporary files: \u0026#34;/var/cache/nginx/fastcgi_temp\u0026#34; nginx http uwsgi temporary files: \u0026#34;/var/cache/nginx/uwsgi_temp\u0026#34; nginx http scgi temporary files: \u0026#34;/var/cache/nginx/scgi_temp\u0026#34; 4. Makefile and move compiled module to right place # Compile the nginx source code make # Move compiled files to the location where we configure make install # Move compiled *.so file to place to let /etc/nginx/nginx.conf use this module sudo cp objs/ngx_http_vhost_traffic_status_module.so /etc/nginx/modules/ Reference install-nginx-virtual-host-traffic-status-module\n","permalink":"https://jacklatte.github.io/posts/nginx-module-vts-installation/","summary":"Nginx-module-vts is designed to monitor Internet traffic on Nginx.","title":"Install nginx-module-vts for monitoring"},{"content":"","permalink":"https://jacklatte.github.io/projects/sad/","summary":"","title":"Stream Analytics Platform"},{"content":"","permalink":"https://jacklatte.github.io/projects/arts-nthu/","summary":"","title":"NTHU Arts Center Website"},{"content":"Now, rust has two ways to write async functions, async-std and tokio. Let\u0026rsquo;s first start with async-std.\nAdd dependencies in Cargo.toml  Note that attributes is used for #[async_std::main].\n Filename: Cargo.toml\n[dependencies] async-std = { version = \u0026#34;1.6.5\u0026#34;, features = [\u0026#34;attributes\u0026#34;] } Write functions Filename: src/hello.rs\n async main requires return a std::io::Result.\n #[async_std::main]asyncfn main()-\u0026gt; std::io::Result\u0026lt;()\u0026gt;{println!(\u0026#34;hello world!\u0026#34;);Ok(())}Build your code cargo run ","permalink":"https://jacklatte.github.io/posts/how-to-use-async-std/","summary":"Now, rust has two ways to write async functions, async-std and tokio. Let\u0026rsquo;s first start with async-std.\nAdd dependencies in Cargo.toml  Note that attributes is used for #[async_std::main].\n Filename: Cargo.toml\n[dependencies] async-std = { version = \u0026#34;1.6.5\u0026#34;, features = [\u0026#34;attributes\u0026#34;] } Write functions Filename: src/hello.rs\n async main requires return a std::io::Result.\n #[async_std::main]asyncfn main()-\u0026gt; std::io::Result\u0026lt;()\u0026gt;{println!(\u0026#34;hello world!\u0026#34;);Ok(())}Build your code cargo run ","title":"How to use async-std"},{"content":"Go-Request-limit Github\nHow to test docker run --name redis-lab -p 6379:6379 -d redis cd \u0026lt;project-name\u0026gt; go build main.go //if necessary ./main Design Idea There are the scenerio on how to prevent URL from users\u0026rsquo; request.\n Request come Check if user\u0026rsquo;s ip is in the Redis list If not, create a redis list, whose key is user\u0026rsquo;s ip. Return. If yes, check the redis list with key=(user\u0026rsquo;s ip) and calcuate its length. If length is over request limit, return status too many reqest. If length is valid, push user\u0026rsquo;s ip to the list and return.   Return data including X-RateLimit-Remaining and X-RateLimit-Reset. The value of X-RateLimit-Reset is based on the TTL of certain redis list. The TTL will start when the first request comes and will expire in an hour. After an hour, the redis list of certain key will disappear.  ","permalink":"https://jacklatte.github.io/posts/go-request-limiter/","summary":"A middleware which can restrict ip request in certain time window","title":"Write a request limiter in Go"},{"content":"Push to Github Pages !!!: Remember to stop hot-loading test server before pushing to Github.\nThere are two different types of Github Page.\n User/Organization Page Project Page  For User/Organization Page, we need to create two github repository. One for hugo, the other one is for static files. For Project Page, we need to add publicDir=docs to config.toml.\nHere we demo how to create User/Organization Page.\n1. Create two git repository  412988937/412988937.github.io \u0026ndash;\u0026gt; For static files 412988937/412988937-blog \u0026ndash;\u0026gt; For hugo files  2. Create deploy.sh at hugo-project-dir #!/bin/sh  # If a command fails then the deploy stops set -e printf \u0026#34;\\033[0;32mDeploying updates to GitHub...\\033[0m\\n\u0026#34; # Build the project. hugo # if using a theme, replace with `hugo -t \u0026lt;YOURTHEME\u0026gt;` # Go To Public folder cd public # Add changes to git. git add . # Commit changes. msg=\u0026#34;rebuilding site $(date)\u0026#34; if [ -n \u0026#34;$*\u0026#34; ]; then msg=\u0026#34;$*\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; # Push source and build repos. git push origin master 2. Add public folder as Git Submodule and root folder In deploy.sh, it run hugo to generate static files to public/. Then it will push whole files to 412988937.github.io.git. Finally we can see our website in https://412988937.github.io\ncd \u0026lt;hugo-project-dir\u0026gt; git init git submodule add -b master https://github.com/412988937/412988937.github.io.git public Note: we can add hugo-project-dir to git respository for tracking.\n3. Publish to Github Page when we create new things sh deploy.sh ","permalink":"https://jacklatte.github.io/posts/hugo-to-github/","summary":"We push our hugo website to Github Page.","title":"Push hugo to Github Page"},{"content":"1. Install go Go to the Go Officail Webiste and download go.\n2. Install brew (OSX) Brew Official Website\n/bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\u0026#34; 3. Install Hugo brew install hugo 4. Run the command to generate a site hugo new site myblog The directory will like:\nmyblog |- archetypes |- assets |- content |-posts |- data |- layout |- public |- static |- theme 5. Install theme You can download themes from here.\nIn this tutorial we use hugo-theme-noteworthy for example.\ncd \u0026lt;hugo-project-dir\u0026gt; git clone https://github.com/kimcc/hugo-theme-noteworthy.git themes/noteworthy There are two ways to utilize the theme.\n Write theme=noteworthy to config.toml Copy necessary data to project folder  For example:\n// Maybe you need to move more data mv themes/noteworthy/layout layout mv themes/noteworthy/assets asset mv themes/noteworthy/static static 6. Set config.toml Usually we can take a look from themes/exampleSite/config.toml for details.\n7. Run the hot-load testing server hugo server // You can see your website on http://localhost:1313 8. Post articles hugo new posts/hello.md ","permalink":"https://jacklatte.github.io/posts/hugo-install/","summary":"\u003ccode\u003eHugo\u003c/code\u003e is the fastest static website generator in the world. It is really suitable for software developers to generate their personal website. In this tutorial, we start to build up a website which used \u003ccode\u003eHugo\u003c/code\u003e.","title":"Install Hugo on MacOS"},{"content":"Jack Li B.A. Computer Science / National Tsing Hua University, Taiwan / 2017-2021\nüíº Experiences Software Engineer, LINE, Taiwan, July, 2021 ~ Present Springboot / MySQL / Redis / Kubernetes / Kafka\n Develop Restful API services with SpringBoot, MySQL and Redis. Design unit tests and build automated CI/CD pipeline with JUnit and Jenkins. Build scalable and fault-tolerance system with Docker, Kubernetes and Kafka.  ‚òéÔ∏è Contact  Email: jack.yenchun.li@gmail.com Github: https://github.com/jacklatte Linkedin: https://www.linkedin.com/in/jack-yen-chun-li/  üõ†Ô∏è Skills  Go Java C/C++ Kubernetes SQL/NoSQL CUDA Distributed System  üá®üá¶ Languages English / Chinese\n","permalink":"https://jacklatte.github.io/about/","summary":"Jack Li B.A. Computer Science / National Tsing Hua University, Taiwan / 2017-2021\nüíº Experiences Software Engineer, LINE, Taiwan, July, 2021 ~ Present Springboot / MySQL / Redis / Kubernetes / Kafka\n Develop Restful API services with SpringBoot, MySQL and Redis. Design unit tests and build automated CI/CD pipeline with JUnit and Jenkins. Build scalable and fault-tolerance system with Docker, Kubernetes and Kafka.  ‚òéÔ∏è Contact  Email: jack.yenchun.li@gmail.com Github: https://github.","title":"About"},{"content":"   What is Hugo ?   1-1. Hugo install 1-2. Hugo to github    ","permalink":"https://jacklatte.github.io/hugo-tutorial/","summary":"archives","title":"Hugo Tutorial"},{"content":"Hugo Tutorial Build your personal website\nQEMU Tutorial Software-simulated virtual machine\n","permalink":"https://jacklatte.github.io/topic/","summary":"Hugo Tutorial Build your personal website\nQEMU Tutorial Software-simulated virtual machine","title":"Topic"}]