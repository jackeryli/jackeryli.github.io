[{"content":"Background Most of the services need a image upload services. Some applications like Ptt, Dcard and HackMD use Imgur to store pictures. Imgur provides free spaces for users to upload their images, and it also provides API so that programers can upload images by sending POST request. In this tutorial, we are going to build a imgur upload service.\nPackages Used  gonic/gin: http server bytes: store images encoding/json: process response io: transfer io.Reader to []byte \u0026ldquo;mime/multipart\u0026rdquo;: form data(request)  Code 1. Create a Client struct and constructor to store/initialize token and imgur API URL type Client struct { token string uploadApiUrl string } func NewClient(token string, uploadApiUrl string) *Client{ return \u0026amp;Client{token: token, uploadApiUrl: uploadApiUrl} } 2. Create a UploadImage function We consider to choose type []byte instead of io.Reader for params. The main reason is that we should pass the real data, not the FileReader pointer. Also []byte is easier to write test.\nWorkflows  if image is nil, return error Create a multipart writer for writing form-data CreateFormFile creates fields for form Copy data at the end of the writer Send a POST request to Imugr with the authorization token Decode the response Return the imgur image url  Functions    Package Function     mime/multipart func (w *Writer) CreateFormFile(fieldname, filename string) (io.Writer, error)   io func Copy(dst Writer, src Reader) (written int64, err error)   http func NewRequest(method, url string, body io.Reader) (*Request, error)   io/ioutil func ReadAll(r io.Reader) ([]byte, error)    Code func (client *Client) UploadImage(image []byte) (string, error){ if image == nil { return \u0026#34;\u0026#34;, errors.New(\u0026#34;No Image\u0026#34;) } var buf = new(bytes.Buffer) writer := multipart.NewWriter(buf) part, _ := writer.CreateFormFile(\u0026#34;image\u0026#34;, \u0026#34;filename\u0026#34;) imgReader := bytes.NewReader(image) io.Copy(part, imgReader) writer.Close() req, _ := http.NewRequest(\u0026#34;POST\u0026#34;, client.uploadApiUrl, buf) req.Header.Set(\u0026#34;Content-Type\u0026#34;, writer.FormDataContentType()) req.Header.Set(\u0026#34;Authorization\u0026#34;, \u0026#34;Bearer \u0026#34;+client.token) res, _ := http.DefaultClient.Do(req) defer res.Body.Close() body, _ := ioutil.ReadAll(res.Body) dec := json.NewDecoder(bytes.NewReader(body)) var img imageInfoDataWrapper if err := dec.Decode(\u0026amp;img); err != nil { return \u0026#34;\u0026#34;, errors.New(\u0026#34;Fail to decode\u0026#34;) } if !img.Success { return \u0026#34;\u0026#34;, errors.New(\u0026#34;Fail\u0026#34;) } return img.Data.Link, nil } Tests We set token by environment variable.\nThere are two tests:\n Test upload nil image Test upload real image  io.ReadFile() reads file in []byte as input file.\nNeed to check if the return URL is correct (https://i.imgur.com/xxxxx).\npackage upload import ( \u0026#34;testing\u0026#34; \u0026#34;os\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;regexp\u0026#34; ) // Test if upload a nil image, it should return error func TestUploadNilImage(t *testing.T) { client := NewClient(\u0026#34;\u0026#34;, \u0026#34;\u0026#34;) _, err := client.UploadImage(nil) if err == nil { t.Error(\u0026#34;UploadImage() should have an error\u0026#34;) t.Fail() } } // Test if upload real image, it should return success(200) func TestUploadRealImage(t *testing.T) { token := os.Getenv(\u0026#34;IMGUR_UPLOAD_TOKEN\u0026#34;) if token == \u0026#34;\u0026#34; { t.Skip(\u0026#34;IMGUR_UPLOAD_TOKEN is not set.\u0026#34;) } client := NewClient(os.Getenv(\u0026#34;IMGUR_UPLOAD_TOKEN\u0026#34;), \u0026#34;https://api.imgur.com/3/upload\u0026#34;) // Read File to byte \tfile, err := ioutil.ReadFile(\u0026#34;logo.png\u0026#34;) if err != nil { t.Skip(\u0026#34;Can\u0026#39;t read logo.png for test\u0026#34;) } url, err := client.UploadImage(file) if err != nil { t.Errorf(\u0026#34;UploadImage() failed with error: %v\u0026#34;, err) t.Fail() } if matched, _ := regexp.MatchString(`https://i.imgur.com/`, url); !matched { t.Error(\u0026#34;UploadImage() did not return imgur url\u0026#34;) t.Fail() } } Usage we need to pass []byte to UploadImage().\nc.FormData()returns *multipart.FileHeader.\n*multipart.FileHeader.Open() returns io.Reader\nWe use ioutil.ReadAll() to read io.Reader to []byte\n// imgurUploadServer.go package main import ( \u0026#34;github.com/gin-gonic/gin\u0026#34; \u0026#34;github.com/jacklatte/arts-nthu-backend/pkg/upload\u0026#34; \u0026#34;io/ioutil\u0026#34; \u0026#34;os\u0026#34; \u0026#34;mime/multipart\u0026#34; \u0026#34;net/http\u0026#34; ) func main() { r := gin.Default() r.POST(\u0026#34;/api/v1/upload\u0026#34;, func(c *gin.Context) { type request struct { image *multipart.FileHeader `form:image binding:\u0026#34;required\u0026#34;` } var req request if err := c.ShouldBind(\u0026amp;req); err != nil { c.JSON(http.StatusBadRequest, gin.H{ \u0026#34;message\u0026#34;: \u0026#34;miss data\u0026#34;, }) return } file, err := c.FormFile(\u0026#34;image\u0026#34;) // *Multipart.FileHeader \tif file.Size \u0026lt;=0 { c.JSON(500, gin.H{ \u0026#34;message\u0026#34;: err.Error(), }) } if err != nil { c.JSON(500, gin.H{ \u0026#34;message\u0026#34;: err.Error(), }) } reader, err := file.Open()\t// io.Reader \tif err != nil { c.JSON(500, gin.H{ \u0026#34;message\u0026#34;: err.Error(), }) } buf, err := ioutil.ReadAll(reader)\t// bytes[] \tif err != nil { c.JSON(500, gin.H{ \u0026#34;message\u0026#34;: err.Error(), }) } client := upload.NewClient(os.Getenv(\u0026#34;IMGUR_UPLOAD_TOKEN\u0026#34;), \u0026#34;https://api.imgur.com/3/upload\u0026#34;) imgurUrl, _ := client.UploadImage(buf) c.JSON(200, gin.H{ \u0026#34;url\u0026#34;: imgurUrl, }) return }) r.Run() } ","permalink":"https://jacklatte.github.io/posts/go-imgur/","summary":"Background Most of the services need a image upload services. Some applications like Ptt, Dcard and HackMD use Imgur to store pictures. Imgur provides free spaces for users to upload their images, and it also provides API so that programers can upload images by sending POST request. In this tutorial, we are going to build a imgur upload service.\nPackages Used  gonic/gin: http server bytes: store images encoding/json: process response io: transfer io.","title":"Write a imgur upload service with go"},{"content":"","permalink":"https://jacklatte.github.io/projects/sad/","summary":"","title":"Stream Analytics Platform"},{"content":"","permalink":"https://jacklatte.github.io/projects/arts-nthu/","summary":"","title":"NTHU Arts Center Website"},{"content":"Go-Request-limit Github\nHow to test docker run --name redis-lab -p 6379:6379 -d redis cd \u0026lt;project-name\u0026gt; go build main.go //if necessary ./main Design Idea There are the scenerio on how to prevent URL from users\u0026rsquo; request.\n Request come Check if user\u0026rsquo;s ip is in the Redis list If not, create a redis list, whose key is user\u0026rsquo;s ip. Return. If yes, check the redis list with key=(user\u0026rsquo;s ip) and calcuate its length. If length is over request limit, return status too many reqest. If length is valid, push user\u0026rsquo;s ip to the list and return.   Return data including X-RateLimit-Remaining and X-RateLimit-Reset. The value of X-RateLimit-Reset is based on the TTL of certain redis list. The TTL will start when the first request comes and will expire in an hour. After an hour, the redis list of certain key will disappear.  ","permalink":"https://jacklatte.github.io/posts/go-request-limiter/","summary":"A middleware which can restrict ip request in certain time window","title":"Write a request limiter in Go"},{"content":"Hugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\n YouTube Privacy Enhanced Shortcode    Twitter Simple Shortcode “In addition to being more logical, asymmetry has the advantage that its complete appearance is far more optically effective than symmetry.”\n— Jan Tschichold pic.twitter.com/gcv7SrhvJb\n\u0026mdash; Graphic Design History (@DesignReviewed) January 17, 2019  Vimeo Simple Shortcode  .__h_video { position: relative; padding-bottom: 56.23%; height: 0; overflow: hidden; width: 100%; background: #000; } .__h_video img { width: 100%; height: auto; color: #000; } .__h_video .play { height: 72px; width: 72px; left: 50%; top: 50%; margin-left: -36px; margin-top: -36px; position: absolute; cursor: pointer; }  ","permalink":"https://jacklatte.github.io/posts/test/","summary":"\u003cp\u003eHugo ships with several \u003ca href=\"https://gohugo.io/content-management/shortcodes/#use-hugos-built-in-shortcodes\"\u003eBuilt-in Shortcodes\u003c/a\u003e for rich content, along with a \u003ca href=\"https://gohugo.io/about/hugo-and-gdpr/\"\u003ePrivacy Config\u003c/a\u003e and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\u003c/p\u003e","title":"Rich Content"},{"content":"","permalink":"https://jacklatte.github.io/about/","summary":"","title":"About"}]