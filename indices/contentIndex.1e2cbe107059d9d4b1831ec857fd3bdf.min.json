{"/":{"title":"Welcome!","content":"\n## Jack Li\n\n## üè´ Education\n\n- Master of Electrical Engineering / [University of British Columbia, Canada](https://www.ubc.ca/) / 2023-Present\n\n- Bachelor of Computer Science / [National Tsing Hua University, Taiwan](https://nthu-en.site.nthu.edu.tw/) / 2017-2021\n\n## üíº Experiences\n\n**Software Engineer, [LINE](https://line.me/en/), Taiwan, July 2021 - July 2023**\n\n**Springboot / MySQL / Redis / Kubernetes / Kafka**\n\n- Developed the mission API, enabling users to engage in various missions such as check-ins, following users,\nand completing transactions, leading to a new business for increasing 2M revenue.\n- Analyzed transaction data with Flink and helped deploy Flink on the kubernetes cluster with Oauth2 support.\n- Developed a File Download Center for the marketing team, integrating Kafka, Elasticsearch and Amazon S3.\n- Designed and implemented a favorite API for user preferences and recommended posts.\n- Developed advertisements and events APIs in microservices architectures for serving 10M users globally.\n- Established a CI workflow with automated unit tests and integration tests with Jenkins and CircleCI.\n- Managed kubernetes cluster with auto-scaling features and monitor with prometheus and grafana.\n- Developed a Vue.js dashboard for user management and data visualization.\n\n\n## ‚òéÔ∏è Contact\n\n- Email: jack.yenchun.li@gmail.com\n- Github: https://github.com/jackeryli\n- Linkedin: https://www.linkedin.com/in/jack-yen-chun-li/\n\n## üõ†Ô∏è Skills\n\n- Java\n- C/C++\n- Go\n- Docker\n- Kubernetes\n- SQL/NoSQL\n- CUDA\n- Distributed System\n\n## üåç Languages\n\nEnglish / Chinese\n\n\n","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/bare-metal/":{"title":"","content":"","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/bare-metal/bootloader":{"title":"Write bootloader for raspberry pi 3","content":"\nWe need three files:\n- kernel.ld: define the memory layout and tell the hardware where to find entry.S.\n- entry.S: run on single core, do initialization and jump to start.c.\n- start.c: first code.\n\nCompile to the kernel image:\n1. Link `entry.S` and `kernel.ld` to create `kernel.elf`\n2. Build `kernel.img` by `kernel.elf`\n3. Boot qemu with `kernel.img`\n\n## kernel.ld\n\n- ENTRY( _xxx ): tell system to find _entry for the following execution\n- 0x80000: first code will put at `0x800000` because 0 ~ 0x80000 are for io-mapping in arm64\n- text: put codes\n- data: initialized variable\n- bss: uinitialized variable \n\n```\nENTRY( _entry )\n\nSECTIONS\n{\n  . = 0x80000;\n  .text :\n  {\n    *(.text)\n  }\n  .data :\n  {\n    *(.data)\n  }\n  .bss ALIGN(16) (NOLOAD) :\n  {\n    __bss_start = .;\n\n    *(.bss)\n\n    __bss_end = .;\n  }\n  _end = .;\n}\n```\n\n## entry.S\n\n- `global _entry`: let `kernel.ld` locate\n\n```armasm\n.section .text\n.global _entry\n\n_entry:\n  mrs     x1, MPIDR_EL1     // Read Register to x1\n  and     x1, x1, #3        // Extract cpu_id from x1\n  cbz     x1, 2f            // If cpu=0, jump to 2\n\n1:\n  wfe                       // Wait for Event instruction\n  b       1b                // Jump to 1\n\n2:\n  ldr     x1, =_entry       // Load the address of _entry to x1\n  mov     sp, x1            // move stack pointer to x1\n\n  // clear bss\n  ldr     x1, =__bss_start  // Load __bss_start to x1\n  ldr     x2, =__bss_end    // Load __bss_end to x2\n\n3:\n  cmp     x1, x2            // Compare x1 and x2\n  beq     4f                // if x1=x2, jump to 4\n  str     xzr, [x1], #8\n  sub     x2, x2, #1\n  cbnz    x2, 3b\n\n4:\n  bl      start             // Jump to start function in C\n  b       1b                // Halt this core if return\n```\n\n## start.c\n\n```c\nvoid\nstart()\n{\n    while(1){}\n}\n```\n\n## Makefile\n\n```makefile\nTOOLCHAIN_PREFIX = aarch64-linux-gnu-\nCC = $(TOOLCHAIN_PREFIX)gcc\nLD = $(TOOLCHAIN_PREFIX)ld\nOBJCPY = $(TOOLCHAIN_PREFIX)objcopy\n\nCFLAGS = -Wall\n\nSRCS = start.c\nOBJS = $(SRCS:.c=.o)\n\nall: clean kernel.img\n\nentry.o: entry.S\n\t$(CC) $(CFLAGS) -c entry.S -o entry.o\n\n# Rule to compile .c files to .o files\n%.o: %.c\n\t$(CC) $(CFLAGS) -c $\u003c -o $@\n\n# Linking the object files to create kernel.elf\nkernel.elf: entry.o\n\t$(LD) -T kernel.ld -o kernel.elf entry.o\n\n# Convert kernel.elf to kernel.img\nkernel.img: kernel.elf\n\t$(OBJCPY) -O binary kernel.elf kernel.img\n\nclean:\n\trm -f *.o kernel.elf kernel.img\n\nqemu: kernel.img\n\tqemu-system-aarch64 -M raspi3b -kernel kernel.img -display none -serial null -serial stdio\n```","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/bare-metal/qemu-gdb":{"title":"Configure gdb for qemu","content":"\n## Compile code with gdb\n\nEnable `layout src` when you use gdb.\n\n```sh\nCFLAGS = -ggdb\n```\n\n## Add flag to qemu\n\n```sh\nqemu-system-aarch64 -M raspi3b -s -S -kernel kernel.img\n```\n\n## Create `.gdbinit` under project folders\n\n- Connect gdb on `127.0.0.1:1234`\n- Symbol-file enables `breakpoint` in gdb\n\n```sh\nset architecture aarch64\ntarget remote 127.0.0.1:1234\nsymbol-file kernel.elf\n```\n\n## Run qemu with gdb\n\n```sh\nmake qemu-gdb\n\n# Run on another window\ngdb-multiarch -x .gdbinit\n\n# Start using gdb\nb printk\nlayout src\nc\n\n```","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/bare-metal/shell":{"title":"Write a simple shell","content":"\nWe write a shell that can run the following commands:\n- help\n- hello\n- timestamp\n- reboot\n\n```c\ntypedef struct cmd_struct {\n  char* name;\n  char* msg;\n  int (*func)(char**);\n} cmd_struct;\n\nint help(char**);\nint hello(char**);\nint timestamp(char**);\nint reboot(char**);\n\n// TODO: argv for each commands\nchar* argv[10];\n\ncmd_struct cmds[NCOMMANDS] = {\n  {\n    .name = \"help\",\n    .msg = \"print available commands\",\n    .func = help\n  },\n  {\n    .name = \"hello\",\n    .msg = \"print hello world\",\n    .func = hello\n  },\n  {\n    .name = \"timestamp\",\n    .msg = \"get current timestamp\",\n    .func = timestamp\n  },\n  {\n    .name = \"reboot\",\n    .msg = \"restart the computer\",\n    .func = reboot\n  }\n};\n\nint\nexecute(char* cmd)\n{\n  for(int i=0; i \u003c NCOMMANDS; i++){\n    if(strncmp(cmd, cmds[i].name, 100) == 0){\n      return cmds[i].func(argv);\n    }\n  }\n  printk(\"sh.c: unknown command\");\n  return -1;\n}\n\nvoid\nrunsh(void)\n{\n  uartflush();\n  static char buf[100];\n\n  while(1){\n    printk(\"$ \");\n    \n    /* Read command */\n    int i = 0;\n    char c;\n    memset(buf, 0, sizeof(buf));\n    buf[0] = '\\0';\n\n    while((c = uartgetc()) != '\\n'){\n      buf[i++] = c;\n      uartputc(c);\n    }\n    buf[i] = '\\0';\n    uartputc('\\n');\n    /* Execute command */\n    execute(buf);\n    uartputc('\\n');\n  }\n}\n```\n\n## Get timestamp\n\n`timestamp` is calculated by timer counter divides timer frequency.\nThese two value are stored in registers `cntfrq_el0` and `cntpct_el0`.\n\n```c\nint\ntimestamp(char**)\n{\n  uint64 cnt = r_cntpct_el0();\n  uint64 freq = r_cntfrq_el0();\n\n  printk(\"cntpct_el0=%d, cntfrq_el0=%d\\n\", cnt, freq);\n  printk(\"%d\", cnt/freq);\n  return 0;\n}\n```\n\nI put assembly code at `arm64.h`. The [arm docs](https://developer.arm.com/documentation/ddi0601/latest/AArch64-Registers/CNTFRQ-EL0--Counter-timer-Frequency-Register)\nsaid that we can use `mrs %0 cntfrq_elo` to read the register.\n\n- `=r` means write register result to variable\n- `r` means write variable to register\n\n```c\nstatic inline uint64\nr_cntfrq_el0()\n{\n  uint64 x;\n  asm volatile(\"mrs %0, cntfrq_el0\": \"=r\" (x) );\n  return x;\n}\n\nstatic inline uint64\nr_cntpct_el0()\n{\n  uint64 x;\n  asm volatile(\"mrs %0, cntpct_el0\": \"=r\" (x) );\n  return x;\n}\n```\n\nFinally\n\n```sh\n$ make qemu\n\n$ timestamp\ncntpct_el0=462388643, cntfrq_el0=62500000\n7\n```","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/bare-metal/uart":{"title":"Configure miniUART to print characters to terminal","content":"\nFrom [rpi3 docs](https://cs140e.sergio.bz/docs/BCM2837-ARM-Peripherals.pdf), IO physical\naddress started from 0x3F000000.\n\n```text\nPhysical addresses range from 0x3F000000 to 0x3FFFFFFF for peripherals. The bus \naddresses for peripherals are set up to map onto the peripheral bus address range\nstarting at 0x7E000000. Thus a peripheral advertised here at bus address \n0x7Ennnnnn is available at physical address 0x3Fnnnnnn.\n```\n\nAnd the docs said miniuart register virtual address is at:\n\n| Address     | Reg Name       | Description                |\n| :---------- | :------------- | :------------------------- | \n| 0x7E21 5000 | AUX_IRQ        | Auxiliary Interrupt status |\n| 0x7E21 5004 | AUX_ENABLES    | Auxiliary enables          |\n| 0x7E21 5040 | AUX_MU_IO_REG  | Mini Uart I/O Data         |\n\nSo we define the registers we need for miniuart:\n\n```c\n/* ARM aux peripheral physical address start */\n#define BASE_ADDRESS 0x3f000000\n\n#define AUX_IRQ           (volatile unsigned int*) (0x7E215000 - BASE_ADDRESS)\n#define AUX_ENABLES       (volatile unsigned int*) (0x7E215004 - BASE_ADDRESS)\n#define AUX_MU_IO_REG     (volatile unsigned int*) (0x7E215040 - BASE_ADDRESS)\n#define AUX_MU_IER_REG    (volatile unsigned int*) (0x7E215044 - BASE_ADDRESS)\n#define AUX_MU_IIR_REG    (volatile unsigned int*) (0x7E215048 - BASE_ADDRESS)\n#define AUX_MU_LCR_REG    (volatile unsigned int*) (0x7E21504C - BASE_ADDRESS)\n#define AUX_MU_MCR_REG    (volatile unsigned int*) (0x7E215050 - BASE_ADDRESS)\n#define AUX_MU_LSR_REG    (volatile unsigned int*) (0x7E215054 - BASE_ADDRESS)\n#define AUX_MU_MSR_REG    (volatile unsigned int*) (0x7E215058 - BASE_ADDRESS)\n#define AUX_MU_SCRATCH    (volatile unsigned int*) (0x7E21505C - BASE_ADDRESS)\n#define AUX_MU_CNTL_REG   (volatile unsigned int*) (0x7E215060 - BASE_ADDRESS)\n#define AUX_MU_STAT_REG   (volatile unsigned int*) (0x7E215064 - BASE_ADDRESS)\n#define AUX_MU_BAUD_REG   (volatile unsigned int*) (0x7E215068 - BASE_ADDRESS)\n```\n\nInitialize uart\n\n```c\nvoid\nuartinit(void)\n{\n  *AUX_ENABLES |= 1; /* Enable mini UART */\n\n  *AUX_MU_CNTL_REG = 0;   /* Disable transmitter and receiver during configuration */\n  *AUX_MU_LCR_REG = 3;    /* 8-bit mode */\n  *AUX_MU_MCR_REG = 0;    /* Disable RTS line */\n  *AUX_MU_IER_REG = 0;    /* Disable interrupts */\n  *AUX_MU_IIR_REG = 6;    /* Clear receive/transmit FIFO */\n  *AUX_MU_BAUD_REG = 270; /* Set baud rate to 115200 */\n\n  *AUX_MU_CNTL_REG = 3;   /* Enable transmitter and receiver */\n}\n```\n\nThen we write `uartputc` and `uartgetc` to interact with uart: \n\n```c\n/**\n * Write to uart\n * \n * Check AUX_MU_LSR_REG‚Äôs Transmitter empty field.\n * If set, write to AUX_MU_IO_REG\n*/\nvoid\nuartputc(int c)\n{\n  while(!(*AUX_MU_LSR_REG \u0026 0x20));\n\n  *AUX_MU_IO_REG = c;\n}\n\n/**\n * Read from uart\n * \n * Check AUX_MU_LSR_REG‚Äôs data ready field.\n * If set, read from AUX_MU_IO_REG\n*/\nint\nuartgetc(void)\n{\n  while(!(*AUX_MU_LSR_REG \u0026 0x01));\n\n  int c = *AUX_MU_IO_REG;\n  c = (c == '\\r') ? '\\n' : c;\n  return c;\n}\n```\n\nAdd code to `start.c`\n\n```c\nvoid\nstart()\n{\n    uartputc('j');\n    uartputc('a');\n    uartputc('c');\n    uartputc('k');\n}\n```\n\nRemember to compile `uart.c`:\n\n```makefile\nSRCS = start.c uart.c\n```\n\nAdd `-serial null -serial stdio` to qemu. Because default qemu will output stdin/stdout to uart0,\nwe need to connect stdin/stdout to miniuart(uart1).\n\n```sh\nqemu-system-aarch64 -M raspi3b -kernel kernel.img -display none -serial null -serial stdio\n```\n\nFinally we can see the output on the terminal:\n\n```sh\n$ make qemu\nqemu-system-aarch64 -M raspi3b -kernel kernel.img -display none -serial null -serial stdio\njack\n```","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/leetcode/":{"title":"","content":"","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/leetcode/array/":{"title":"","content":"","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/leetcode/array/0048":{"title":"0048.Rotate Image","content":"\n```cpp\nclass Solution {\npublic:\n    void rotate(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix) {\n        // row column to column row\n        // left to right\n\n        int m = matrix.size();\n        \n        for(int i = 0; i \u003c m; i++){\n            for(int j = i; j \u003c m; j++) {\n                swap(matrix[i][j], matrix[j][i]);\n            }\n        }\n\n        for(int i = 0; i \u003c m; i++){\n            for(int j = 0; j \u003c m/2; j++){\n                swap(matrix[i][j], matrix[i][m-j-1]);\n            }\n        }\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/leetcode/array/2966":{"title":"2966. Divide Array Into Arrays With Max Difference","content":"\n```cpp\nclass Solution {\npublic:\n    vector\u003cvector\u003cint\u003e\u003e divideArray(vector\u003cint\u003e\u0026 nums, int k) {\n        // sort array from small to large\n        // divide into 3 part\n        // iterate and check if part[0] - part[2] is bigger than k\n        // if yes, return empty vector\n        // if no, assign part[0], part[1], part[2] to one vector\n\n        sort(nums.begin(), nums.end());\n\n        vector\u003cvector\u003cint\u003e\u003e ans = {nums.size()/3, vector\u003cint\u003e{}};\n\n        for(int i = 0; i \u003c nums.size(); i+=3){\n            if((nums[i+2] - nums[i]) \u003c= k) {\n                ans[i/3] = {nums[i], nums[i+1], nums[i+2]};\n            } else {\n                return vector\u003cvector\u003cint\u003e\u003e{};\n            }\n        }\n\n        return ans;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/leetcode/backtracking/":{"title":"","content":"","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/leetcode/backtracking/0017":{"title":"0017.Letter Combination","content":"\n```cpp\nclass Solution {\npublic:\n    vector\u003cstring\u003e result;\n    string path = \"\";\n    unordered_map\u003cchar, string\u003e num2alpha;\n\n    void backtracking(const string\u0026 digits, int index) {\n        if(index == digits.size()) {\n            result.emplace_back(path);\n            return;\n        }\n\n        for(char c : num2alpha[digits[index]]) {\n            path.push_back(c);\n            backtracking(digits, index + 1);\n            path.pop_back();\n        }\n    }\n\n    vector\u003cstring\u003e letterCombinations(string digits) {\n        if(digits.size() == 0) return {};\n        num2alpha['2'] = \"abc\";\n        num2alpha['3'] = \"def\";\n        num2alpha['4'] = \"ghi\";\n        num2alpha['5'] = \"jkl\";\n        num2alpha['6'] = \"mno\";\n        num2alpha['7'] = \"pqrs\";\n        num2alpha['8'] = \"tuv\";\n        num2alpha['9'] = \"wxyz\";\n\n        backtracking(digits, 0);\n        return result;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/leetcode/backtracking/0022":{"title":"0022.Generate Parentheses","content":"\n```cpp\nclass Solution {\npublic:\n    vector\u003cstring\u003e result;\n    string path;\n    void backtracking(int left, int right, int n) {\n        if(left \u003e n || right \u003e n) return;\n        if(left == n \u0026\u0026 right == n) {\n            result.push_back(path);\n            return;\n        }\n\n        if(left \u003e= right) {\n            path.push_back('(');\n            backtracking(left+1, right, n);\n            path.pop_back();\n        }\n        if(left \u003e right) {\n            path.push_back(')');\n            backtracking(left, right+1, n);\n            path.pop_back();\n        }\n    }\n    vector\u003cstring\u003e generateParenthesis(int n) {\n        path = \"(\";\n        backtracking(1, 0, n);\n        return result;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/leetcode/backtracking/0039":{"title":"0039. Combination Sum","content":"\n```cpp\nclass Solution {\npublic:\n    vector\u003cvector\u003cint\u003e\u003e result;\n    vector\u003cint\u003e path;\n\n    void backtracking(vector\u003cint\u003e\u0026 candidates, int target, int sum) {\n        if(target == sum) {\n            result.push_back(path);\n            return;\n        } else if(sum \u003e target) {\n            return;\n        }\n\n        for(int i = 0; i \u003c candidates.size(); i++) {\n            if(path.size() == 0 || path[path.size()-1] \u003c= candidates[i]) {\n                path.push_back(candidates[i]);\n                backtracking(candidates, target, sum + candidates[i]);\n                path.pop_back();\n            }\n        }\n    }\n\n    vector\u003cvector\u003cint\u003e\u003e combinationSum(vector\u003cint\u003e\u0026 candidates, int target) {\n        backtracking(candidates, target, 0);\n        return result;\n    }\n};\n```\n\n```cpp\nclass Solution {\npublic:\n    vector\u003cvector\u003cint\u003e\u003e result;\n    vector\u003cint\u003e path;\n\n    void backtracking(vector\u003cint\u003e\u0026 candidates, int target, int sum, int startIndex) {\n        if(target == sum) {\n            result.push_back(path);\n            return;\n        }\n\n        // Don't need to backtracking if already above target\n        for(int i = startIndex; i \u003c candidates.size() \u0026\u0026 sum + candidates[i] \u003c= target; i++) {\n            path.push_back(candidates[i]);\n            backtracking(candidates, target, sum + candidates[i], i);\n            path.pop_back();\n        }\n    }\n\n    vector\u003cvector\u003cint\u003e\u003e combinationSum(vector\u003cint\u003e\u0026 candidates, int target) {\n        sort(candidates.begin(), candidates.end()); // Need sort\n        backtracking(candidates, target, 0, 0);\n        return result;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/leetcode/backtracking/0046":{"title":"0046.Permutations","content":"\n```cpp\nclass Solution {\npublic:\n    vector\u003cvector\u003cint\u003e\u003e result;\n    vector\u003cint\u003e path;\n    \n    void backtracking(vector\u003cint\u003e\u0026 nums, vector\u003cbool\u003e\u0026 visited) {\n        if(path.size() == nums.size()) {\n            result.push_back(path);\n            return;\n        }\n\n        for(int i = 0; i \u003c nums.size(); i++) {\n            if(visited[i] == false) {\n                path.push_back(nums[i]);\n                visited[i] = true;\n                backtracking(nums, visited);\n                path.pop_back();\n                visited[i] = false;\n            }\n        }\n    }\n\n    vector\u003cvector\u003cint\u003e\u003e permute(vector\u003cint\u003e\u0026 nums) {\n        vector\u003cbool\u003e visited(nums.size(), false);\n        backtracking(nums, visited);\n        return result;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/leetcode/backtracking/0077":{"title":"0077.Combinations","content":"\n```cpp\nclass Solution {\npublic:\n    vector\u003cvector\u003cint\u003e\u003e result;\n    vector\u003cint\u003e path;\n\n    void backtracking(int n, int k, int start) {\n        if(path.size() == k) {\n            result.push_back(path);\n            return;\n        }\n\n        for(int i = start; i \u003c= n; i++) {\n            path.push_back(i);\n            backtracking(n, k, i + 1);\n            path.pop_back();\n        }\n    }\n\n    vector\u003cvector\u003cint\u003e\u003e combine(int n, int k) {\n        backtracking(n, k, 1);\n        return result;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/leetcode/backtracking/0079":{"title":"0079. Word Search","content":"\n```cpp\nclass Solution {\npublic:\n\n    bool backtracking(vector\u003cvector\u003cchar\u003e\u003e\u0026 board, string\u0026 word, int index, int row, int col) {\n        if(index == word.size()) {\n            return true;\n        }\n\n        if(row \u003c 0 || row == board.size() || col \u003c 0 || col == board[0].size() || word[index] != board[row][col]) {\n            return false;\n        }\n\n        board[row][col] = '#';\n        \n        bool r1 = backtracking(board, word, index + 1, row + 1, col);\n        bool r2 = backtracking(board, word, index + 1, row - 1, col);\n        bool r3 = backtracking(board, word, index + 1, row, col + 1);\n        bool r4 = backtracking(board, word, index + 1, row, col - 1);\n\n        board[row][col] = word[index];\n\n        return r1 || r2 || r3 || r4;\n    }\n\n    bool exist(vector\u003cvector\u003cchar\u003e\u003e\u0026 board, string word) {\n        for(int i = 0; i \u003c board.size(); i++) {\n            for(int j = 0; j \u003c board[0].size(); j++) {\n                if(backtracking(board, word, 0, i, j) == true) {\n                    return true;\n                }\n            }\n        }\n        \n        return false;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/leetcode/binary-search/":{"title":"","content":"","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/leetcode/binary-search/0034":{"title":"0034. Find First and Last Position of Element in Sorted Array","content":"\n```cpp\nclass Solution {\npublic:\n    int binarySearch(vector\u003cint\u003e\u0026 nums, int target, bool isSame){\n        int left = 0;\n        int right = nums.size() - 1;\n        int mid;\n\n        int index = -1;\n\n        while(left \u003c= right){\n            mid = left + (right - left) / 2;\n\n            if(nums[mid] == target){\n                index = mid;\n                if(isSame) right = mid - 1;\n                else left = mid + 1;\n            } else if (nums[mid] \u003e target){\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n\n        return index;\n    }\n\n    vector\u003cint\u003e searchRange(vector\u003cint\u003e\u0026 nums, int target) {\n        int left = binarySearch(nums, target, true);\n        if(left == -1) return {-1, -1};\n        int right = binarySearch(nums, target, false);\n        return {left, right};\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/leetcode/binary-search/0035":{"title":"0035. Search Insert Position","content":"```cpp\nclass Solution {\npublic:\n    int searchInsert(vector\u003cint\u003e\u0026 nums, int target) {\n        int left = 0;\n        int right = nums.size() - 1;\n\n        while(left \u003c= right){\n            int mid = left + (right - left) / 2;\n            if(target == nums[mid]){\n                return mid;\n            } else if (target \u003e nums[mid]){\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return left;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/leetcode/binary-search/0074":{"title":"0074. Search a 2D Matrix","content":"\n```cpp\nclass Solution {\npublic:\n    bool searchMatrix(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix, int target) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n\n        int left = 0;\n        int right = m*n - 1;\n        int mid;\n\n        while(left \u003c= right){\n            mid = left + (right - left) / 2;\n\n            int row = mid / n;\n            int col = mid % n;\n            if(matrix[row][col] == target) return true;\n            else if(target \u003e matrix[row][col]){\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return false;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/leetcode/binary-search/0436":{"title":"0436. Find Right Interval","content":"\n```cpp\nclass Solution {\npublic:\n\n    int binarySearch(vector\u003cvector\u003cint\u003e\u003e\u0026 intervals, int target){\n        int left = 0;\n        int right = intervals.size() - 1;\n        int mid;\n\n        // [[1,4], [2,3], [6,7]]\n        while(left \u003c= right){\n            mid = left + (right - left) / 2;\n            if(target == intervals[mid][0]){\n                right = mid - 1;\n            } else if (target \u003e intervals[mid][0]){\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return left == intervals.size() ? -1 : intervals[left][2];\n    }\n\n    vector\u003cint\u003e findRightInterval(vector\u003cvector\u003cint\u003e\u003e\u0026 intervals) {\n        for(int i = 0; i \u003c intervals.size(); i++){\n            intervals[i].push_back(i);\n        }\n\n        vector\u003cvector\u003cint\u003e\u003e base = intervals;\n\n        sort(intervals.begin(), intervals.end());\n\n        vector\u003cint\u003e result;\n        for(auto\u0026 interval : base){\n            result.push_back(binarySearch(intervals, interval[1]));\n        }\n        return result;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/leetcode/binary-search/0611":{"title":"0611. Valid Triangle Number","content":"\n```cpp\nclass Solution {\npublic:\n    int binarySearch(vector\u003cint\u003e\u0026 nums, int target, int left){\n        // find the number that smaller than a + b\n        // for example: 2 2 3 3 4 4\n        // final:             r l\n        // return (l - left) number are smaller than a + b\n        int l = left;\n        int r = nums.size() - 1;\n        int mid;\n\n        while(l \u003c= r){\n            mid = l + (r - l) / 2;\n\n            if(nums[mid] == target){\n                r = mid - 1;\n            } else if(nums[mid] \u003e target){\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l - left;\n    }\n\n    int triangleNumber(vector\u003cint\u003e\u0026 nums) {\n        int n = nums.size() - 1;\n        int ans = 0;\n\n        sort(nums.begin(), nums.end());\n\n        for(int i = 0; i \u003c n-1; i++){\n            for(int j = i+1; j \u003c n; j++){\n                int sum = nums[i] + nums[j];\n                ans += binarySearch(nums, sum, j+1);\n            }\n        }\n\n        return ans;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/leetcode/binary-search/0702":{"title":"0702. Search in a Sorted Array of Unknown Size","content":"\n```cpp\n/**\n * // This is the ArrayReader's API interface.\n * // You should not implement it, or speculate about its implementation\n * class ArrayReader {\n *   public:\n *     int get(int index);\n * };\n */\n\nclass Solution {\npublic:\n    int search(const ArrayReader\u0026 reader, int target) {\n        int l = 0;\n        int r = 1;\n        int mid;\n        int num;\n\n        // Find right most point which covered by 2^right-1 and 2^right\n        while(reader.get(r) != INT_MAX){\n            l = r;\n            r = r \u003c\u003c 1;\n        }\n\n        // Find right most point\n        while(l \u003c= r){\n            mid = l + (r - l) / 2;\n            if(reader.get(mid) == INT_MAX){\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n\n        r = l;\n        l = 0;\n\n        while(l \u003c= r){\n            mid = l + (r - l) / 2;\n            num = reader.get(mid);\n            if(num == target) return mid;\n            else if(num \u003e target) r = mid - 1;\n            else l = mid + 1;\n        }\n        \n        return -1;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/leetcode/binary-search/0704":{"title":"0704. Binary Search","content":"\n```cpp\nclass Solution {\npublic:\n    int search(vector\u003cint\u003e\u0026 nums, int target) {\n        int left = 0;\n        int right = nums.size()-1;\n\n        while(left \u003c= right){\n            int mid = left + (right - left) / 2;\n            if(nums[mid] == target) {\n                return mid;\n            }\n            else if(target \u003e nums[mid]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return -1;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/leetcode/binary-search/0744":{"title":"0744. Find Smallest Letter Greater Than Target","content":"```cpp\nclass Solution {\npublic:\n    char nextGreatestLetter(vector\u003cchar\u003e\u0026 letters, char target) {\n        int left = 0;\n        int right = letters.size() - 1;\n        int mid;\n\n        while(left \u003c= right){\n            mid = left + (right - left) / 2;\n            if(letters[mid] \u003c= target){\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return left == letters.size() ? letters[0] : letters[left];\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/leetcode/binary-search/0852":{"title":"0852. Peak Index in a Mountatin Array","content":"\n```cpp\nclass Solution {\npublic:\n    int peakIndexInMountainArray(vector\u003cint\u003e\u0026 arr) {\n        int l = 0;\n        int r = arr.size() - 1;\n        int mid;\n        // Use l \u003c r rather than l \u003c= r because I want to stop at l == r\n        // Seems like no effect in this question\n        while(l \u003c r){\n            mid = l + (r - l) / 2;\n            // Current is peak if left and right are smaller than mid\n            if(arr[mid-1] \u003c arr[mid] \u0026\u0026 arr[mid] \u003e arr[mid+1]){\n                return mid;\n            }\n            // Only move to mid to avoid illegal condition\n            if(arr[mid-1] \u003c arr[mid]){\n                l = mid;\n            } else {\n                r = mid;\n            }\n        }\n\n        return l;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/leetcode/binary-search/0875":{"title":"0875. Koko Eating Bananas","content":"\nIf we set `l \u003c r` and `r = m`\n```\nstate n-1\n\n3 4 5 6 7\n  l r\n  m\n\nstate n\n3 4 5 6 7\n  l\n  r\n```\n\n```cpp\nclass Solution {\npublic:\n    int minEatingSpeed(vector\u003cint\u003e\u0026 piles, int h) {\n        int l = 1;\n        int r = *max_element(piles.begin(), piles.end());\n        int m;\n        long long hours;\n\n        while(l \u003c= r){\n            m = l + (r - l) / 2;\n            hours = 0;\n            for(int\u0026 pile : piles){\n                hours += ((pile / m) + (pile % m != 0));\n            }\n\n            if(hours == h){\n                r = m - 1;\n            } else if(hours \u003e h){\n                l = m + 1;\n            } else {\n                r = m - 1;\n            }\n\n        }\n\n        return l;\n    }\n};\n```\n\nIf we set `l \u003c= r` and `r = m - 1`,\n\n```\nstate n-2\n\n3 4 5 6 7\n  l r\n  m\n\nstate n-1\n3 4 5 6 7\n  l\n  r\n  m\n\nstate n\n3 4 5 6 7\nl r\n```\n\n```cpp\nclass Solution {\npublic:\n    int minEatingSpeed(vector\u003cint\u003e\u0026 piles, int h) {\n        int l = 1;\n        int r = *max_element(piles.begin(), piles.end());\n        int m;\n        int hours;\n\n        while(l \u003c r){\n            m = l + (r - l) / 2;\n            hours = 0;\n            for(int\u0026 pile : piles){\n                hours += ((pile / m) + (pile % m != 0));\n            }\n\n            if(hours == h){\n                r = m;\n            } else if(hours \u003e h){\n                l = m + 1;\n            } else {\n                r = m;\n            }\n\n        }\n\n        return l;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/leetcode/binary-search/1011":{"title":"1011. Capacity To Ship Packages Within D Days","content":"\n```cpp\nclass Solution {\npublic:\n    int countShipDays(vector\u003cint\u003e\u0026 weights, int capacity){\n        int usedDays = 1;\n        int current = capacity;\n\n        for(int\u0026 weight : weights){\n            if(weight \u003e capacity){\n                return INT_MAX;\n            }\n            if(current \u003e= weight){\n                current -= weight;\n            } else {\n                usedDays++;\n                current = capacity - weight;\n            }\n        }\n\n        return usedDays;\n    }\n    int shipWithinDays(vector\u003cint\u003e\u0026 weights, int days) {\n        int l = 0;\n        int r = *max_element(weights.begin(), weights.end());\n        int usedDays;\n        int mid;\n\n        while(l \u003c r){\n            usedDays = countShipDays(weights, r);\n            if(usedDays \u003c= days)\n                break;\n            l = r;\n            r = r \u003c\u003c 1;\n        }\n\n        while(l \u003c= r){\n            mid = l + (r - l) / 2;\n            usedDays = countShipDays(weights, mid);\n\n            if(usedDays == days){\n                r = mid-1;\n            } else if(usedDays \u003e days){\n                l = mid + 1;\n            } else {\n                r = mid-1;\n            }\n        }\n\n        return l;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/leetcode/binary-search/1283":{"title":"1283. Find the Smallest Divisor Given a Threshold","content":"\n```cpp\nclass Solution {\npublic:\n    int calDivisionSum(vector\u003cint\u003e\u0026 nums, int divisor){\n        int result = 0;\n        for(int\u0026 num : nums){\n            result += (num / divisor) + (num % divisor != 0);\n        }\n        return result;\n    }\n\n    int smallestDivisor(vector\u003cint\u003e\u0026 nums, int threshold) {\n        int l = 1;\n        int r = *max_element(nums.begin(), nums.end());\n        int m;\n        int pivot;\n\n        while(l \u003c= r){\n            m = l + (r - l) / 2;\n            pivot = calDivisionSum(nums, m);\n\n            if(pivot == threshold){\n                r = m - 1;\n            } else if(pivot \u003e threshold){\n                l = m + 1;\n            } else {\n                r = m - 1;\n            }\n        }\n\n        return l;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/leetcode/binary-search/1351":{"title":"1351. Count Negative Numbers in a Sorted Matrix","content":"\n```cpp\nclass Solution {\npublic:\n    int binarySearch(vector\u003cint\u003e\u0026 arr){\n        int left = 0;\n        int right = arr.size() - 1;\n        int mid;\n\n        while(left \u003c= right){\n            mid = left + (right - left) / 2;\n            if(arr[mid] \u003e= 0){\n                left = mid + 1;          \n            } else {\n               right = mid - 1;\n            }\n        }\n        return arr.size() - left;\n    }\n\n    int countNegatives(vector\u003cvector\u003cint\u003e\u003e\u0026 grid) {\n        int m = grid.size();\n        int n = grid[0].size();\n\n        int ans = 0;\n\n        for(auto\u0026 arr: grid){\n            ans += binarySearch(arr);\n        }\n\n        return ans;\n    }\n};\n```\n\n```cpp\nclass Solution {\npublic:\n    int countNegatives(vector\u003cvector\u003cint\u003e\u003e\u0026 grid) {\n        int m = grid.size();\n        int n = grid[0].size();\n\n        int ans = 0;\n        int index = n - 1;\n\n        for(auto\u0026 row : grid){\n            while(index \u003e= 0 \u0026\u0026 row[index] \u003c 0){\n                index--;\n            }\n            ans += (n - index - 1);\n        }\n\n        return ans;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/leetcode/binary-search/1870":{"title":"1870. Minimum Speed to Arrive on Time","content":"\n```cpp\nclass Solution {\npublic:\n    double calHourSpent(vector\u003cint\u003e\u0026 dist, int speed) {\n        int n = dist.size() - 1;\n        double hourSpent = 0;\n\n        for(int i = 0; i \u003c n; i++) {\n            hourSpent += (dist[i] / speed + (dist[i] % speed != 0));\n        }\n        \n        return hourSpent + (double) dist[n] / speed;\n    }\n\n    int minSpeedOnTime(vector\u003cint\u003e\u0026 dist, double hour) {\n        if(hour \u003c= dist.size() - 1){\n            return -1;\n        }\n\n        int l = 1;\n        int r = 10e7; // two digit decimal after 10e5\n        int m;\n        double pivot;\n\n        while(l \u003c r) {\n            m = l + (r - l) / 2;\n            pivot = calHourSpent(dist, m);\n            \n            if(pivot == hour){\n                r = m;\n            } else if (pivot \u003e hour){\n                l = m + 1;\n            } else {\n                r = m;\n            }\n        }\n\n        return r;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/leetcode/binary-search/2300":{"title":"2300. Successful Pairs of Spells and Potions","content":"\n```cpp\nclass Solution {\npublic:\n    int binarySearch(vector\u003cint\u003e\u0026 potions, long long target) {\n        int n = potions.size();\n        int l = 0;\n        int r = n - 1;\n\n        while(l \u003c= r) {\n            long long m = l + (r - l) / 2;\n            if(potions[m] == target) {\n                r = m - 1;\n            } else if (potions[m] \u003e target) {\n                r = m - 1;\n            } else {\n                l = m + 1;\n            }\n        }\n\n        // 1 2  3 4 5\n        //   lr\n        // r l\n        return n - l;\n    }\n    vector\u003cint\u003e successfulPairs(vector\u003cint\u003e\u0026 spells, vector\u003cint\u003e\u0026 potions, long long success) {\n        vector\u003cint\u003e result;\n\n        sort(potions.begin(), potions.end());\n\n        for(int\u0026 spell : spells) {\n            long long target = success / spell + (success % spell != 0);\n            result.push_back(binarySearch(potions, target));\n        }\n\n        return result;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/leetcode/binary-tree/":{"title":"","content":"","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/binary-tree/0100":{"title":"0100.Same Tree","content":"\n```cpp\nclass Solution {\npublic:\n    bool isSameTree(TreeNode* p, TreeNode* q) {\n        if(p == nullptr \u0026\u0026 q == nullptr) return true;\n        if(p == nullptr || q == nullptr) return false;\n        if(p-\u003eval != q-\u003eval) return false;\n        return isSameTree(p-\u003eleft, q-\u003eleft) \u0026\u0026 isSameTree(p-\u003eright, q-\u003eright);\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/leetcode/binary-tree/0101":{"title":"0101.Symmetric Tree","content":"\n## Recursive\n\n```cpp\nclass Solution {\npublic:\n    bool compare(TreeNode* left, TreeNode* right) {\n        if(left == nullptr \u0026\u0026 right == nullptr) return true;\n        if(left != nullptr \u0026\u0026 right == nullptr) return false;\n        if(left == nullptr \u0026\u0026 right != nullptr) return false;\n        if(left-\u003eval != right-\u003eval) return false;\n\n        bool c1 = compare(left-\u003eleft, right-\u003eright);\n        bool c2 = compare(left-\u003eright, right-\u003eleft);\n        return c1 \u0026\u0026 c2;\n    }\n\n    bool isSymmetric(TreeNode* root) {\n        if(root == nullptr) return true;\n        return compare(root-\u003eleft, root-\u003eright);\n    }\n};\n```\n\n## Queue\n\n```cpp\nclass Solution {\npublic:\n    bool isSymmetric(TreeNode* root) {\n        if(root == nullptr) return true;\n        queue\u003cTreeNode*\u003e que;\n        que.push(root-\u003eleft);\n        que.push(root-\u003eright);\n\n        while(!que.empty()) {\n            TreeNode* left = que.front(); que.pop();\n            TreeNode* right = que.front(); que.pop();\n\n            if(left == nullptr \u0026\u0026 right == nullptr) continue;\n            if(left != nullptr \u0026\u0026 right == nullptr) return false;\n            if(left == nullptr \u0026\u0026 right != nullptr) return false;\n            if(left-\u003eval != right-\u003eval) return false;\n            que.push(left-\u003eleft);\n            que.push(right-\u003eright);\n            que.push(left-\u003eright);\n            que.push(right-\u003eleft);\n        }\n\n        return true;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/leetcode/binary-tree/0104":{"title":"0104. Maximum Depth of Binary Tree","content":"\n```cpp\nclass Solution {\npublic:\n    int maxDepth(TreeNode* root) {\n        if(root == nullptr) return 0;\n        return max(maxDepth(root-\u003eleft), maxDepth(root-\u003eright)) + 1;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/leetcode/binary-tree/0105":{"title":"0105.Construct Binary Tree from Preorder and Inorder Traversal","content":"\n```cpp\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(0), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* traverse(vector\u003cint\u003e\u0026 preorder, vector\u003cint\u003e\u0026 inorder, int pl, int pr, int il, int ir) {\n        if(pl == pr) return nullptr;\n\n        TreeNode* root = new TreeNode(preorder[pl]);\n\n        if(pr - pl == 1) return root;\n\n        int delimeter = 0;\n\n        for(delimeter = il; delimeter \u003c ir; delimeter++) {\n            if(inorder[delimeter] == preorder[pl]) {\n                break;\n            }\n        }\n\n        root-\u003eleft = traverse(preorder, inorder, pl+1, pl+1+delimeter-il, il, delimeter);\n        root-\u003eright = traverse(preorder, inorder, pl+1+delimeter-il, pr, delimeter+1, ir);\n        \n        return root;\n    }\n\n    TreeNode* buildTree(vector\u003cint\u003e\u0026 preorder, vector\u003cint\u003e\u0026 inorder) {\n        if(preorder.size() == 0 || inorder.size() == 0) return nullptr;\n        return traverse(preorder, inorder, 0, preorder.size(), 0, inorder.size());\n    }\n};\n```\n","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/leetcode/binary-tree/0106":{"title":"0106.Construct Binary Tree from Inorder and Postorder Traversal","content":"\n```cpp\nstruct TreeNode {\n    int val;\n    TreeNode* left;\n    TreeNode* right;\n    TreeNode() : val(-1), left(nullptr), right(nullptr) {}\n    TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n    TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {}\n};\n\nclass Solution {\npublic:\n    TreeNode* traverse(vector\u003cint\u003e\u0026 inorder, vector\u003cint\u003e\u0026 postorder, int inorderBegin, int inorderEnd, int postorderBegin, int postorderEnd) {\n        if(postorderBegin == postorderEnd) return nullptr;\n\n        TreeNode* root = new TreeNode(postorder[postorderEnd-1]);\n\n        if(postorderEnd - postorderBegin == 1) return root;\n\n        int delimeter = 0;\n        for(delimeter = inorderBegin; delimeter \u003c inorderEnd; delimeter++) {\n            if(inorder[delimeter] == root-\u003eval)\n                break;\n        }\n\n        root-\u003eleft = traverse(inorder, postorder, inorderBegin, delimeter, postorderBegin, postorderBegin + (delimeter - inorderBegin));\n        root-\u003eright = traverse(inorder, postorder, delimeter + 1, inorderEnd, postorderBegin + (delimeter - inorderBegin), postorderEnd-1);\n\n        return root;\n    }\n\n    TreeNode* buildTree(vector\u003cint\u003e\u0026 inorder, vector\u003cint\u003e\u0026 postorder) {\n        if(inorder.size() == 0 || postorder.size() == 0) return nullptr;\n        return traverse(inorder, postorder, 0, inorder.size(), 0 , postorder.size());\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/leetcode/binary-tree/0112":{"title":"0112.Path Sum","content":"\n## Recursive\n\n```cpp\nclass Solution {\npublic:\n    bool traverse(TreeNode* root, int targetSum, int currentSum) {\n        if(root == nullptr) return false;\n        currentSum += root-\u003eval;\n\n        if(root-\u003eleft == nullptr \u0026\u0026 root-\u003eright == nullptr) {\n            return currentSum == targetSum;\n        }\n        \n        return traverse(root-\u003eleft, targetSum, currentSum) || traverse(root-\u003eright, targetSum, currentSum);\n    }\n     \n    bool hasPathSum(TreeNode* root, int targetSum) {\n        if(root == nullptr) return false;\n        return traverse(root, targetSum, 0);\n    }\n};\n```\n\n## Stack\n\n```cpp\nclass Solution {\npublic:\n    bool hasPathSum(TreeNode* root, int targetSum) {\n        if(root == nullptr) return false;\n        \n        stack\u003cpair\u003cTreeNode*, int\u003e\u003e sta;\n        sta.push(make_pair(root, root-\u003eval));\n\n        while(!sta.empty()) {\n            auto node = sta.top();\n            sta.pop();\n\n            if(node.first-\u003eleft == nullptr \u0026\u0026 node.first-\u003eright == nullptr \u0026\u0026 targetSum == node.second) return true;\n\n            if(node.first-\u003eright != nullptr) {\n                sta.push(make_pair(node.first-\u003eright, node.second + node.first-\u003eright-\u003eval));\n            }\n\n            if(node.first-\u003eleft != nullptr) {\n                sta.push(make_pair(node.first-\u003eleft, node.second + node.first-\u003eleft-\u003eval));\n            }\n        }\n        return false;\n    }\n};\n```\n\n## Queue\n\n```cpp\nclass Solution {\npublic:\n    bool hasPathSum(TreeNode* root, int targetSum) {\n        if(root == nullptr) return false;\n        \n        queue\u003cpair\u003cTreeNode*, int\u003e\u003e que;\n        que.push(make_pair(root, root-\u003eval));\n\n        while(!que.empty()) {\n            auto node = que.front();\n            que.pop();\n            \n            if(node.first-\u003eleft == nullptr \u0026\u0026 node.first-\u003eright == nullptr \u0026\u0026 node.second == targetSum) return true;\n            if(node.first-\u003eleft != nullptr) {\n                que.push(make_pair(node.first-\u003eleft, node.second + node.first-\u003eleft-\u003eval));\n            }\n            if(node.first-\u003eright != nullptr) {\n                que.push(make_pair(node.first-\u003eright, node.second + node.first-\u003eright-\u003eval));\n            }\n        }\n        return false;\n    }\n};\n```\n","lastmodified":"2024-04-06T03:11:41.530903706Z","tags":null},"/leetcode/binary-tree/0114":{"title":"0114. Flatten Binary Tree to Linked List","content":"\n## Recursion\n\n```cpp\nclass Solution {\npublic:\n    TreeNode* traverse(TreeNode* root) {\n        if(root == nullptr) return nullptr;\n        if(root-\u003eleft == nullptr \u0026\u0026 root-\u003eright == nullptr) {\n            return root;\n        }\n        TreeNode* leftTail = traverse(root-\u003eleft);\n        TreeNode* rightTail = traverse(root-\u003eright);\n\n        if(leftTail != nullptr) {\n            leftTail-\u003eright = root-\u003eright;\n            root-\u003eright = root-\u003eleft;\n            root-\u003eleft = nullptr;\n        }\n\n        return rightTail != nullptr ? rightTail : leftTail;\n    }\n\n    void flatten(TreeNode* root) {\n        if(root == nullptr) return;\n        traverse(root);\n    }\n};\n```\n\n## Linkedlist\n\n```cpp\nclass Solution {\npublic:\n    void flatten(TreeNode* root) {\n        if(root == nullptr) return;\n        \n        TreeNode* node = root;\n\n        while(node != nullptr) {\n\n            if(node-\u003eleft != nullptr) {\n                TreeNode* rightmost = node-\u003eleft;\n                // find rightmost\n                while(rightmost-\u003eright != nullptr) {\n                    rightmost = rightmost-\u003eright;\n                }\n\n                rightmost-\u003eright = node-\u003eright;\n                node-\u003eright = node-\u003eleft;\n                node-\u003eleft = nullptr;\n            }\n            node = node-\u003eright;\n        }\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/binary-tree/0117":{"title":"0117.Populating Next Right Pointers in Each Node","content":"\n## Level Order Traversal\n\n- Time Comlexity: O(n)\n- Space Complexity: O(n)\n\n```cpp\nclass Solution {\npublic:\n    Node* connect(Node* root) {\n        if(root == nullptr) return nullptr;\n        queue\u003cNode*\u003e que;\n        que.push(root);\n\n        while(!que.empty()) {\n            int size = que.size();\n\n            Node* node = que.front();\n            if(que.front()-\u003eleft != nullptr) que.push(que.front()-\u003eleft);\n            if(que.front()-\u003eright != nullptr) que.push(que.front()-\u003eright);\n            que.pop();\n\n            for(int i = 1; i \u003c size; i++){\n                node-\u003enext = que.front();\n                node = que.front();\n                if(que.front()-\u003eleft != nullptr) que.push(que.front()-\u003eleft);\n                if(que.front()-\u003eright != nullptr) que.push(que.front()-\u003eright);\n                que.pop();\n                \n            }\n\n        }\n\n        return root;\n    }\n};\n```\n\n## Linkedlist\n\n- Time Complexity: O(n)\n- Space Complexity: O(1)\n\n```cpp\nclass Solution {\npublic:\n    Node* prev;\n    Node* leftmost;\n\n    void processChild(Node* childNode) {\n        if(childNode != nullptr) {\n            if(prev != nullptr) {\n                // connect prev to childNode\n                prev-\u003enext = childNode;\n            } else {\n                // set new leftmost to next level\n                leftmost = childNode;\n            }\n            // move prev to childNode\n            prev = childNode; \n        }\n    }\n\n    Node* connect(Node* root) {\n        if(root == nullptr) return nullptr;\n        \n        // left most starts from root\n        leftmost = root;\n        \n        // iterate until there is no leftmost\n        while(leftmost != nullptr){\n            // iterate this level by curr\n            Node* curr = leftmost;\n            prev = nullptr;\n\n            // reset leftmost to track next level leftmost\n            leftmost = nullptr;\n\n            while(curr != nullptr) {\n                processChild(curr-\u003eleft);\n                processChild(curr-\u003eright);\n                curr = curr-\u003enext;\n            }\n        }\n\n        return root;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/binary-tree/0129":{"title":"0129. Sum Root to Leaf Numbers","content":"\n## Recursion\n\n```cpp\nclass Solution {\npublic:\n    int result = 0;\n    void traverse(TreeNode* root, int sum) {\n        if(root == nullptr) return;\n\n        int newSum = sum + root-\u003eval;\n        if(root-\u003eleft == nullptr \u0026\u0026 root-\u003eright == nullptr) {\n            // leaf, add sum to result\n            result += newSum;\n            return;\n        }\n        \n        newSum *= 10;\n        if(root-\u003eleft != nullptr) traverse(root-\u003eleft, newSum);\n        if(root-\u003eright != nullptr) traverse(root-\u003eright, newSum);\n    }\n\n    int sumNumbers(TreeNode* root) {\n        traverse(root, 0);\n        return result;\n    }\n};\n```\n## Stack\n\n```cpp\nclass Solution {\npublic:\n    int sumNumbers(TreeNode* root) {\n        if(root == nullptr) return 0;\n\n        int result = 0;\n        int currentSum = 0;\n\n        stack\u003cpair\u003cTreeNode*,int\u003e\u003e sta;\n\n        sta.push({root, 0});\n\n        while(!sta.empty()) {\n            pair\u003cTreeNode*,int\u003e node = sta.top();\n            sta.pop();\n            \n            currentSum = node.second * 10 + node.first-\u003eval;\n\n            if(node.first-\u003eleft == nullptr \u0026\u0026 node.first-\u003eright == nullptr) {\n                result += currentSum;\n            }\n\n            if(node.first-\u003eright != nullptr) sta.push({node.first-\u003eright, currentSum});\n            if(node.first-\u003eleft != nullptr) sta.push({node.first-\u003eleft, currentSum});\n            \n        }\n\n        return result;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/binary-tree/0222":{"title":"0222.Count Complete Tree Nodes","content":"\n```cpp\nclass Solution {\npublic:\n    int countNodes(TreeNode* root) {\n        if(root == nullptr) return 0;\n        return countNodes(root-\u003eleft) + countNodes(root-\u003eright) + 1;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/binary-tree/0226":{"title":"0226.Invert Binary Tree","content":"\n## Recursive\n\n```cpp\nclass Solution {\npublic:\n    TreeNode* invertTree(TreeNode* root) {\n        if(root == nullptr) return nullptr;\n        swap(root-\u003eleft, root-\u003eright);\n        invertTree(root-\u003eleft);\n        invertTree(root-\u003eright);\n        return root;\n    }\n};\n```\n\n## Stack\n\n```cpp\nclass Solution {\npublic:\n TreeNode* invertTree(TreeNode* root) {\n        if(root == nullptr) return nullptr;\n        stack\u003cTreeNode*\u003e sta;\n        sta.push(root);\n        while(!sta.empty()){\n            TreeNode* node = sta.top();\n            sta.pop();\n            swap(node-\u003eleft, node-\u003eright);\n            if(node-\u003eright != nullptr) sta.push(node-\u003eright);\n            if(node-\u003eleft != nullptr) sta.push(node-\u003eleft);\n        }\n        return root;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/binary-tree/0236":{"title":"0236. Lowest Common Ancestor of a Binary Tree","content":"\n```cpp\nclass Solution {\npublic:\n    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {\n        if(root == nullptr) return nullptr;\n        if(root == p || root == q) return root;\n\n        TreeNode* left = lowestCommonAncestor(root-\u003eleft, p, q);\n        TreeNode* right = lowestCommonAncestor(root-\u003eright, p, q);\n\n        if(left != nullptr \u0026\u0026 right != nullptr) {\n            return root;\n        }\n        \n        return left != nullptr ? left : right;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/design/":{"title":"","content":"","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/design/0146":{"title":"0146.LRU Cache","content":"\n```cpp\nstruct Node {\n    int key;\n    int val;\n    Node* next;\n    Node* prev;\n    Node(int key, int val) : key(key), val(val), next(nullptr), prev(nullptr){}\n};\n\nclass LRUCache {\npublic:\n    int cap;\n    Node* head = new Node(-1, -1);\n    Node* tail = new Node(-1, -1);\n\n    unordered_map\u003cint, Node*\u003e kv;\n\n    LRUCache(int capacity) {\n        this-\u003ecap = capacity;\n        head-\u003enext = tail;\n        tail-\u003eprev = head;\n    }\n\n    void removeNode(Node* curr) {\n        // prev -\u003e curr -\u003e next;\n        Node* prev = curr-\u003eprev;\n        Node* next = curr-\u003enext;\n        prev-\u003enext = next;\n        next-\u003eprev = prev;\n    }\n\n    void addNode(Node* curr) {\n        // head -\u003e next;\n        Node* next = head-\u003enext;\n        head-\u003enext = curr;\n        curr-\u003eprev = head;\n        curr-\u003enext = next;\n        next-\u003eprev = curr;\n    }\n    \n    // If not found, return -1\n    // If found,\n    //  1. Move to the head\n    int get(int key) {\n        if(kv.find(key) == kv.end()) return -1;\n        \n        Node* node = kv[key];\n        removeNode(node);\n        addNode(node);\n        return node-\u003eval;\n    }\n    \n    // If found, move to head\n    // else\n    //   if meet capacity, remove tail-\u003eprev and add newNode\n    void put(int key, int value) {\n        if(kv.find(key) != kv.end()){\n            Node* node = kv[key];\n            node-\u003eval = value;\n            removeNode(node);\n            addNode(node);\n            return;\n        }\n\n        if(kv.size() == cap){\n            Node* garbage = tail-\u003eprev;\n            kv.erase(tail-\u003eprev-\u003ekey);\n            removeNode(tail-\u003eprev);\n            delete garbage;\n        }\n\n        Node* newNode = new Node(key, value);\n        addNode(newNode);\n        kv[key] = newNode;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/divide_conquer/":{"title":"","content":"","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/divide_conquer/0108":{"title":"0108. Convert Sorted Array to Binary Search Tree","content":"\n```cpp\nclass Solution {\npublic:\n    TreeNode* sortedArrayToBST(vector\u003cint\u003e\u0026 nums) {\n        if(nums.size() == 0) return nullptr;\n        int mid = nums.size() / 2;\n        TreeNode* root = new TreeNode(nums[mid]);\n        vector\u003cint\u003e leftNodes(nums.begin(), nums.begin() + mid);\n        vector\u003cint\u003e rightNodes(nums.begin() + mid + 1, nums.end());\n        root-\u003eleft = sortedArrayToBST(leftNodes);\n        root-\u003eright = sortedArrayToBST(rightNodes);\n        return root;\n    }\n};\n```\n\n```cpp\nclass Solution {\npublic:\n    TreeNode* helper(vector\u003cint\u003e\u0026 nums, int left, int right) {\n        if(left \u003e right) return nullptr;\n        int mid = left + (right - left) / 2;\n        TreeNode* root = new TreeNode(nums[mid]);\n        root-\u003eleft = helper(nums, left, mid - 1);\n        root-\u003eright = helper(nums, mid + 1, right);\n        return root;\n    }\n    TreeNode* sortedArrayToBST(vector\u003cint\u003e\u0026 nums) {\n        if(nums.size() == 0) return nullptr;\n        return helper(nums, 0, nums.size() - 1);\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/divide_conquer/0148":{"title":"0148. Sort List","content":"\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* findMiddle(ListNode* head) {\n        ListNode* fast = head;\n        ListNode* slow = nullptr;\n\n        while(fast != nullptr \u0026\u0026 fast-\u003enext != nullptr) {\n            fast = fast-\u003enext-\u003enext;\n            slow = (slow == nullptr) ? head : slow-\u003enext;\n        }\n\n        ListNode* mid = slow-\u003enext;\n        slow-\u003enext = nullptr;\n        return mid;\n    }\n\n    ListNode* merge(ListNode* left, ListNode* right) {\n        ListNode* dummy = new ListNode(-1);\n        ListNode* curr = dummy;\n\n        while(left != nullptr \u0026\u0026 right != nullptr) {\n            if(left-\u003eval \u003c right-\u003eval) {\n                curr-\u003enext = left;\n                left = left-\u003enext;\n            } else {\n                curr-\u003enext = right;\n                right = right-\u003enext;\n            }\n            curr = curr-\u003enext;\n        }\n\n        if(left != nullptr) {\n            curr-\u003enext = left;\n        } else {\n            curr-\u003enext = right;\n        }\n\n        return dummy-\u003enext;\n    }\n\n    ListNode* sortList(ListNode* head) {\n        if(head == nullptr) return nullptr;\n        if(head-\u003enext == nullptr) return head;\n        ListNode* mid = findMiddle(head);\n        ListNode* left = sortList(head);\n        ListNode* right = sortList(mid);\n        return merge(left, right);\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/divide_conquer/0427":{"title":"0427. Construct Quad Tree","content":"\n```cpp\n/*\n// Definition for a QuadTree node.\nclass Node {\npublic:\n    bool val;\n    bool isLeaf;\n    Node* topLeft;\n    Node* topRight;\n    Node* bottomLeft;\n    Node* bottomRight;\n    \n    Node() {\n        val = false;\n        isLeaf = false;\n        topLeft = NULL;\n        topRight = NULL;\n        bottomLeft = NULL;\n        bottomRight = NULL;\n    }\n    \n    Node(bool _val, bool _isLeaf) {\n        val = _val;\n        isLeaf = _isLeaf;\n        topLeft = NULL;\n        topRight = NULL;\n        bottomLeft = NULL;\n        bottomRight = NULL;\n    }\n    \n    Node(bool _val, bool _isLeaf, Node* _topLeft, Node* _topRight, Node* _bottomLeft, Node* _bottomRight) {\n        val = _val;\n        isLeaf = _isLeaf;\n        topLeft = _topLeft;\n        topRight = _topRight;\n        bottomLeft = _bottomLeft;\n        bottomRight = _bottomRight;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    bool isDifferent(vector\u003cvector\u003cint\u003e\u003e\u0026 grid, int rowStart, int rowEnd, int colStart, int colEnd) {\n        int curr = grid[rowStart][colStart];\n\n        for(int i = rowStart; i \u003c= rowEnd; i++) {\n            for(int j = colStart; j \u003c= colEnd; j++) {\n                if(grid[i][j] != curr) return true;\n            }\n        }\n        return false;\n    }\n\n    Node* build(vector\u003cvector\u003cint\u003e\u003e\u0026 grid, int rowStart, int rowEnd, int colStart, int colEnd) {\n        Node* root = new Node();\n        root-\u003eval = 1;\n        \n        if(isDifferent(grid, rowStart, rowEnd, colStart, colEnd) == false) {\n            root-\u003eval = grid[rowStart][colStart];\n            root-\u003eisLeaf = true;\n            return root;\n        }\n        \n        int rowMid = rowStart + (rowEnd - rowStart) / 2;\n        int colMid = colStart + (colEnd - colStart) / 2;\n        root-\u003etopLeft = build(grid, rowStart, rowMid, colStart, colMid);\n        root-\u003etopRight = build(grid, rowStart, rowMid, colMid+1, colEnd);\n        root-\u003ebottomLeft = build(grid, rowMid+1, rowEnd, colStart, colMid);\n        root-\u003ebottomRight = build(grid, rowMid+1, rowEnd, colMid+1, colEnd);\n        return root;\n    }\n\n    Node* construct(vector\u003cvector\u003cint\u003e\u003e\u0026 grid) {\n        int m = grid.size();\n        int n = grid[0].size();\n\n        return build(grid, 0, m-1, 0, n-1);\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/dp/":{"title":"","content":"","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/dp/0063":{"title":"0063. Unique Path II","content":"\n```cpp\nclass Solution {\npublic:\n    int uniquePathsWithObstacles(vector\u003cvector\u003cint\u003e\u003e\u0026 obstacleGrid) {\n        int m = obstacleGrid.size();\n        int n = obstacleGrid[0].size();\n\n        int dp[m][n];\n\n        memset(dp, 0, sizeof(dp));\n\n        for(int i = 0; i \u003c m \u0026\u0026 obstacleGrid[i][0] == 0; i++) dp[i][0] = 1;\n        for(int j = 0; j \u003c n \u0026\u0026 obstacleGrid[0][j] == 0; j++) dp[0][j] = 1;\n\n        for(int i = 1; i \u003c m; i++) {\n            for(int j = 1; j \u003c n; j++) {\n                if(obstacleGrid[i][j] != 1) {\n                    dp[i][j] = dp[i-1][j] + dp[i][j-1];\n                } \n            }\n        }\n\n        return dp[m-1][n-1];\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/dp/0123":{"title":"0123. Best Time to Buy and Sell Stock III","content":"\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector\u003cint\u003e\u0026 prices) {\n        int firstBuy = -prices[0];\n        int firstSell = 0;\n        int secondBuy = -prices[0];\n        int secondSell = 0;\n\n        for(int i = 1; i \u003c prices.size(); i++) {\n            firstBuy = max(firstBuy, -prices[i]);\n            firstSell = max(firstSell, prices[i] + firstBuy);\n            secondBuy = max(secondBuy, -prices[i] + firstSell);\n            secondSell = max(secondSell, prices[i] + secondBuy);\n        }\n\n        return secondSell;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/dp/0139":{"title":"0139. Word Break","content":"\n```cpp\nclass Solution {\npublic:\n    bool wordBreak(string s, vector\u003cstring\u003e\u0026 wordDict) {\n        unordered_set\u003cstring\u003e wordSet(wordDict.begin(), wordDict.end());\n        int n = s.size();\n        // dp[i]: sub string length i can be segament in Dict\n        vector\u003cbool\u003e dp(n + 1, false);\n        \n        dp[0] = true;   \n        \n        // Because the order of the string is important\n        // Iterate bag then iterate items\n        for(int i = 1; i \u003c= n; i++) {\n            for(int j = 0; j \u003c i; j++) {\n                string sub = s.substr(j, i - j);\n                if(dp[j] == true \u0026\u0026 wordSet.find(sub) != wordSet.end()) {\n                    dp[i] = true;\n                }\n            }\n        }\n        return dp[n];\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/dp/0188":{"title":"0188. Best Time to Buy and Sell Stock IV","content":"\n```cpp\nclass Solution {\npublic:\n    int maxProfit(int k, vector\u003cint\u003e\u0026 prices) {\n        // Do nothing, firstBuy, firstSell, secondBuy, secondSell, ...\n        vector\u003cint\u003e dp(2 * k + 1);\n\n        for(int i = 1; i \u003c 2 * k + 1; i += 2) {\n            dp[i] = -prices[0];\n        }\n\n        for(int i = 1; i \u003c prices.size(); i++) {\n            for(int j = 1; j \u003c 2 * k + 1; j++) {\n                if(j % 2 == 1) {\n                    // buy score\n                    // last day sell score - today stock price\n                    dp[j] = max(dp[j], dp[j-1] - prices[i]);\n                } else {\n                    // sell score\n                    // today stock price + last day buy score\n                    dp[j] = max(dp[j], prices[i] + dp[j-1]);\n                }\n            }\n        }\n\n        return dp[2 * k];\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/dp/0279":{"title":"0279. Perfect Squares","content":"\n```cpp\nclass Solution {\npublic:\n    int numSquares(int n) {\n        // dp[i] = least number of perfect square numbers\n        vector\u003cint\u003e dp(n+1, 10001);\n        dp[0] = 0;\n        for(int i = 0; i \u003c= n; i++) {\n            for(int j = 1; j * j \u003c= i; j++) {\n                dp[i] = min(dp[i], dp[i - j*j] + 1);\n            }\n        }\n\n        return dp[n] == 10001 ? 0 : dp[n];\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/dp/0309":{"title":"0309. Best Time to Buy and Sell Stock with Cooldown","content":"\n### 2-DP\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector\u003cint\u003e\u0026 prices) {\n        int n = prices.size();\n        vector\u003cvector\u003cint\u003e\u003e dp(n, vector\u003cint\u003e(4));\n\n        for(int i = 0; i \u003c n; i++) {\n            dp[i][0] = -prices[0];\n        }\n\n        for(int i = 1; i \u003c n; i++) {\n            dp[i][0] = max(dp[i-1][0], max(dp[i-1][1] - prices[i], dp[i-1][3] - prices[i]));\n            dp[i][1] = max(dp[i-1][3], dp[i-1][1]);\n            dp[i][2] = dp[i-1][0] + prices[i];\n            dp[i][3] = dp[i-1][2];\n        }\n\n        return max(dp[n-1][1], max(dp[n-1][2], dp[n-1][3]));\n    }\n};\n```\n\n### 1-DP\n\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector\u003cint\u003e\u0026 prices) {\n        int n = prices.size();\n        vector\u003cint\u003e dp(4);\n        dp[0] = -prices[0];\n\n        for(int i = 1; i \u003c n; i++) {\n            int temp = dp[0];\n            int temp2 = dp[2];\n\n            dp[0] = max(dp[0], max(dp[1] - prices[i], dp[3] - prices[i]));\n            dp[1] = max(dp[3], dp[1]);\n            dp[2] = temp + prices[i];\n            dp[3] = temp2;\n        }\n\n        return max(dp[1], max(dp[2], dp[3]));\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/dp/0322":{"title":"0322. Coin Change","content":"\n```cpp\nclass Solution {\npublic:\n    int coinChange(vector\u003cint\u003e\u0026 coins, int amount) {\n        // dp[j]: fewest number of coins to make amount=j\n        // dp[j] = min(dp[j], dp[j - coins[i]] + 1)\n\n        // max will be amount+1 because the min value of coin is 1\n        // only possible amount of coins is amount\n        vector\u003cint\u003e dp(amount+1, amount+1);\n        dp[0] = 0;\n\n        for(int coin : coins) {\n            for(int j = coin; j \u003c= amount; j++) {\n                dp[j] = min(dp[j], dp[j - coin] + 1);\n            }\n        }\n\n        if(dp[amount] \u003e amount) return -1;\n        return dp[amount];\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/dp/0518":{"title":"0518. Coin Change II","content":"\n```cpp\nclass Solution {\npublic:\n    int change(int amount, vector\u003cint\u003e\u0026 coins) {\n        // dp[j] = number of combination to make amount = j\n        int dp[amount+1];\n        memset(dp, 0, sizeof(dp));\n\n        dp[0] = 1;\n\n        for(int coin : coins) {\n            for(int j = coin; j \u003c= amount; j++) {\n                dp[j] += dp[j - coin];\n            }\n        }\n\n        return dp[amount];\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/graph/":{"title":"","content":"","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/graph/0130":{"title":"130.Surrounded Regions","content":"\n## DFS\n\n```cpp\nclass Solution {\npublic:\n    void dfs(vector\u003cvector\u003cchar\u003e\u003e\u0026 board, int i, int j, char c) {\n        if(i \u003c 0 || i \u003e= board.size() || j \u003c 0 || j \u003e= board[0].size() || board[i][j] != 'O') return;\n        board[i][j] = c;\n        dfs(board, i-1, j, c);\n        dfs(board, i+1, j, c);\n        dfs(board, i, j-1, c);\n        dfs(board, i, j+1, c);\n    }\n\n    void solve(vector\u003cvector\u003cchar\u003e\u003e\u0026 board) {\n        int m = board.size();\n        int n = board[0].size();\n\n        for(int i = 0; i \u003c m; i++) {\n            if(board[i][0] == 'O') dfs(board, i , 0, 'A');\n            if(board[i][n-1] == 'O') dfs(board, i, n-1, 'A');\n        }\n\n        for(int j = 0; j \u003c n; j++) {\n            if(board[0][j] == 'O') dfs(board, 0, j, 'A');\n            if(board[m-1][j] == 'O') dfs(board, m-1, j, 'A');\n        }\n\n        for(int i = 0; i \u003c m; i++) {\n            for(int j = 0; j \u003c n; j++) {\n                if(board[i][j] == 'O') {\n                    board[i][j] = 'X';\n                }\n                if(board[i][j] == 'A') {\n                    board[i][j] = 'O';\n                }\n            }\n        }\n\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/graph/0133":{"title":"0133.Clone Graph","content":"\n## DFS\n\n```cpp\nclass Solution {\npublic:\n    unordered_map\u003cint, Node*\u003e visited;\n    Node* cloneGraph(Node* node) {\n        if(node == nullptr) return nullptr;\n        if(visited.find(node-\u003eval) != visited.end()) {\n            return visited[node-\u003eval];\n        }\n\n        Node* newNode = new Node(node-\u003eval);\n        visited[node-\u003eval] = newNode;\n\n        for(auto neighbor : node-\u003eneighbors) {\n            newNode-\u003eneighbors.emplace_back(cloneGraph(neighbor));\n        }\n        \n        return newNode;\n    }\n};\n```\n\n## BFS\n\n```cpp\nclass Solution {\npublic:\n    Node* cloneGraph(Node* node) {\n        if(node == nullptr) return nullptr;\n        \n        queue\u003cNode*\u003e que;\n        unordered_map\u003cint, Node*\u003e visited;\n\n        Node* newNode = new Node(node-\u003eval);\n        visited[node-\u003eval] = newNode;\n        que.push(node);\n\n        while(!que.empty()) {\n            Node* current = que.front();\n            que.pop();\n\n            for(auto neighbor : current-\u003eneighbors) {\n                // if this point is not visited before\n                // create a new node with this value\n                if(visited.find(neighbor-\u003eval) == visited.end()) {\n                    Node* child = new Node(neighbor-\u003eval);\n                    visited[neighbor-\u003eval] = child;\n                    que.push(neighbor);\n                }\n                // insert to the current's neighbors\n                visited[current-\u003eval]-\u003eneighbors.emplace_back(visited[neighbor-\u003eval]);\n            }\n        }\n\n        return visited[node-\u003eval];\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/graph/0200":{"title":"0200.Number of Islands","content":"\n## DFS\n\n- Time Complexity: O(M*N)\n- Space Complexity: O(M*N)\n\n```cpp\nclass Solution {\npublic:\n    void dfs(vector\u003cvector\u003cchar\u003e\u003e\u0026 grid, int i, int j) {\n        if(i \u003c 0 || i \u003e= grid.size() || j \u003c 0 || j \u003e= grid[0].size() || grid[i][j] != '1') return;\n        grid[i][j] = '2';\n        dfs(grid, i+1, j);\n        dfs(grid, i-1, j);\n        dfs(grid, i, j+1);\n        dfs(grid, i, j-1);\n    }\n\n    int numIslands(vector\u003cvector\u003cchar\u003e\u003e\u0026 grid) {\n        int m = grid.size();\n        int n = grid[0].size();\n        int result = 0;\n\n        for(int i = 0; i \u003c m; i++) {\n            for(int j = 0; j \u003c n; j++) {\n                if(grid[i][j] == '1') {\n                    result++;\n                    dfs(grid, i, j);\n                }\n            }\n        }\n\n        return result;\n    }\n};\n```\n\n## BFS\n\n- Time Complexity: O(M*N)\n- Space Complexity: \n\n```cpp\nclass Solution {\npublic:\n    int numIslands(vector\u003cvector\u003cchar\u003e\u003e\u0026 grid) {\n        \n        int result = 0;\n        int m = grid.size();\n        int n = grid[0].size();\n\n\n        for(int i = 0; i \u003c m; i++) {\n            for(int j = 0; j \u003c n; j++) {\n                if(grid[i][j] == '1') {\n                    ++result;\n                    queue\u003cpair\u003cint,int\u003e\u003e que;\n                    que.push({i, j});\n                    grid[i][j] = '2';\n\n                    while(!que.empty()) {\n                        auto node = que.front();\n                        que.pop();\n                        int row = node.first;\n                        int col = node.second;\n                        if(row-1 \u003e= 0 \u0026\u0026 grid[row-1][col] == '1') {\n                            que.push({row-1, col});\n                            grid[row-1][col] = '2';\n                        }\n                        if(row+1 \u003c m \u0026\u0026 grid[row+1][col] == '1') {\n                            que.push({row+1, col});\n                            grid[row+1][col] = '2';\n                        }\n                        if(col-1 \u003e= 0 \u0026\u0026 grid[row][col-1] == '1') {\n                            que.push({row, col-1});\n                            grid[row][col-1] = '2';\n                        }\n                        if(col+1 \u003c n \u0026\u0026 grid[row][col+1] == '1') {\n                            que.push({row, col+1});\n                            grid[row][col+1] = '2';\n                        }\n                    }\n                    \n                }\n            }\n        }\n\n        return result;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/graph/0201":{"title":"0210. Course Schedule II","content":"\n```cpp\nclass Solution {\npublic:\n    vector\u003cint\u003e findOrder(int numCourses, vector\u003cvector\u003cint\u003e\u003e\u0026 prerequisites) {\n        vector\u003cvector\u003cint\u003e\u003e graph(numCourses);\n        vector\u003cint\u003e indegree(numCourses);\n        vector\u003cint\u003e result;\n        queue\u003cint\u003e que;\n\n        for(auto\u0026 pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n            indegree[pre[0]]++;\n        }\n\n        for(int i = 0; i \u003c numCourses; i++) {\n            if(indegree[i] == 0) que.push(i);\n        }\n\n        if(que.empty() == true) return {};\n\n        int nodeVisited = 0;\n        while(que.empty() == false) {\n            int current = que.front();\n            que.pop();\n            nodeVisited++;\n            result.push_back(current);\n\n            for(auto\u0026 edge : graph[current]) {\n                indegree[edge]--;\n                if(indegree[edge] == 0) que.push(edge);\n            }\n        }\n\n        if(nodeVisited != numCourses) return {};\n        return result;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/graph/0207":{"title":"0207.Course Schedule","content":"\n## DFS\n\nDraw colors\n- 0: unvisited\n- 1: visiting\n- 2: visited\n\n```cpp\nclass Solution {\npublic:\n    bool isCycle(vector\u003cvector\u003cint\u003e\u003e\u0026 graph, vector\u003cint\u003e\u0026 visited, int current) {\n        if(visited[current] == 1) return true;\n        if(visited[current] == 2) return false;\n\n        visited[current] = 1;\n        for(int\u0026 edge : graph[current]) {\n            if(isCycle(graph, visited, edge) == true) return true;\n        }        \n\n        visited[current] = 2;\n        return false;\n    }\n\n    bool canFinish(int numCourses, vector\u003cvector\u003cint\u003e\u003e\u0026 prerequisites) {\n        vector\u003cvector\u003cint\u003e\u003e graph(numCourses, vector\u003cint\u003e(0));\n\n        // Establish graph\n        for(auto pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n        }\n\n        // 0: unvisited\n        // 1: visiting\n        // 2: visited\n        vector\u003cint\u003e visited(numCourses, 0);\n\n        for(int i = 0; i \u003c numCourses; i++) {\n            if(isCycle(graph, visited, i) == true) return false;\n        }\n\n        return true;\n    }\n};\n\n```\n\n## Topological Sort\n\n```cpp\nclass Solution {\npublic:\n    bool canFinish(int numCourses, vector\u003cvector\u003cint\u003e\u003e\u0026 prerequisites) {\n        vector\u003cvector\u003cint\u003e\u003e graph(numCourses);\n        vector\u003cint\u003e indegree(numCourses);\n        queue\u003cint\u003e que;\n\n        for(auto\u0026 pre : prerequisites) {\n            graph[pre[1]].push_back(pre[0]);\n            indegree[pre[0]]++;\n        }\n\n        for(int i = 0; i \u003c numCourses; i++) {\n            // put indegree = 0 node into queue\n            if(indegree[i] == 0) que.push(i);\n        }\n\n        if(que.empty() == true) return false;\n\n        int nodeVisited = 0;\n\n        while(que.empty() == false) {\n            int current = que.front();\n            que.pop();\n            nodeVisited++;\n            // iterate all neighbors\n            for(auto\u0026 neighbor : graph[current]) {\n                indegree[neighbor]--;\n                // put neighbor if indegree decreases to zero\n                if(indegree[neighbor] == 0) que.push(neighbor);\n            }\n        }\n\n        // if not all visited, return false\n        return nodeVisited == numCourses;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/graph/0433":{"title":"0433. Minimum Genetic Mutation","content":"\n```cpp\nclass Solution {\npublic:\n    int minMutation(string startGene, string endGene, vector\u003cstring\u003e\u0026 bank) {\n        unordered_set\u003cstring\u003e bankSet(bank.begin(), bank.end());\n        unordered_set\u003cstring\u003e seen;\n        queue\u003cstring\u003e que;\n\n        int level = 0;\n        que.push(startGene);\n        seen.insert(startGene);\n\n        while(!que.empty()) {\n            int size = que.size();\n\n            // use level order traversal\n            for(int i = 0; i \u003c size; i++) {\n                string currGene = que.front();\n                que.pop();\n\n                // if currGene is equal to endGene, return step\n                if(currGene == endGene) return level;\n\n                for(char c : \"ATCG\") {\n                    for(int i = 0; i \u003c 8; i++) {\n                        string updateGene = currGene;\n                        // only update a character\n                        updateGene[i] = c;\n\n                        // if we visit the gene before, we should not visit again\n                        if(bankSet.count(updateGene) == 1 \u0026\u0026 seen.count(updateGene) == 0) {\n                            que.push(updateGene);\n                            seen.insert(updateGene);\n                        }\n                    }\n                }\n            }\n\n            level++;\n        }\n\n        // if no gene is equal to endGene, return -1\n        return -1;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/graph/0695":{"title":"0695. Max Area of Island","content":"\n## DFS\n\n```cpp\nclass Solution {\npublic:\n    int space;\n    int result = 0;\n    void dfs(vector\u003cvector\u003cint\u003e\u003e\u0026 grid, int i, int j) {\n        if(i \u003c 0 || i \u003e= grid.size() || j \u003c 0 || j \u003e= grid[0].size() || grid[i][j] != 1) return;\n        grid[i][j] = 2;\n        space++;\n        dfs(grid, i+1, j);\n        dfs(grid, i-1, j);\n        dfs(grid, i, j-1);\n        dfs(grid, i, j+1);\n    }\n\n    int maxAreaOfIsland(vector\u003cvector\u003cint\u003e\u003e\u0026 grid) {\n        for(int i = 0; i \u003c grid.size(); i++) {\n            for(int j = 0; j \u003c grid[0].size(); j++) {\n                if(grid[i][j] == 1) {\n                    space = 0;\n                    dfs(grid, i, j);\n                    result = max(result, space);\n                }\n            }\n        }\n        return result;\n    }\n};\n```\n\n## BFS\n\n```cpp\nclass Solution {\npublic:\n    int maxAreaOfIsland(vector\u003cvector\u003cint\u003e\u003e\u0026 grid) {\n        vector\u003cvector\u003cint\u003e\u003e directions = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};\n        int result = 0;\n\n        for(int i = 0; i \u003c grid.size(); i++) {\n            for(int j = 0; j \u003c grid[0].size(); j++) {\n                if(grid[i][j] == 1) {\n                    // start bfs\n                    queue\u003cpair\u003cint,int\u003e\u003e que;\n                    que.push({i, j});\n                    grid[i][j] = 0;     // remember to label visited\n                    int space = 1;\n\n                    while(!que.empty()) {\n                        auto node = que.front();\n                        que.pop();\n\n                        for(auto dir : directions) {\n                            int row = node.first + dir[0];\n                            int col = node.second + dir[1];\n\n                            if(row \u003c 0 || row \u003e= grid.size() || col \u003c 0 || col \u003e= grid[0].size() || grid[row][col] != 1) {\n                                continue;\n                            }\n                            grid[row][col] = 2;\n                            space++;\n                            que.push({row, col});\n                        }\n                    }\n                    result = max(result, space);\n                }\n            }\n        }\n        return result;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/graph/0797":{"title":"0797.All Paths From Source to Target","content":"\n```cpp\nclass Solution {\npublic:\n    vector\u003cvector\u003cint\u003e\u003e result;\n    vector\u003cint\u003e path;\n    \n    void dfs(vector\u003cvector\u003cint\u003e\u003e\u0026 graph, int current) {\n        if(current == graph.size() - 1) {\n            result.emplace_back(path);\n            return;\n        }\n\n        for(int i = 0; i \u003c graph[current].size(); i++) {\n            path.emplace_back(graph[current][i]);\n            dfs(graph, graph[current][i]);\n            path.pop_back();\n        }\n    }\n\n    vector\u003cvector\u003cint\u003e\u003e allPathsSourceTarget(vector\u003cvector\u003cint\u003e\u003e\u0026 graph) {\n        path.emplace_back(0);\n        dfs(graph, 0);\n        return result;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/graph/0909":{"title":"0909. Snakes and Ladders","content":"\n## BFS\n\n```cpp\nclass Solution {\npublic:\n    int snakesAndLadders(vector\u003cvector\u003cint\u003e\u003e\u0026 board) {\n        int n = board.size();\n\n        // Create a mapping between pos and {row,col}\n        vector\u003cpair\u003cint,int\u003e\u003e posMap(n * n + 1);\n        int pdx = 1;\n        int revFlag = 0; // col is reverse\n        \n        for(int row = n - 1; row \u003e= 0; row--) {\n            for(int col = 0; col \u003c n; col++) {\n                posMap[pdx++] = (revFlag == 0) ? make_pair(row, col) : make_pair(row, n - 1 - col);\n            }\n            revFlag = !revFlag; // reverse the flag\n        }\n\n        vector\u003cint\u003e dist(n * n + 1, -1);\n        dist[1] = 0;    // start from 1\n        queue\u003cint\u003e que;\n        que.push(1);\n\n        // start BFS\n        while(!que.empty()) {\n            int curr = que.front();\n            que.pop();\n\n            for(int next = curr + 1; next \u003c= min(curr + 6, n * n); next++) {\n                // fetch row and col from posMap\n                auto [row, col] = posMap[next];\n                // calculate the destination\n                // if there is a stairs or snake, move to new pos\n                // otherwise, just move to next\n                int destination = board[row][col] != -1 ? board[row][col] : next;\n\n                // if we do not visit destination before, move from curr and add one step\n                if(dist[destination] == -1) {\n                    dist[destination] = dist[curr] + 1;\n                    que.push(destination);\n                }\n            }\n        }\n        return dist[n * n];\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/greedy/":{"title":"","content":"","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/greedy/121":{"title":"0121.Best Time to Buy and Sell Stock","content":"\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector\u003cint\u003e\u0026 prices) {\n        int result = 0;\n        int minPrice = 100000;\n\n        for(int\u0026 price : prices) {\n            // find minPrice\n            // if price is smaller than minPrice, replace minPrice\n            // else, stock can be selled, compare to the result\n            if(price \u003c minPrice){\n                minPrice = price;\n            } else {\n                result = max(result, price - minPrice);\n            }\n        }\n\n        return result;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/hashmap/":{"title":"","content":"","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/hashmap/0036":{"title":"0036.Valid Sudoku","content":"\n```cpp\nclass Solution {\npublic:\n    bool isValidSudoku(vector\u003cvector\u003cchar\u003e\u003e\u0026 board) {\n        int m = board.size();\n        int n = board[0].size();\n\n        int columnMap[9][9];\n        int rowMap[9][9];\n        int threeMap[9][9];\n\n        memset(rowMap, 0, sizeof(rowMap));\n        memset(columnMap, 0, sizeof(columnMap));\n        memset(threeMap, 0, sizeof(threeMap));\n\n        for(int i = 0; i \u003c m; i++){\n            for(int j = 0; j \u003c n; j++){\n                if(isdigit(board[i][j])) {\n                    int idx = board[i][j] - '1';\n\n                    // columnMap\n                    if(columnMap[j][idx] != 0) return false;\n                    columnMap[j][idx] = 1;\n\n                    // rowMap\n                    if(rowMap[i][idx] != 0) return false;\n                    rowMap[i][idx] = 1;\n\n                    // threeMap\n                    int threeIdx = i/3 * 3 + j/3;\n                    if(threeMap[threeIdx][idx] != 0) return false;\n                    else threeMap[threeIdx][idx] = 1;\n                }\n            }\n        }\n\n        return true;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/hashmap/0049":{"title":"0049.Group Anagrams","content":"\n```cpp\nclass Solution {\npublic:\n    vector\u003cvector\u003cstring\u003e\u003e groupAnagrams(vector\u003cstring\u003e\u0026 strs) {\n        unordered_map\u003cstring, vector\u003cstring\u003e\u003e map1;\n        vector\u003cvector\u003cstring\u003e\u003e result;\n\n        for(string str : strs){\n            string key = str;\n            sort(key.begin(), key.end());\n            map1[key].push_back(str);\n        }\n\n        for(auto it = map1.begin(); it != map1.end(); it++){\n            result.push_back(it-\u003esecond);\n        }\n\n        return result;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/hashmap/0128":{"title":"0128.Longest Consecutive Sequence","content":"\n```cpp\nclass Solution {\npublic:\n    int longestConsecutive(vector\u003cint\u003e\u0026 nums) {\n        unordered_set\u003cint\u003e set1;\n        int result = 0;\n\n        for(int\u0026 num : nums){\n            set1.insert(num);\n        }\n\n        for(int\u0026 num : nums){\n            int start;\n            if(set1.find(num-1) == set1.end()){\n                start = num;\n            }\n\n            int distance = 0;\n            while(set1.find(start) != set1.end()){\n                start = start + 1;\n                distance++;\n            }\n\n            result = max(result, distance);\n        }\n\n        return result;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/hashmap/0202":{"title":"0202.Happy Number","content":"\n```cpp\nclass Solution {\npublic:\n    bool isHappy(int n) {\n        int sum = 0;\n        unordered_set\u003cint\u003e sumSet;\n\n        while(1){\n            sum = 0;\n            while(n \u003e 0){\n                int digit = n % 10;\n                sum += (digit * digit);\n                n /= 10;\n            }\n\n            if(sum == 1) return true;\n\n            if(sumSet.find(sum) != sumSet.end()) return false;\n            else  sumSet.insert(sum);\n\n            n = sum;\n        }\n\n        return false;\n    }\n};\n```\n\n```cpp\nclass Solution {\npublic:\n    unordered_set\u003cint\u003e sumSet;\n\n    int getNext(int num){\n        int sum = 0;\n\n        while(num \u003e 0){\n            int digit = num % 10;\n            sum += (digit * digit);\n            num /= 10;\n        }\n\n        return sum;\n    }\n    bool isHappy(int n) {\n        \n        while(n != 1 \u0026\u0026 sumSet.find(n) == sumSet.end()){\n            sumSet.insert(n);\n            n = getNext(n);\n        }\n\n        return n == 1;\n    }\n};\n```\n\n```cpp\nclass Solution {\npublic:\n\n    int getNext(int num){\n        int sum = 0;\n\n        while(num \u003e 0){\n            int digit = num % 10;\n            sum += (digit * digit);\n            num /= 10;\n        }\n\n        return sum;\n    }\n\n    bool isHappy(int n) {\n        int slow = n;\n        int fast = getNext(n);\n\n        while(fast != 1 \u0026\u0026 fast != slow){\n            slow = getNext(slow);\n            fast = getNext(getNext(fast));\n        }\n\n        return fast == 1;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/hashmap/0219":{"title":"0219. Contains Duplicated II","content":"\n```cpp\nclass Solution {\npublic:\n    bool containsNearbyDuplicate(vector\u003cint\u003e\u0026 nums, int k) {\n        unordered_map\u003cint, int\u003e num2FirstIdx;\n\n        for(int i = 0; i \u003c nums.size(); i++) {\n            if(num2FirstIdx.find(nums[i]) == num2FirstIdx.end()){\n                num2FirstIdx[nums[i]] = i; \n            } else {\n                if(i - num2FirstIdx[nums[i]] \u003c= k) return true;\n                num2FirstIdx[nums[i]] = i;\n            }\n        }\n\n        return false;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/hashmap/0242":{"title":"0242. Valid Anagrams","content":"\n```cpp\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        // If size different, it isn't anagram\n        if(s.size() != t.size())\n            return false;\n        \n        unordered_map\u003cchar, int\u003e charToCount;\n\n        for(char c : s) {\n            charToCount[c]++;\n        }\n\n        for(char c : t) {\n            charToCount[c]--;\n        }\n\n        for(int i = 0; i \u003c 26; i++) {\n            char c = 'a' + i;\n\n            if(charToCount[c] != 0)\n                return false;\n\n        }\n\n        return true;\n    }\n};\n```\n\n```cpp\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        int mapS2count[26];\n\n        memset(mapS2count, 0, sizeof(mapS2count));\n\n        for(char c : s){\n            mapS2count[c - 'a']++;\n        }\n\n        for(char c : t){\n            mapS2count[c - 'a']--;\n        }\n\n        for(int i = 0; i \u003c 26; i++){\n            if(mapS2count[i] != 0){\n                return false;\n            }\n        }\n\n        return true;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/hashmap/0290":{"title":"0290.Word Pattern","content":"\n```cpp\nclass Solution {\npublic:\n    bool wordPattern(string pattern, string s) {\n        unordered_map\u003cchar, string\u003e mapP2S;\n        unordered_map\u003cstring, char\u003e mapS2P;\n        \n        int i = 0;\n        int l = 0, r = 0;\n        int n = s.size();\n        \n        while(l \u003c n \u0026\u0026 r \u003c n){\n            // Split the string by space\n            while(s[r] != ' ' \u0026\u0026 r \u003c n) r++;    // ensure r range\n            string sub = s.substr(l, r - l);    // blank index to left index\n\n            // if pattern and string are all not recorded before, record it\n            if(mapP2S.find(pattern[i]) == mapP2S.end() \u0026\u0026 mapS2P.find(sub) == mapS2P.end()){\n                mapP2S[pattern[i]] = sub;\n                mapS2P[sub] = pattern[i];\n            } else {\n                // if pattern or string are not mapping correctly, return false\n                if(mapP2S[pattern[i]] != sub || mapS2P[sub] != pattern[i]){\n                    return false;\n                }\n            }\n            i++;    // pattern index increment\n            while(s[r] == ' ' \u0026\u0026 r \u003c n) r++; // move to next vocabulary\n            l = r;  // left index moves to right\n        }\n        // Check if pattern uses completely\n        if(i != pattern.size()) return false;\n        return true;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/hashmap/0383":{"title":"0382.Rawsom Note","content":"\n```cpp\nclass Solution {\npublic:\n    bool canConstruct(string ransomNote, string magazine) {\n        // put magazine in hashmap, key: character, value: count\n        // check each character in ransomNote and minus count\n        // If unvalid situation, return false\n        // return true if completely iterates ransomNote\n        int magazineCharToCount[26];\n        memset(magazineCharToCount, 0, sizeof(magazineCharToCount));\n\n        for(char c : magazine){\n            magazineCharToCount[c - 'a']++;\n        }\n        \n        for(char c : ransomNote){\n            int idx = c - 'a';\n            if(magazineCharToCount[idx] == 0){\n                return false;\n            }\n            magazineCharToCount[idx]--;\n        }\n        return true;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/linkedlist/":{"title":"","content":"","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/linkedlist/0024":{"title":"0024. Swap nodes by pairs","content":"\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        // 1 2 3 4\n        // s f\n        ListNode* dummy = new ListNode();\n        dummy-\u003enext = head;\n\n        ListNode* fast = dummy;\n        ListNode* slow = dummy;\n        ListNode* before = dummy;\n\n        while(fast-\u003enext != nullptr \u0026\u0026 fast-\u003enext-\u003enext != nullptr) {\n            fast = fast-\u003enext-\u003enext;\n            slow = slow-\u003enext;\n\n            // swap fast and slow\n            // dummy -\u003e 1 -\u003e 2 -\u003e 3 -\u003e 4\n            // b.    .  s.   f.   n\n            ListNode* next = fast-\u003enext;\n            fast-\u003enext = slow;\n            slow-\u003enext = next;\n            before-\u003enext = fast;\n            fast = slow;\n            before = slow;\n        }\n\n        return dummy-\u003enext;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/quickselect/":{"title":"","content":"","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/quickselect/0215":{"title":"0215.Kth Largest Element in an Array","content":"\n```cpp\nclass Solution {\npublic:\n    int partition(vector\u003cint\u003e\u0026 nums, int left, int right) {\n        // choose pivot\n        int pivot = nums[right];\n        int l = left;\n        int r = right - 1;\n\n        // swap left and right based on pivot\n        while(l \u003c= r) {\n            if(nums[l] \u003c pivot \u0026\u0026 nums[r] \u003e pivot) swap(nums[l++], nums[r--]);\n            if(nums[l] \u003e= pivot) l++;\n            if(nums[r] \u003c= pivot) r--;\n        }\n        // 5  3 4\n        // lr\n        // 5 3 4\n        // r l\n        // swap pivot to l\n        swap(nums[right], nums[l]);\n\n        return l;\n    }\n\n    int findKthLargest(vector\u003cint\u003e\u0026 nums, int k) {\n        // use quickselect\n        // Time: O(n)\n        // Space: O(1)\n\n        int l = 0;\n        int r = nums.size() - 1;\n        k = k - 1; // convert to index-0\n\n        while(l \u003c= r) {\n            int idx = partition(nums, l, r);\n            if(idx == k) {\n                return nums[idx];\n            } else if (idx \u003e k) {\n                r = idx - 1;\n            } else {\n                l = idx + 1;\n            }\n        }\n\n        return -1;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/recursion/":{"title":"","content":"","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/recursion/227":{"title":"0227. Basic Calculator II","content":"\n```cpp\nclass Solution {\npublic:\n    int getNumber(string\u0026 expression, int\u0026 pos){\n        int result = 0;\n        while((isdigit(expression[pos]) || expression[pos] == ' ') \u0026\u0026 pos \u003c expression.size()){\n            if(isdigit(expression[pos])){\n                result = result * 10 + (expression[pos] - '0');\n            }\n            pos++;\n        }\n        return result;\n    }\n\n    int parseTerm(string\u0026 expression, int\u0026 pos){\n        int result = getNumber(expression, pos);\n        \n        while(pos \u003c expression.size() \u0026\u0026 (expression[pos] == '*' || expression[pos] == '/')){\n            char op = expression[pos++];\n            int nextNumber = getNumber(expression, pos);\n            if(op == '*'){\n                result *= nextNumber;\n            } else if(op == '/'){\n                result /= nextNumber;\n            }\n        }\n        return result;\n    }\n\n    int parseExpression(string\u0026 expression, int\u0026 pos){\n        int result = parseTerm(expression, pos);\n\n        while(pos \u003c expression.size() \u0026\u0026 (expression[pos] == '+' || expression[pos] == '-')){\n            char op = expression[pos++];\n            int nextTerm = parseTerm(expression, pos);\n            if(op == '+'){\n                result += nextTerm;\n            } else if(op == '-'){\n                result -= nextTerm;\n            }\n        }\n        return result;\n    }\n\n    int calculate(string s) {\n        int pos = 0;\n        return parseExpression(s, pos);\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/recursion/268":{"title":"0268. Missing Number","content":"```cpp\nclass Solution {\npublic:\n    int missingNumber(vector\u003cint\u003e\u0026 nums) {\n        int size = nums.size();\n        \n        int expect_sum = size * (size+1) / 2;\n        \n        int actual_sum = 0;\n\n        for(int i = 0; i \u003c size; i++) {\n            actual_sum += nums[i];\n        }\n\n        return expect_sum - actual_sum;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/recursion/285":{"title":"0285. Inorder Successor in BST","content":"\n```cpp\nclass Solution {\npublic:\n    bool isTarget = false;\n    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {\n        if(root == nullptr) return nullptr;\n        \n        TreeNode* left = inorderSuccessor(root-\u003eleft, p);\n        if(left != nullptr) return left;\n\n        if(isTarget){\n            return root;\n        }\n        if(p-\u003eval == root-\u003eval){\n            isTarget = true;\n        }\n        TreeNode* right = inorderSuccessor(root-\u003eright, p);\n        if(right != nullptr) return right;\n        return nullptr;\n    }\n};\n\n```\n\n```cpp\nclass Solution {\npublic:\n    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {\n        TreeNode* sucessor = nullptr;\n\n        while(root != nullptr){\n            if(root-\u003eval \u003c= p-\u003eval){\n                root = root-\u003eright;\n            } else {\n                sucessor = root;\n                root = root-\u003eleft;\n            }\n        }\n\n        return sucessor;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/recursion/772":{"title":"0772. Basic Calculator III","content":"\n```cpp\nclass Solution {\npublic:\n    int getNumber(string\u0026 expression, int\u0026 pos){\n        int result = 0;\n        while(isdigit(expression[pos]) \u0026\u0026 pos \u003c expression.size()){\n            result = result * 10 + (expression[pos] - '0');     \n            pos++;\n        }\n        return result;\n    }\n\n    int parseFactor(string\u0026 expression, int\u0026 pos){\n        if(expression[pos] == '('){\n            pos++;\n            int result = parseExpression(expression, pos);\n            pos++;\n            return result;\n        }\n        return getNumber(expression, pos);\n    }\n\n    int parseTerm(string\u0026 expression, int\u0026 pos){\n        int result = parseFactor(expression, pos);\n        \n        while(pos \u003c expression.size() \u0026\u0026 (expression[pos] == '*' || expression[pos] == '/')){\n            char op = expression[pos++];\n            int nextFactor = parseFactor(expression, pos);\n            if(op == '*'){\n                result *= nextFactor;\n            } else if(op == '/'){\n                result /= nextFactor;\n            }\n        }\n        return result;\n    }\n\n    int parseExpression(string\u0026 expression, int\u0026 pos){\n        int result = parseTerm(expression, pos);\n\n        while(pos \u003c expression.size() \u0026\u0026 (expression[pos] == '+' || expression[pos] == '-')){\n            char op = expression[pos++];\n            int nextTerm = parseTerm(expression, pos);\n            if(op == '+'){\n                result += nextTerm;\n            } else if(op == '-'){\n                result -= nextTerm;\n            }\n        }\n        return result;\n    }\n\n    int calculate(string s) {\n        int pos = 0;\n        return parseExpression(s, pos);\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/sliding-window/":{"title":"","content":"","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/sliding-window/209":{"title":"0209. Minimum Size Subarray Sum","content":"\n```cpp\nclass Solution {\npublic:\n    int minSubArrayLen(int target, vector\u003cint\u003e\u0026 nums) {\n        int left = 0;\n        int sum = 0;\n        int ans = INT_MAX;\n\n        for(int right = 0; right \u003c nums.size(); right++) {\n            sum += nums[right];\n\n            while(sum \u003e= target) {\n                ans = min(ans, right - left + 1);\n                sum -= nums[left++];\n            }\n                \n        }\n        return ans == INT_MAX ? 0 : ans;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/stack/":{"title":"","content":"","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/stack/0020":{"title":"0020.Valid Parentheses","content":"\n```cpp\nclass Solution {\npublic:\n    bool isValid(string s) {\n        stack\u003cchar\u003e sta;\n\n        for(char c : s){\n            if(c == '(' || c == '[' || c == '{'){\n                sta.push(c);\n            } else {\n                if(sta.empty()){\n                    return false;\n                }\n                int t = sta.top();\n\n                if(c == ')' \u0026\u0026 t != '('){\n                    return false;\n                } else if (c == ']' \u0026\u0026 t != '['){\n                    return false;\n                } else if (c == '}' \u0026\u0026 t != '{'){\n                    return false;\n                }\n                sta.pop();\n            }\n        }\n\n        return sta.empty(); \n    }\n};\n```\n","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/stack/0739":{"title":"739. Daily Temperatures","content":"\n```cpp\nclass Solution {\npublic:\n    vector\u003cint\u003e dailyTemperatures(vector\u003cint\u003e\u0026 temperatures) {\n        stack\u003cint\u003e sta;\n        vector\u003cint\u003e result(temperatures.size(), 0);\n\n        for(int i = 0; i \u003c temperatures.size(); i++){\n            while(!sta.empty() \u0026\u0026 temperatures[sta.top()] \u003c temperatures[i]){\n                result[sta.top()] = i - sta.top();\n                sta.pop();\n            }\n            sta.push(i);\n        }\n\n        return result;\n    }\n};\n```\n","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/string/":{"title":"","content":"","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/string/0058":{"title":"58. Length of Last Word","content":"\n```cpp\nclass Solution {\npublic:\n    int lengthOfLastWord(string s) {\n        int n = s.size();\n        int l = n-1;\n        int r = l;\n\n        while(r \u003e= 0 \u0026\u0026 s[r] == ' ') r--;\n        l = r;\n        while(l \u003e= 0 \u0026\u0026 s[l] != ' ') l--;\n        \n        return r - l;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/two-pointer/":{"title":"","content":"","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/two-pointer/0011":{"title":"0011.Container With Most Water","content":"\n```cpp\nclass Solution {\npublic:\n    int maxArea(vector\u003cint\u003e\u0026 height) {\n        int l = 0;\n        int r = height.size() - 1;\n        int result = 0;\n\n        while(l \u003c r) {\n            result = max(result, (r - l) * min(height[l], height[r]));\n            if(height[l] \u003c height[r]) l++;\n            else r--;\n        }\n\n        return result;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/two-pointer/0015":{"title":"0015. Three Sum","content":"\n```cpp\nclass Solution {\npublic:\n    void twoSum(vector\u003cint\u003e\u0026 nums, int target, int left, vector\u003cvector\u003cint\u003e\u003e\u0026 result) {\n        int l = left;\n        int r = nums.size() - 1;\n\n        while(l \u003c r) {\n            int sum = nums[l] + nums[r];\n            if(target \u003e sum) {\n                l++;\n            } else if (target \u003c sum) {\n                r--;\n            } else {\n                result.push_back({-target, nums[l], nums[r]});\n                l++;\n                r--;\n                while(nums[l] == nums[l-1] \u0026\u0026 l \u003c r) l++;\n                while(nums[r] == nums[r+1] \u0026\u0026 l \u003c r) r--;\n\n            }\n        }\n    }\n\n    vector\u003cvector\u003cint\u003e\u003e threeSum(vector\u003cint\u003e\u0026 nums) {\n        int n = nums.size();\n        vector\u003cvector\u003cint\u003e\u003e result;\n\n        sort(nums.begin(), nums.end());\n\n        for(int i = 0; i \u003c n-2 \u0026\u0026 nums[i] \u003c= 0; i++) {\n            if(i == 0 || nums[i] != nums[i-1])\n                twoSum(nums, -nums[i], i+1, result);\n        }\n\n        return result;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/two-pointer/0026":{"title":"0026. Remove Duplicates from Sorted Array","content":"\n```cpp\nclass Solution {\npublic:\n    int removeDuplicates(vector\u003cint\u003e\u0026 nums) {\n        // fast and slow start from 0\n        // fast go first\n        // if nums[fast] != nums[slow], slow++ and swap\n        // return slow\n        int fast = 1, slow = 0;\n\n        // 0 1 0 1 1 2 2 3 3 4\n        // 0 1 2 1 1 0 2 3 3 4\n        //     s       f\n        for(; fast \u003c nums.size(); fast++) {\n            if(nums[fast] != nums[slow]) {\n                slow++;\n                nums[slow] = nums[fast];\n            }\n        }\n\n        return slow + 1;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/two-pointer/0125":{"title":"0125. Valid Palindrome","content":"\n```cpp\nclass Solution {\npublic:\n    bool isPalindrome(string s) {\n        // two point left and right\n        // if meet not alpha or number, skip\n        // compare s[left] and s[right]\n        // if equal, continue\n        // if not equal return false\n        // if left == right, return true\n\n        int left = 0, right = s.size() - 1;\n\n        for(; left \u003c right; left++, right--) {\n            while(left \u003c right \u0026\u0026 !isalnum(s[left])) {\n                left++;\n            }\n\n            while(left \u003c right \u0026\u0026 !isalnum(s[right])) {\n                right--;\n            }\n\n            if(tolower(s[left]) != tolower(s[right])) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/two-pointer/0141":{"title":"0141. Linked List Cycle","content":"\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        ListNode* fast = head;\n        ListNode* slow = head;\n\n        while(fast != nullptr \u0026\u0026 fast-\u003enext != nullptr){\n            fast = fast-\u003enext-\u003enext;\n            slow = slow-\u003enext;\n\n            if(fast == slow) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/two-pointer/0142":{"title":"0142. Linked List Cycle II","content":"\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        // fast move 2 pos\n        // slow move 1 pos\n        // pos count: 2(x+y) = x + y + n(y + z)\n        // n = 1, x = z\n\n        ListNode* fast = head;\n        ListNode* slow = head;\n\n        while(fast != nullptr \u0026\u0026 fast-\u003enext != nullptr) {\n            fast = fast-\u003enext-\u003enext;\n            slow = slow-\u003enext;\n\n            // Encounter point find\n            if(fast == slow) {\n                slow = head;\n                \n                // fast starts from encouter ponit\n                // slow starts from head\n                // move together\n                while(fast != slow) {\n                    fast = fast-\u003enext;\n                    slow = slow-\u003enext;\n                }\n\n                // return new encounter point\n                return fast;\n            }\n        }\n\n        return nullptr;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/two-pointer/0167":{"title":"0167. Two Sum - Input Array is Sorted","content":"\n```cpp\nclass Solution {\npublic:\n    vector\u003cint\u003e twoSum(vector\u003cint\u003e\u0026 numbers, int target) {\n        int l = 0;\n        int r = numbers.size() - 1;\n        int sum;\n\n        while(l \u003c r) {\n            sum = numbers[l] + numbers[r];\n            if(sum == target)   return {l+1, r+1};\n            else if (sum \u003e target) r--;\n            else l++;    \n        }\n\n        return {};\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/two-pointer/0189":{"title":"0189.Rotate Array","content":"\n```cpp\nclass Solution {\npublic:\n    void rotate(vector\u003cint\u003e\u0026 nums, int k) {\n        reverse(nums.begin(), nums.end());\n\n        if(k \u003e nums.size()) k = k % nums.size();\n\n        reverse(nums.begin(), nums.begin() + k);\n        reverse(nums.begin() + k, nums.end());\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/two-pointer/0392":{"title":"0392. Is Subsequence","content":"\n```cpp\nclass Solution {\npublic:\n    bool isSubsequence(string s, string t) {\n        if(t.size() \u003c s.size()) return false;\n        \n        int index1 = 0;\n        int index2 = 0;\n\n        while(index1 \u003c s.size() \u0026\u0026 index2 \u003c t.size()) {\n            if(s[index1] == t[index2]){\n                index1++;\n                index2++;\n            } else {\n                index2++;\n            }\n        }\n        return index1 == s.size();\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/two-pointer/0647":{"title":"647. Palindromic Substrings","content":"\n```cpp\nclass Solution {\npublic:\n    int findPalindrome(string s, int l, int r) {\n        int count = 0;\n        while(l \u003e= 0 \u0026\u0026 r \u003c s.size() \u0026\u0026 s[l] == s[r]) {\n            count++;\n            l--;\n            r++;\n        }\n        return count;\n    }\n    int countSubstrings(string s) {\n        int result = 0;\n        for(int i = 0; i \u003c s.size(); i++) {\n            result += findPalindrome(s, i, i);\n            result += findPalindrome(s, i, i+1);\n        }\n        return result;\n    }\n};\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/leetcode/two-pointer/0977":{"title":"0977. Squares of a Sorted Array","content":"\n## Method 1\n\n- Time Complexity: O(n)\n- Space Complexity: O(n)\n\n```cpp\nclass Solution {\npublic:\n    vector\u003cint\u003e sortedSquares(vector\u003cint\u003e\u0026 nums) {\n        int l = 0;\n        int r = nums.size() - 1;\n        int index = nums.size() - 1;\n        vector\u003cint\u003e result(nums.size(), 1);\n\n        while(l \u003c= r) {\n            int leftpower = nums[l] * nums[l];\n            int rightpower = nums[r] * nums[r];\n\n            if(leftpower \u003e rightpower) {\n                result[index--] = leftpower;\n                l++;\n            } else {\n                result[index--] = rightpower;\n                r--;\n            }\n        }\n\n        return result;\n    }\n};\n```\n","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/linux-kernel/":{"title":"","content":"","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/linux-kernel/add_system_call":{"title":"Add system call to linux","content":"\nOpen `include/uapi/asm-generic/unistd.h`\n\n```c\n#define __NR_get_cpuid 452\n__SYSCALL(__NR_get_cpuid, sys_get_cpuid)\n\n#undef __NR_syscalls\n#define __NR_syscalls 453\n```\n\nOpen `linux/kernel/sys.c`\n\n```c\nSYSCALL_DEFINE0(get_cpuid)\n{\n\treturn raw_smp_processor_id();\n}\n```\n","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/linux-kernel/write_first_kernel_module":{"title":"Write your first kernel module","content":"\n## Building Kernel Module\n\nCreate `rootkit.c`\n\n```cpp\n#include \u003clinux/module.h\u003e\n#include \u003clinux/syscalls.h\u003e\n#include \u003clinux/types.h\u003e\n\n#define OURMODNAME\t\"rootkit\"\n\nMODULE_AUTHOR(\"FOOBAR\");\nMODULE_DESCRIPTION(\"FOOBAR\");\nMODULE_LICENSE(\"Dual MIT/GPL\");\nMODULE_VERSION(\"0.1\");\n\nstatic int __init rootkit_init(void)\n{\n    printk(KERN_INFO \"hello, world!\\n\");\n\treturn 0;\n}\n\nstatic void __exit rootkit_exit(void)\n{\n\tprintk(KERN_INFO \"Goodbye, world!\\n\");\n}\n\nmodule_init(rootkit_init);\nmodule_exit(rootkit_exit);\n```\n\nCreate `Makefile`. Remember to update `KDIR` with your linux source code dir.\n\n```sh\nobj-m = rootkit.o\nPWD := $(shell pwd)\nEXTRA_CFLAGS = -Wall -g\nCROSS = aarch64-linux-gnu-\nKDIR = /home/jack/Desktop/linux/\n\nall:\n\t$(MAKE) ARCH=arm64 CROSS_COMPILE=$(CROSS) -C $(KDIR) M=$(PWD) modules\nclean:\n\t$(MAKE) -C $(KDIR) M=$(PWD) clean\n```\n\nCompile kernel module\n\n```sh\nmake all\n\n$ ls\nrootkit.ko\n```\n\nCopy `rootkit.ko` to qemu share folders.\n\n```sh\ncp rootkit.ko ../shared\n```\n\nOpen qemu vm.\n\n```sh\nqemu-system-aarch64 ...\n```\n\nInsert kernel module and list all kernel module\n\n```sh\n$ sudo insmod rootkit.ko\n$ sudo lsmod\n\nModule    Size  Used by\nrootkit  12232  0\n```\n\nRemove kernel module and look log by `dmesg`\n\n```sh\n$ sudo rmmod rootkit\n$ dmesg\n\nHello, world!\nGoodbye, world!\n```\n\n\n\n\n\n","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/network/":{"title":"","content":"","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/network/tcp-connection":{"title":"How TCP establish and close connection?","content":"\n## TCP establish connection\n\n```mermaid\nsequenceDiagram\n\tparticipant Client\n\tparticipant Server\n\tNote over Client, Server: CLOSED\n\tNote right of Server: LISTEN\n\tClient-\u003e\u003eServer: SYN seq=100\n\tNote left of Client: SYN-SENT\n\tServer-\u003e\u003eClient: SYN ACK seq=300 ack=101\n\tNote right of Server: SYN_RCVD\n\tNote left of Client: ESTABLISHED\n\tClient-\u003e\u003eServer: ACK seq=101 ack=301\n\tNote right of Server: ESTABLISHED\n```\n\n## TCP close connection\n\n```mermaid\nsequenceDiagram\n\tparticipant Client\n\tparticipant Server\n\tNote left of Client: ESTABLISHED\n\tNote right of Server: ESTABLISHED\n\tClient-\u003e\u003eServer: FIN seq=300\n\tNote left of Client: FIN_WAIT\n\tNote right of Server: CLOSE_WAIT\n\tServer-\u003e\u003eClient: ACK ack=301\n\tNote right of Server: LAST_ACK\n\tNote left of Client: FIN_WAIT2\n\tServer-\u003e\u003eClient: FIN seq=500 ack=301\n\tNote left of Client: TIME_WAIT\n\tClient-\u003e\u003eServer: ACK seq=301 ack=501\n\tNote right of Server: CLOSED\n\tNote left of Client: CLOSED\n```\n\n## Why TCP has TIME_WAIT?\n\nClient normally waits for 2 maximum segment lifetime (MSL) and close the connection. There are two main reason:\n\n- Ensure all old packets is disapper on the internet.\n- ACK from client might lose due to the network. Therefore, server will resend `FIN` after timeout. If client closes the connection immediately, client can't receive the new `FIN`.\n\n","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/xv6/":{"title":"","content":"","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/xv6/xv6-gdb":{"title":"Debug xv6 with gdb","content":"\n## Preparation\n\n```sh\n# Run xv6 with gdb\nmake qemu-gdb\n\n# Change to another terminal and connect to xv6-gdb\ngdb-multiarch -x .gdbinit\n```\n\n## Basic Command\n\n```sh\n# Set break point\nb syscall\nb module.c:67\n\n# Print source code\nlayout src\nlayout asm\n\n# Continue\nc\n\n# Step into\nstep\n\n# Step over\nnext\n\n# Print register or value\np /x $stvec\np /x $a7\np /x p-\u003eproc\n\n# List value of register\ninfo register\n\n# List args\ninfo args\n\n# See who call it\nbacktrace\n\n# Set value\nset xxx\n\n# Watching variable\nwatch a\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/xv6/xv6-isatty":{"title":"Implement isatty on xv6","content":"\n## Problem\n\nThis bug happens when we try to run shell commands from a file:\n\n```sh\n// xargstest.sh\nmkdir a\necho hello \u003e a/b\nmkdir c\necho hello \u003e c/b\necho hello \u003e b\nfind . b | xargs grep hello\n```\n\nIt will print out `$` for all commands:\n\n```sh\n$ sh \u003c xargstest.sh\n$ $ $ $ $ $ hello\nhello\nhello\n$ $\n```\n\nThe problem is that we need to determine where the input comes from.\nIf it comes from terminal, the program should print out `$`. If it\ncomes from file, the program should not print out `$`.\n\n## isatty\n\n`isatty` is a system call that telling us whether the file descriptor comes from terminal or not.\n\n```c\nint main()\n{\n  if(isatty(0)){\n    printf(\"0 is device\\n\");\n  } else {\n    printf(\"0 is file\\n\");\n  }\n  exit(0);\n}\n```\n\nAfter writing some tests, we can see that when `isatty` is false when we send commands to `stdin` by\nfile redirection.\n\n```sh\n$ ./main\n0 is device\n$ ./main \u003c input.txt\n0 is file\n```\n\nTherefore, we need to implement `isatty` on xv6 to support this feature. The logic here is simple\nand not be tested for every scenario.\n\n```c\n// kernel/sysfile.c\nuint64\nsys_isatty(void)\n{\n  int fd;\n  struct file *f;\n\n  if(argfd(0, \u0026fd, \u0026f) \u003c 0){\n    return -1;\n  }\n\n  return f-\u003etype == FD_DEVICE;\n}\n```\n\nFinally, we modify `user/sh.c` and only print out `$` when commands come from terminal.\n\n```c\n// user/sh.c\nint\ngetcmd(char *buf, int nbuf)\n{\n  if(isatty(0)){\n    fprintf(2, \"$ \");\n  }\n  memset(buf, 0, nbuf);\n  gets(buf, nbuf);\n  if(buf[0] == 0) // EOF\n    return -1;\n  return 0;\n}\n```\n\n## Test\n\n```sh\n$ sh \u003c xargstest.sh\nhello\nhello\nhello\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/xv6/xv6-lab-trap":{"title":"xv6 lab trap","content":"\n# Lab Trap\n\n- [x] RISC-V assembly (easy)\n- [x] Backtrace (moderate)\n- [ ] Alarm (hard)\n\n## RISC-V assembly (easy)\n\n\u003e Which registers contain arguments to functions? For example, which register holds 13 in main's call to¬†printf?\n\nAns: `a1`, `a2` will store arguments. Here `li a2,13` means that load immediate 13 to `a2`.\n\n```bash\nvoid main(void) {\n  1c:\t1141                \tadd\tsp,sp,-16\n  1e:\te406                \tsd\tra,8(sp)\n  20:\te022                \tsd\ts0,0(sp)\n  22:\t0800                \tadd\ts0,sp,16\n  printf(\"%d %d\\n\", f(8)+1, 13);\n  24:\t4635                \tli\ta2,13\n  26:\t45b1                \tli\ta1,12\n\t//...\t\n}\n```\n\n\u003e Where is the call to function¬†f¬†in the assembly code for main? Where is the call to¬†g? (Hint: the compiler may inline functions.)\n\u003e \n\n`f()` stored at `000000000000000e` and `g()` stored at `0000000000000000.`\n\n```bash\n0000000000000000 \u003cg\u003e:\n// ...\n\nint g(int x) {\n\t// ...\n}\n  // ...\n\n000000000000000e \u003cf\u003e:\n\nint f(int x) {\n\t// ...\n}\n```\n\n\u003e At what address is the function¬†printf¬†located?\n\u003e \n\n```bash\n0000000000000616 \u003cprintf\u003e:\n```\n\nWe can also get the same result by looking at how compiler calculates address\n\nauipc: add upper immediate to program counter and save to register\n\njalr: jump to certain address based on register and offset\n\n```bash\n30:\t00000097          \tauipc\tra,0x0\n34:\t5e6080e7          \tjalr\t1510(ra) # 616 \u003cprintf\u003e\n```\n\nSo the following steps are:\n\n1. program counter = 30\n2. add 0 to program counter and save to `ra`\n3. jump to ra + 1510: `hex(1510) + 0x30 = 0x5e6 + 0x30 = 0x616`\n\n\u003e What value is in the register¬†ra¬†just after the¬†jalr¬†to¬†printf¬†in¬†main?\n\u003e \n\nRead [risc-v-spec](https://riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf) at page 16:\n\n\u003caside\u003e\nüí° The indirect jump instruction JALR (jump and link register) uses the I-type encoding. The target address is obtained by adding the 12-bit signed I-immediate to the register rs1, then setting the least-significant bit of the result to zero. The address of the instruction following the jump (pc+4) is written to register rd. Register x0 can be used as the destination if the result is not required.\n\nWhen used with a base rs1=x0, JALR can be used to implement a single instruction subroutine call to the lowest 2 KiB or highest 2 KiB address region from anywhere in the address space, which could be used to implement fast calls to a small runtime library.\n\n\u003c/aside\u003e\n\nRegister `ra` is used for return address. Therefore, `jalr 1510(ra)` ra store `pc+4`, 34 + 4 = 38.\n\n## Backtrace (moderate)\n\n```c\nvoid\nbacktrace(void)\n{\n  uint64 fp = r_fp();\n\n  while(fp \u003c PGROUNDUP(fp)) {\n    uint64 ra = *(uint64*)(fp - 8); // return address at offset(-8)\n    printf(\"%p\\n\", ra);\n    fp = *(uint64*)(fp - 16); // previous frame pointer at offset(-16)\n  }\n}\n```\n\n## Alarm (hard)\n\nTBD","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/xv6/xv6-pwd":{"title":"Implement pwd on xv6","content":"\n## Flow\n\n- Open current path and get file stat\n- Keep finding the path like:   `./..` ‚Üí `./../..` ‚Üí `./../../..`\n- Iterate all files and folder by `read()` and find corresponding folder name by comparing parent inode number and current inode number.\n- Stop loop when parent inode number is equal to current inode number because it reaches the root.\n\n```sh\n// Use fstat to get current folder inode = 9\n// Iterate all inodes in parent folder to find\n// which folder inode = 9\n\n// root folder (parent)\n---- .  1\n |-- .. 1\n |-- a  9\n\n// folder /a (current)\n---- .  9\n |-- .. 1\n```\n\n```c\n#include \"kernel/types.h\"\n#include \"kernel/stat.h\"\n#include \"user/user.h\"\n#include \"kernel/fs.h\"\n\nvoid\npwd()\n{\n  char *path = \".\";\n  char buf[512];\n  int fd;\n  struct dirent de;\n  struct stat st, parentst;\n  char *result = \"\";\n\n  if((fd = open(path, 0)) \u003c 0){\n    fprintf(2, \"pwd: cannot open %s\\n\", path);\n    return;\n  }\n\n  if(fstat(fd, \u0026st) \u003c 0){\n    fprintf(2, \"pwd: cannot stat %s\\n\", path);\n    close(fd);\n    return;\n  }\n\n  strcpy(buf, path);\n  \n  int maxdepth = 20;\n  int depth = 0;\n\n  for(; depth \u003c maxdepth; depth++){\n\n    // Go to parent directory\n    strcpy(buf + strlen(buf), \"/..\");\n    \n    if((fd = open(buf, 0)) \u003c 0){\n      fprintf(2, \"pwd: cannot open %s\\n\", buf);\n      return;\n    }\n\n    if(fstat(fd, \u0026parentst) \u003c 0){\n      fprintf(2, \"pwd: cannot stat %s\\n\", buf);\n      close(fd);\n      return;\n    }\n\n    // If parent ino is equal to current ino,\n    // it indicates that it reaches the root\n    if(parentst.ino == st.ino)\n      break;\n\n    // Iterate parent directory and find the folder\n    // that match current directory by checking ino\n    while(read(fd, \u0026de, sizeof(de)) == sizeof(de)){\n      if(de.inum == 0)\n        continue;\n      if(de.inum == st.ino){\n        char resultbuf[512];\n        strcpy(resultbuf, result);\n        strcpy(result, \"/\");\n        strcpy(result+1, de.name);\n        strcpy(result+strlen(result), resultbuf);\n      }\n    }\n\n    // Move to parent folder\n    st = parentst;\n  }\n\n  // Root folder\n  if(strlen(result) == 0)\n    result = \"/\";\n\n  printf(\"%s\\n\", result);\n  close(fd);\n}\n\nint\nmain(int argc, char *argv[])\n{\n  pwd();\n  exit(0);\n}\n```\n\n## Test\n\n```sh\n$ mkdir a\n$ mkdir a/b\n$ /pwd\n/a/b\n$ cd ..\n$ /pwd\n/a\n$ cd ..\n$ pwd\n/\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null},"/xv6/xv6-xargs":{"title":"Implement xargs on xv6","content":"\n## Flow\n\n- Read `user/sh.c` and get more ideas\n- Read command by `gets`\n- Child process will execute the commands after xargs.\n- Parent process will execute the front commands after child process is finished.\n\n```c\n#include \"kernel/types.h\"\n#include \"kernel/param.h\"\n#include \"user/user.h\"\n\nint\ngetcmd(char *buf, int nbuf)\n{\n  memset(buf, 0, nbuf);\n  gets(buf, nbuf);\n  if(buf[0] == 0) // EOF\n    return -1;\n  return 0;\n}\n\nint\nmain(int argc, char *argv[])\n{\n  char *args[argc+1];\n  int i;\n  char buf[512];\n\n  for(i=1; i\u003cargc; i++)\n    args[i-1] = argv[i];\n\n  while(getcmd(buf, sizeof(buf)) \u003e= 0){\n    buf[strlen(buf)-1] = 0; // chop \\n\n    args[argc-1] = buf;\n    args[argc] = 0;\n\n    if(fork() == 0){\n      exec(args[0], args);\n      printf(\"xargs: exec error\\n\");\n      exit(1);\n    } else {\n      wait(0);\n    }\n  }\n\n  exit(0);\n}\n```\n\n## Test\n\n```sh\n$ echo hello jack | xargs echo bye\nbye hello jack\n```","lastmodified":"2024-04-06T03:11:41.534903729Z","tags":null}}