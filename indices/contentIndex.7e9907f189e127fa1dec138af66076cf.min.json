{"/":{"title":"Welcome!","content":"\n## Jack Li\n\n## üè´ Education\n\n- Master of Electrical Engineering / [University of British Columbia, Canada](https://www.ubc.ca/) / 2023-Present\n\n- Bachelor of Computer Science / [National Tsing Hua University, Taiwan](https://nthu-en.site.nthu.edu.tw/) / 2017-2021\n\n## üíº Experiences\n\n**Software Engineer, [LINE](https://line.me/en/), Taiwan, July 2021 - July 2023**\n\n**Springboot / MySQL / Redis / Kubernetes / Kafka**\n\n- Developed the mission API, enabling users to engage in various missions such as check-ins, following users,\nand completing transactions, leading to a new business for increasing 2M revenue.\n- Analyzed transaction data with Flink and helped deploy Flink on the kubernetes cluster with Oauth2 support.\n- Developed a File Download Center for the marketing team, integrating Kafka, Elasticsearch and Amazon S3.\n- Designed and implemented a favorite API for user preferences and recommended posts.\n- Developed advertisements and events APIs in microservices architectures for serving 10M users globally.\n- Established a CI workflow with automated unit tests and integration tests with Jenkins and CircleCI.\n- Managed kubernetes cluster with auto-scaling features and monitor with prometheus and grafana.\n- Developed a Vue.js dashboard for user management and data visualization.\n\n\n## ‚òéÔ∏è Contact\n\n- Email: jack.yenchun.li@gmail.com\n- Github: https://github.com/jackeryli\n- Linkedin: https://www.linkedin.com/in/jack-yen-chun-li/\n\n## üõ†Ô∏è Skills\n\n- Java\n- C/C++\n- Go\n- Docker\n- Kubernetes\n- SQL/NoSQL\n- CUDA\n- Distributed System\n\n## üåç Languages\n\nEnglish / Chinese\n\n\n","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/internet/":{"title":"","content":"","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/internet/tcp-connection":{"title":"How TCP establish and close connection?","content":"\n## TCP establish connection\n\n```mermaid\nsequenceDiagram\n\tparticipant Client\n\tparticipant Server\n\tNote over Client, Server: CLOSED\n\tNote right of Server: LISTEN\n\tClient-\u003e\u003eServer: SYN seq=100\n\tNote left of Client: SYN-SENT\n\tServer-\u003e\u003eClient: SYN ACK seq=300 ack=101\n\tNote right of Server: SYN_RCVD\n\tNote left of Client: ESTABLISHED\n\tClient-\u003e\u003eServer: SYN seq=101 ack=301\n\tNote right of Server: ESTABLISHED\n```\n\n## TCP close connection\n\n```mermaid\nsequenceDiagram\n\tparticipant Client\n\tparticipant Server\n\tNote left of Client: ESTABLISHED\n\tNote right of Server: ESTABLISHED\n\tClient-\u003e\u003eServer: FIN seq=300\n\tNote left of Client: FIN_WAIT\n\tNote right of Server: CLOSE_WAIT\n\tServer-\u003e\u003eClient: ACK ack=301\n\tNote right of Server: LAST_ACK\n\tNote left of Client: FIN_WAIT2\n\tServer-\u003e\u003eClient: FIN seq=500 ack=301\n\tNote left of Client: TIME_WAIT\n\tClient-\u003e\u003eServer: ACK seq=301 ack=501\n\tNote right of Server: CLOSED\n\tNote left of Client: CLOSED\n```\n\n## Why TCP has TIME_WAIT?\n\nClient normally waits for 2 maximum segment lifetime (MSL) and close the connection. There are two main reason:\n\n- Ensure all old packets is disapper on the internet.\n- ACK from client might lose due to the network. Therefore, server will resend `FIN` after timeout. If client closes the connection immediately, client can't receive the new `FIN`.\n\n","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/":{"title":"","content":"","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/array/":{"title":"","content":"","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/array/2966":{"title":"2966. Divide Array Into Arrays With Max Difference","content":"\n```cpp\nclass Solution {\npublic:\n    vector\u003cvector\u003cint\u003e\u003e divideArray(vector\u003cint\u003e\u0026 nums, int k) {\n        // sort array from small to large\n        // divide into 3 part\n        // iterate and check if part[0] - part[2] is bigger than k\n        // if yes, return empty vector\n        // if no, assign part[0], part[1], part[2] to one vector\n\n        sort(nums.begin(), nums.end());\n\n        vector\u003cvector\u003cint\u003e\u003e ans = {nums.size()/3, vector\u003cint\u003e{}};\n\n        for(int i = 0; i \u003c nums.size(); i+=3){\n            if((nums[i+2] - nums[i]) \u003c= k) {\n                ans[i/3] = {nums[i], nums[i+1], nums[i+2]};\n            } else {\n                return vector\u003cvector\u003cint\u003e\u003e{};\n            }\n        }\n\n        return ans;\n    }\n};\n```","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/binary-search/":{"title":"","content":"","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/binary-search/1011":{"title":"1011. Capacity To Ship Packages Within D Days","content":"\n```cpp\nclass Solution {\npublic:\n    int countShipDays(vector\u003cint\u003e\u0026 weights, int capacity){\n        int usedDays = 1;\n        int current = capacity;\n\n        for(int\u0026 weight : weights){\n            if(weight \u003e capacity){\n                return INT_MAX;\n            }\n            if(current \u003e= weight){\n                current -= weight;\n            } else {\n                usedDays++;\n                current = capacity - weight;\n            }\n        }\n\n        return usedDays;\n    }\n    int shipWithinDays(vector\u003cint\u003e\u0026 weights, int days) {\n        int l = 0;\n        int r = *max_element(weights.begin(), weights.end());\n        int usedDays;\n        int mid;\n\n        while(l \u003c r){\n            usedDays = countShipDays(weights, r);\n            if(usedDays \u003c= days)\n                break;\n            l = r;\n            r = r \u003c\u003c 1;\n        }\n\n        while(l \u003c= r){\n            mid = l + (r - l) / 2;\n            usedDays = countShipDays(weights, mid);\n\n            if(usedDays == days){\n                r = mid-1;\n            } else if(usedDays \u003e days){\n                l = mid + 1;\n            } else {\n                r = mid-1;\n            }\n        }\n\n        return l;\n    }\n};\n```","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/binary-search/1283":{"title":"1283. Find the Smallest Divisor Given a Threshold","content":"\n```cpp\nclass Solution {\npublic:\n    int calDivisionSum(vector\u003cint\u003e\u0026 nums, int divisor){\n        int result = 0;\n        for(int\u0026 num : nums){\n            result += (num / divisor) + (num % divisor != 0);\n        }\n        return result;\n    }\n\n    int smallestDivisor(vector\u003cint\u003e\u0026 nums, int threshold) {\n        int l = 1;\n        int r = *max_element(nums.begin(), nums.end());\n        int m;\n        int pivot;\n\n        while(l \u003c= r){\n            m = l + (r - l) / 2;\n            pivot = calDivisionSum(nums, m);\n\n            if(pivot == threshold){\n                r = m - 1;\n            } else if(pivot \u003e threshold){\n                l = m + 1;\n            } else {\n                r = m - 1;\n            }\n        }\n\n        return l;\n    }\n};\n```","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/binary-search/1351":{"title":"1351. Count Negative Numbers in a Sorted Matrix","content":"\n```cpp\nclass Solution {\npublic:\n    int binarySearch(vector\u003cint\u003e\u0026 arr){\n        int left = 0;\n        int right = arr.size() - 1;\n        int mid;\n\n        while(left \u003c= right){\n            mid = left + (right - left) / 2;\n            if(arr[mid] \u003e= 0){\n                left = mid + 1;          \n            } else {\n               right = mid - 1;\n            }\n        }\n        return arr.size() - left;\n    }\n\n    int countNegatives(vector\u003cvector\u003cint\u003e\u003e\u0026 grid) {\n        int m = grid.size();\n        int n = grid[0].size();\n\n        int ans = 0;\n\n        for(auto\u0026 arr: grid){\n            ans += binarySearch(arr);\n        }\n\n        return ans;\n    }\n};\n```\n\n```cpp\nclass Solution {\npublic:\n    int countNegatives(vector\u003cvector\u003cint\u003e\u003e\u0026 grid) {\n        int m = grid.size();\n        int n = grid[0].size();\n\n        int ans = 0;\n        int index = n - 1;\n\n        for(auto\u0026 row : grid){\n            while(index \u003e= 0 \u0026\u0026 row[index] \u003c 0){\n                index--;\n            }\n            ans += (n - index - 1);\n        }\n\n        return ans;\n    }\n};\n```","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/binary-search/1870":{"title":"1870. Minimum Speed to Arrive on Time","content":"\n```cpp\nclass Solution {\npublic:\n    double calHourSpent(vector\u003cint\u003e\u0026 dist, int speed) {\n        int n = dist.size() - 1;\n        double hourSpent = 0;\n\n        for(int i = 0; i \u003c n; i++) {\n            hourSpent += (dist[i] / speed + (dist[i] % speed != 0));\n        }\n        \n        return hourSpent + (double) dist[n] / speed;\n    }\n\n    int minSpeedOnTime(vector\u003cint\u003e\u0026 dist, double hour) {\n        if(hour \u003c= dist.size() - 1){\n            return -1;\n        }\n\n        int l = 1;\n        int r = 10e7; // two digit decimal after 10e5\n        int m;\n        double pivot;\n\n        while(l \u003c r) {\n            m = l + (r - l) / 2;\n            pivot = calHourSpent(dist, m);\n            \n            if(pivot == hour){\n                r = m;\n            } else if (pivot \u003e hour){\n                l = m + 1;\n            } else {\n                r = m;\n            }\n        }\n\n        return r;\n    }\n};\n```","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/binary-search/2300":{"title":"2300. Successful Pairs of Spells and Potions","content":"\n```cpp\nclass Solution {\npublic:\n    int binarySearch(vector\u003cint\u003e\u0026 potions, long long target) {\n        int n = potions.size();\n        int l = 0;\n        int r = n - 1;\n\n        while(l \u003c= r) {\n            long long m = l + (r - l) / 2;\n            if(potions[m] == target) {\n                r = m - 1;\n            } else if (potions[m] \u003e target) {\n                r = m - 1;\n            } else {\n                l = m + 1;\n            }\n        }\n\n        // 1 2  3 4 5\n        //   lr\n        // r l\n        return n - l;\n    }\n    vector\u003cint\u003e successfulPairs(vector\u003cint\u003e\u0026 spells, vector\u003cint\u003e\u0026 potions, long long success) {\n        vector\u003cint\u003e result;\n\n        sort(potions.begin(), potions.end());\n\n        for(int\u0026 spell : spells) {\n            long long target = success / spell + (success % spell != 0);\n            result.push_back(binarySearch(potions, target));\n        }\n\n        return result;\n    }\n};\n```","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/binary-search/34":{"title":"34. Find First and Last Position of Element in Sorted Array","content":"\n```cpp\nclass Solution {\npublic:\n    int binarySearch(vector\u003cint\u003e\u0026 nums, int target, bool isSame){\n        int left = 0;\n        int right = nums.size() - 1;\n        int mid;\n\n        int index = -1;\n\n        while(left \u003c= right){\n            mid = left + (right - left) / 2;\n\n            if(nums[mid] == target){\n                index = mid;\n                if(isSame) right = mid - 1;\n                else left = mid + 1;\n            } else if (nums[mid] \u003e target){\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n\n        return index;\n    }\n\n    vector\u003cint\u003e searchRange(vector\u003cint\u003e\u0026 nums, int target) {\n        int left = binarySearch(nums, target, true);\n        if(left == -1) return {-1, -1};\n        int right = binarySearch(nums, target, false);\n        return {left, right};\n    }\n};\n```","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/binary-search/35":{"title":"35. Search Insert Position","content":"```cpp\nclass Solution {\npublic:\n    int searchInsert(vector\u003cint\u003e\u0026 nums, int target) {\n        int left = 0;\n        int right = nums.size() - 1;\n\n        while(left \u003c= right){\n            int mid = left + (right - left) / 2;\n            if(target == nums[mid]){\n                return mid;\n            } else if (target \u003e nums[mid]){\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return left;\n    }\n};\n```","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/binary-search/436":{"title":"436. Find Right Interval","content":"\n```cpp\nclass Solution {\npublic:\n\n    int binarySearch(vector\u003cvector\u003cint\u003e\u003e\u0026 intervals, int target){\n        int left = 0;\n        int right = intervals.size() - 1;\n        int mid;\n\n        // [[1,4], [2,3], [6,7]]\n        while(left \u003c= right){\n            mid = left + (right - left) / 2;\n            if(target == intervals[mid][0]){\n                right = mid - 1;\n            } else if (target \u003e intervals[mid][0]){\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return left == intervals.size() ? -1 : intervals[left][2];\n    }\n\n    vector\u003cint\u003e findRightInterval(vector\u003cvector\u003cint\u003e\u003e\u0026 intervals) {\n        for(int i = 0; i \u003c intervals.size(); i++){\n            intervals[i].push_back(i);\n        }\n\n        vector\u003cvector\u003cint\u003e\u003e base = intervals;\n\n        sort(intervals.begin(), intervals.end());\n\n        vector\u003cint\u003e result;\n        for(auto\u0026 interval : base){\n            result.push_back(binarySearch(intervals, interval[1]));\n        }\n        return result;\n    }\n};\n```","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/binary-search/611":{"title":"611. Valid Triangle Number","content":"\n```cpp\nclass Solution {\npublic:\n    int binarySearch(vector\u003cint\u003e\u0026 nums, int target, int left){\n        // find the number that smaller than a + b\n        // for example: 2 2 3 3 4 4\n        // final:             r l\n        // return (l - left) number are smaller than a + b\n        int l = left;\n        int r = nums.size() - 1;\n        int mid;\n\n        while(l \u003c= r){\n            mid = l + (r - l) / 2;\n\n            if(nums[mid] == target){\n                r = mid - 1;\n            } else if(nums[mid] \u003e target){\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n        return l - left;\n    }\n\n    int triangleNumber(vector\u003cint\u003e\u0026 nums) {\n        int n = nums.size() - 1;\n        int ans = 0;\n\n        sort(nums.begin(), nums.end());\n\n        for(int i = 0; i \u003c n-1; i++){\n            for(int j = i+1; j \u003c n; j++){\n                int sum = nums[i] + nums[j];\n                ans += binarySearch(nums, sum, j+1);\n            }\n        }\n\n        return ans;\n    }\n};\n```","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/binary-search/702":{"title":"702. Search in a Sorted Array of Unknown Size","content":"\n```cpp\n/**\n * // This is the ArrayReader's API interface.\n * // You should not implement it, or speculate about its implementation\n * class ArrayReader {\n *   public:\n *     int get(int index);\n * };\n */\n\nclass Solution {\npublic:\n    int search(const ArrayReader\u0026 reader, int target) {\n        int l = 0;\n        int r = 1;\n        int mid;\n        int num;\n\n        // Find right most point which covered by 2^right-1 and 2^right\n        while(reader.get(r) != INT_MAX){\n            l = r;\n            r = r \u003c\u003c 1;\n        }\n\n        // Find right most point\n        while(l \u003c= r){\n            mid = l + (r - l) / 2;\n            if(reader.get(mid) == INT_MAX){\n                r = mid - 1;\n            } else {\n                l = mid + 1;\n            }\n        }\n\n        r = l;\n        l = 0;\n\n        while(l \u003c= r){\n            mid = l + (r - l) / 2;\n            num = reader.get(mid);\n            if(num == target) return mid;\n            else if(num \u003e target) r = mid - 1;\n            else l = mid + 1;\n        }\n        \n        return -1;\n    }\n};\n```","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/binary-search/704":{"title":"704. Binary Search","content":"\n```cpp\nclass Solution {\npublic:\n    int search(vector\u003cint\u003e\u0026 nums, int target) {\n        int left = 0;\n        int right = nums.size()-1;\n\n        while(left \u003c= right){\n            int mid = left + (right - left) / 2;\n            if(nums[mid] == target) {\n                return mid;\n            }\n            else if(target \u003e nums[mid]) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return -1;\n    }\n};\n```","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/binary-search/74":{"title":"74. Search a 2D Matrix","content":"\n```cpp\nclass Solution {\npublic:\n    bool searchMatrix(vector\u003cvector\u003cint\u003e\u003e\u0026 matrix, int target) {\n        int m = matrix.size();\n        int n = matrix[0].size();\n\n        int left = 0;\n        int right = m*n - 1;\n        int mid;\n\n        while(left \u003c= right){\n            mid = left + (right - left) / 2;\n\n            int row = mid / n;\n            int col = mid % n;\n            if(matrix[row][col] == target) return true;\n            else if(target \u003e matrix[row][col]){\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return false;\n    }\n};\n```","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/binary-search/744":{"title":"744. Find Smallest Letter Greater Than Target","content":"```cpp\nclass Solution {\npublic:\n    char nextGreatestLetter(vector\u003cchar\u003e\u0026 letters, char target) {\n        int left = 0;\n        int right = letters.size() - 1;\n        int mid;\n\n        while(left \u003c= right){\n            mid = left + (right - left) / 2;\n            if(letters[mid] \u003c= target){\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return left == letters.size() ? letters[0] : letters[left];\n    }\n};\n```","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/binary-search/852":{"title":"852. Peak Index in a Mountatin Array","content":"\n```cpp\nclass Solution {\npublic:\n    int peakIndexInMountainArray(vector\u003cint\u003e\u0026 arr) {\n        int l = 0;\n        int r = arr.size() - 1;\n        int mid;\n        // Use l \u003c r rather than l \u003c= r because I want to stop at l == r\n        // Seems like no effect in this question\n        while(l \u003c r){\n            mid = l + (r - l) / 2;\n            // Current is peak if left and right are smaller than mid\n            if(arr[mid-1] \u003c arr[mid] \u0026\u0026 arr[mid] \u003e arr[mid+1]){\n                return mid;\n            }\n            // Only move to mid to avoid illegal condition\n            if(arr[mid-1] \u003c arr[mid]){\n                l = mid;\n            } else {\n                r = mid;\n            }\n        }\n\n        return l;\n    }\n};\n```","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/binary-search/875":{"title":"875. Koko Eating Bananas","content":"\nIf we set `l \u003c r` and `r = m`\n```\nstate n-1\n\n3 4 5 6 7\n  l r\n  m\n\nstate n\n3 4 5 6 7\n  l\n  r\n```\n\n```cpp\nclass Solution {\npublic:\n    int minEatingSpeed(vector\u003cint\u003e\u0026 piles, int h) {\n        int l = 1;\n        int r = *max_element(piles.begin(), piles.end());\n        int m;\n        long long hours;\n\n        while(l \u003c= r){\n            m = l + (r - l) / 2;\n            hours = 0;\n            for(int\u0026 pile : piles){\n                hours += ((pile / m) + (pile % m != 0));\n            }\n\n            if(hours == h){\n                r = m - 1;\n            } else if(hours \u003e h){\n                l = m + 1;\n            } else {\n                r = m - 1;\n            }\n\n        }\n\n        return l;\n    }\n};\n```\n\nIf we set `l \u003c= r` and `r = m - 1`,\n\n```\nstate n-2\n\n3 4 5 6 7\n  l r\n  m\n\nstate n-1\n3 4 5 6 7\n  l\n  r\n  m\n\nstate n\n3 4 5 6 7\nl r\n```\n\n```cpp\nclass Solution {\npublic:\n    int minEatingSpeed(vector\u003cint\u003e\u0026 piles, int h) {\n        int l = 1;\n        int r = *max_element(piles.begin(), piles.end());\n        int m;\n        int hours;\n\n        while(l \u003c r){\n            m = l + (r - l) / 2;\n            hours = 0;\n            for(int\u0026 pile : piles){\n                hours += ((pile / m) + (pile % m != 0));\n            }\n\n            if(hours == h){\n                r = m;\n            } else if(hours \u003e h){\n                l = m + 1;\n            } else {\n                r = m;\n            }\n\n        }\n\n        return l;\n    }\n};\n```","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/greedy/":{"title":"","content":"","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/greedy/121":{"title":"121.Best Time to Buy and Sell Stock","content":"\n```cpp\nclass Solution {\npublic:\n    int maxProfit(vector\u003cint\u003e\u0026 prices) {\n        int result = 0;\n        int minPrice = 100000;\n\n        for(int\u0026 price : prices) {\n            // find minPrice\n            // if price is smaller than minPrice, replace minPrice\n            // else, stock can be selled, compare to the result\n            if(price \u003c minPrice){\n                minPrice = price;\n            } else {\n                result = max(result, price - minPrice);\n            }\n        }\n\n        return result;\n    }\n};\n```","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/hashmap/":{"title":"","content":"","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/hashmap/242":{"title":"242. Valid Anagrams","content":"\n```cpp\nclass Solution {\npublic:\n    bool isAnagram(string s, string t) {\n        // If size different, it isn't anagram\n        if(s.size() != t.size())\n            return false;\n        \n        unordered_map\u003cchar, int\u003e charToCount;\n\n        for(char c : s) {\n            charToCount[c]++;\n        }\n\n        for(char c : t) {\n            charToCount[c]--;\n        }\n\n        for(int i = 0; i \u003c 26; i++) {\n            char c = 'a' + i;\n\n            if(charToCount[c] != 0)\n                return false;\n\n        }\n\n        return true;\n    }\n};\n```","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/linkedlist/":{"title":"","content":"","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/linkedlist/24":{"title":"24. Swap nodes by pairs","content":"\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* swapPairs(ListNode* head) {\n        // 1 2 3 4\n        // s f\n        ListNode* dummy = new ListNode();\n        dummy-\u003enext = head;\n\n        ListNode* fast = dummy;\n        ListNode* slow = dummy;\n        ListNode* before = dummy;\n\n        while(fast-\u003enext != nullptr \u0026\u0026 fast-\u003enext-\u003enext != nullptr) {\n            fast = fast-\u003enext-\u003enext;\n            slow = slow-\u003enext;\n\n            // swap fast and slow\n            // dummy -\u003e 1 -\u003e 2 -\u003e 3 -\u003e 4\n            // b.    .  s.   f.   n\n            ListNode* next = fast-\u003enext;\n            fast-\u003enext = slow;\n            slow-\u003enext = next;\n            before-\u003enext = fast;\n            fast = slow;\n            before = slow;\n        }\n\n        return dummy-\u003enext;\n    }\n};\n```","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/recursion/":{"title":"","content":"","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/recursion/227":{"title":"227. Basic Calculator II","content":"\n```cpp\nclass Solution {\npublic:\n    int getNumber(string\u0026 expression, int\u0026 pos){\n        int result = 0;\n        while((isdigit(expression[pos]) || expression[pos] == ' ') \u0026\u0026 pos \u003c expression.size()){\n            if(isdigit(expression[pos])){\n                result = result * 10 + (expression[pos] - '0');\n            }\n            pos++;\n        }\n        return result;\n    }\n\n    int parseTerm(string\u0026 expression, int\u0026 pos){\n        int result = getNumber(expression, pos);\n        \n        while(pos \u003c expression.size() \u0026\u0026 (expression[pos] == '*' || expression[pos] == '/')){\n            char op = expression[pos++];\n            int nextNumber = getNumber(expression, pos);\n            if(op == '*'){\n                result *= nextNumber;\n            } else if(op == '/'){\n                result /= nextNumber;\n            }\n        }\n        return result;\n    }\n\n    int parseExpression(string\u0026 expression, int\u0026 pos){\n        int result = parseTerm(expression, pos);\n\n        while(pos \u003c expression.size() \u0026\u0026 (expression[pos] == '+' || expression[pos] == '-')){\n            char op = expression[pos++];\n            int nextTerm = parseTerm(expression, pos);\n            if(op == '+'){\n                result += nextTerm;\n            } else if(op == '-'){\n                result -= nextTerm;\n            }\n        }\n        return result;\n    }\n\n    int calculate(string s) {\n        int pos = 0;\n        return parseExpression(s, pos);\n    }\n};\n```","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/recursion/268":{"title":"268. Missing Number","content":"```cpp\nclass Solution {\npublic:\n    int missingNumber(vector\u003cint\u003e\u0026 nums) {\n        int size = nums.size();\n        \n        int expect_sum = size * (size+1) / 2;\n        \n        int actual_sum = 0;\n\n        for(int i = 0; i \u003c size; i++) {\n            actual_sum += nums[i];\n        }\n\n        return expect_sum - actual_sum;\n    }\n};\n```","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/recursion/285":{"title":"285. Inorder Successor in BST","content":"\n```cpp\nclass Solution {\npublic:\n    bool isTarget = false;\n    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {\n        if(root == nullptr) return nullptr;\n        \n        TreeNode* left = inorderSuccessor(root-\u003eleft, p);\n        if(left != nullptr) return left;\n\n        if(isTarget){\n            return root;\n        }\n        if(p-\u003eval == root-\u003eval){\n            isTarget = true;\n        }\n        TreeNode* right = inorderSuccessor(root-\u003eright, p);\n        if(right != nullptr) return right;\n        return nullptr;\n    }\n};\n\n```\n\n```cpp\nclass Solution {\npublic:\n    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {\n        TreeNode* sucessor = nullptr;\n\n        while(root != nullptr){\n            if(root-\u003eval \u003c= p-\u003eval){\n                root = root-\u003eright;\n            } else {\n                sucessor = root;\n                root = root-\u003eleft;\n            }\n        }\n\n        return sucessor;\n    }\n};\n```","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/recursion/772":{"title":"772. Basic Calculator III","content":"\n```cpp\nclass Solution {\npublic:\n    int getNumber(string\u0026 expression, int\u0026 pos){\n        int result = 0;\n        while(isdigit(expression[pos]) \u0026\u0026 pos \u003c expression.size()){\n            result = result * 10 + (expression[pos] - '0');     \n            pos++;\n        }\n        return result;\n    }\n\n    int parseFactor(string\u0026 expression, int\u0026 pos){\n        if(expression[pos] == '('){\n            pos++;\n            int result = parseExpression(expression, pos);\n            pos++;\n            return result;\n        }\n        return getNumber(expression, pos);\n    }\n\n    int parseTerm(string\u0026 expression, int\u0026 pos){\n        int result = parseFactor(expression, pos);\n        \n        while(pos \u003c expression.size() \u0026\u0026 (expression[pos] == '*' || expression[pos] == '/')){\n            char op = expression[pos++];\n            int nextFactor = parseFactor(expression, pos);\n            if(op == '*'){\n                result *= nextFactor;\n            } else if(op == '/'){\n                result /= nextFactor;\n            }\n        }\n        return result;\n    }\n\n    int parseExpression(string\u0026 expression, int\u0026 pos){\n        int result = parseTerm(expression, pos);\n\n        while(pos \u003c expression.size() \u0026\u0026 (expression[pos] == '+' || expression[pos] == '-')){\n            char op = expression[pos++];\n            int nextTerm = parseTerm(expression, pos);\n            if(op == '+'){\n                result += nextTerm;\n            } else if(op == '-'){\n                result -= nextTerm;\n            }\n        }\n        return result;\n    }\n\n    int calculate(string s) {\n        int pos = 0;\n        return parseExpression(s, pos);\n    }\n};\n```","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/sliding-window/":{"title":"","content":"","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/sliding-window/209":{"title":"209. Minimum Size Subarray Sum","content":"\n```cpp\nclass Solution {\npublic:\n    int minSubArrayLen(int target, vector\u003cint\u003e\u0026 nums) {\n        int left = 0;\n        int sum = 0;\n        int ans = INT_MAX;\n\n        for(int right = 0; right \u003c nums.size(); right++) {\n            sum += nums[right];\n\n            while(sum \u003e= target) {\n                ans = min(ans, right - left + 1);\n                sum -= nums[left++];\n            }\n                \n        }\n        return ans == INT_MAX ? 0 : ans;\n    }\n};\n```","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/two-pointer/":{"title":"","content":"","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/two-pointer/125":{"title":"125. Valid Palindrome","content":"\n```cpp\nclass Solution {\npublic:\n    bool isPalindrome(string s) {\n        // two point left and right\n        // if meet not alpha or number, skip\n        // compare s[left] and s[right]\n        // if equal, continue\n        // if not equal return false\n        // if left == right, return true\n\n        int left = 0, right = s.size() - 1;\n\n        for(; left \u003c right; left++, right--) {\n            while(left \u003c right \u0026\u0026 !isalnum(s[left])) {\n                left++;\n            }\n\n            while(left \u003c right \u0026\u0026 !isalnum(s[right])) {\n                right--;\n            }\n\n            if(tolower(s[left]) != tolower(s[right])) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n};\n```","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/two-pointer/141":{"title":"141. Linked List Cycle","content":"\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    bool hasCycle(ListNode *head) {\n        ListNode* fast = head;\n        ListNode* slow = head;\n\n        while(fast != nullptr \u0026\u0026 fast-\u003enext != nullptr){\n            fast = fast-\u003enext-\u003enext;\n            slow = slow-\u003enext;\n\n            if(fast == slow) {\n                return true;\n            }\n        }\n        return false;\n    }\n};\n```","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/two-pointer/142":{"title":"142. Linked List Cycle II","content":"\n```cpp\n/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode(int x) : val(x), next(NULL) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode *detectCycle(ListNode *head) {\n        // fast move 2 pos\n        // slow move 1 pos\n        // pos count: 2(x+y) = x + y + n(y + z)\n        // n = 1, x = z\n\n        ListNode* fast = head;\n        ListNode* slow = head;\n\n        while(fast != nullptr \u0026\u0026 fast-\u003enext != nullptr) {\n            fast = fast-\u003enext-\u003enext;\n            slow = slow-\u003enext;\n\n            // Encounter point find\n            if(fast == slow) {\n                slow = head;\n                \n                // fast starts from encouter ponit\n                // slow starts from head\n                // move together\n                while(fast != slow) {\n                    fast = fast-\u003enext;\n                    slow = slow-\u003enext;\n                }\n\n                // return new encounter point\n                return fast;\n            }\n        }\n\n        return nullptr;\n    }\n};\n```","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/two-pointer/15":{"title":"15. Three Sum","content":"\n```cpp\nclass Solution {\npublic:\n    void twoSum(vector\u003cint\u003e\u0026 nums, int target, int left, vector\u003cvector\u003cint\u003e\u003e\u0026 result) {\n        int l = left;\n        int r = nums.size() - 1;\n\n        while(l \u003c r) {\n            int sum = nums[l] + nums[r];\n            if(target \u003e sum) {\n                l++;\n            } else if (target \u003c sum) {\n                r--;\n            } else {\n                result.push_back({-target, nums[l], nums[r]});\n                l++;\n                r--;\n                while(nums[l] == nums[l-1] \u0026\u0026 l \u003c r) l++;\n                while(nums[r] == nums[r+1] \u0026\u0026 l \u003c r) r--;\n\n            }\n        }\n    }\n\n    vector\u003cvector\u003cint\u003e\u003e threeSum(vector\u003cint\u003e\u0026 nums) {\n        int n = nums.size();\n        vector\u003cvector\u003cint\u003e\u003e result;\n\n        sort(nums.begin(), nums.end());\n\n        for(int i = 0; i \u003c n-2; i++) {\n            if(i == 0 || nums[i] != nums[i-1] || nums[i] \u003e 0)\n                twoSum(nums, -nums[i], i+1, result);\n        }\n\n        return result;\n    }\n};\n```","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/two-pointer/26":{"title":"26. Remove Duplicates from Sorted Array","content":"\n```cpp\nclass Solution {\npublic:\n    int removeDuplicates(vector\u003cint\u003e\u0026 nums) {\n        // fast and slow start from 0\n        // fast go first\n        // if nums[fast] != nums[slow], slow++ and swap\n        // return slow\n        int fast = 1, slow = 0;\n\n        // 0 1 0 1 1 2 2 3 3 4\n        // 0 1 2 1 1 0 2 3 3 4\n        //     s       f\n        for(; fast \u003c nums.size(); fast++) {\n            if(nums[fast] != nums[slow]) {\n                slow++;\n                nums[slow] = nums[fast];\n            }\n        }\n\n        return slow + 1;\n    }\n};\n```","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/leetcode/two-pointer/977":{"title":"977. Squares of a Sorted Array","content":"\n## Method 1\n\n- Time Complexity: O(n)\n- Space Complexity: O(n)\n\n```cpp\nclass Solution {\npublic:\n    vector\u003cint\u003e sortedSquares(vector\u003cint\u003e\u0026 nums) {\n        int l = 0;\n        int r = nums.size() - 1;\n        int index = nums.size() - 1;\n        vector\u003cint\u003e result(nums.size(), 1);\n\n        while(l \u003c= r) {\n            int leftpower = nums[l] * nums[l];\n            int rightpower = nums[r] * nums[r];\n\n            if(leftpower \u003e rightpower) {\n                result[index--] = leftpower;\n                l++;\n            } else {\n                result[index--] = rightpower;\n                r--;\n            }\n        }\n\n        return result;\n    }\n};\n```\n","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/linux-kernel/":{"title":"","content":"","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/linux-kernel/add_system_call":{"title":"Add system call to linux","content":"\nOpen `include/uapi/asm-generic/unistd.h`\n\n```c\n#define __NR_get_cpuid 452\n__SYSCALL(__NR_get_cpuid, sys_get_cpuid)\n\n#undef __NR_syscalls\n#define __NR_syscalls 453\n```\n\nOpen `linux/kernel/sys.c`\n\n```c\nSYSCALL_DEFINE0(get_cpuid)\n{\n\treturn raw_smp_processor_id();\n}\n```\n","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/linux-kernel/write_first_kernel_module":{"title":"Write your first kernel module","content":"\n## Building Kernel Module\n\nCreate `rootkit.c`\n\n```cpp\n#include \u003clinux/module.h\u003e\n#include \u003clinux/syscalls.h\u003e\n#include \u003clinux/types.h\u003e\n\n#define OURMODNAME\t\"rootkit\"\n\nMODULE_AUTHOR(\"FOOBAR\");\nMODULE_DESCRIPTION(\"FOOBAR\");\nMODULE_LICENSE(\"Dual MIT/GPL\");\nMODULE_VERSION(\"0.1\");\n\nstatic int __init rootkit_init(void)\n{\n    printk(KERN_INFO \"hello, world!\\n\");\n\treturn 0;\n}\n\nstatic void __exit rootkit_exit(void)\n{\n\tprintk(KERN_INFO \"Goodbye, world!\\n\");\n}\n\nmodule_init(rootkit_init);\nmodule_exit(rootkit_exit);\n```\n\nCreate `Makefile`. Remember to update `KDIR` with your linux source code dir.\n\n```sh\nobj-m = rootkit.o\nPWD := $(shell pwd)\nEXTRA_CFLAGS = -Wall -g\nCROSS = aarch64-linux-gnu-\nKDIR = /home/jack/Desktop/linux/\n\nall:\n\t$(MAKE) ARCH=arm64 CROSS_COMPILE=$(CROSS) -C $(KDIR) M=$(PWD) modules\nclean:\n\t$(MAKE) -C $(KDIR) M=$(PWD) clean\n```\n\nCompile kernel module\n\n```sh\nmake all\n\n$ ls\nrootkit.ko\n```\n\nCopy `rootkit.ko` to qemu share folders.\n\n```sh\ncp rootkit.ko ../shared\n```\n\nOpen qemu vm.\n\n```sh\nqemu-system-aarch64 ...\n```\n\nInsert kernel module and list all kernel module\n\n```sh\n$ sudo insmod rootkit.ko\n$ sudo lsmod\n\nModule    Size  Used by\nrootkit  12232  0\n```\n\nRemove kernel module and look log by `dmesg`\n\n```sh\n$ sudo rmmod rootkit\n$ dmesg\n\nHello, world!\nGoodbye, world!\n```\n\n\n\n\n\n","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/xv6/":{"title":"","content":"","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/xv6/xv6-gdb":{"title":"Debug xv6 with gdb","content":"\n## Preparation\n\n```sh\n# Run xv6 with gdb\nmake qemu-gdb\n\n# Change to another terminal and connect to xv6-gdb\ngdb-multiarch -x .gdbinit\n```\n\n## Basic Command\n\n```sh\n# Set break point\nb syscall\nb module.c:67\n\n# Print source code\nlayout src\nlayout asm\n\n# Continue\nc\n\n# Step into\nstep\n\n# Step over\nnext\n\n# Print register or value\np /x $stvec\np /x $a7\np /x p-\u003eproc\n\n# List value of register\ninfo register\n\n# List args\ninfo args\n\n# See who call it\nbacktrace\n\n# Set value\nset xxx\n\n# Watching variable\nwatch a\n```","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/xv6/xv6-isatty":{"title":"Implement isatty on xv6","content":"\n## Problem\n\nThis bug happens when we try to run shell commands from a file:\n\n```sh\n// xargstest.sh\nmkdir a\necho hello \u003e a/b\nmkdir c\necho hello \u003e c/b\necho hello \u003e b\nfind . b | xargs grep hello\n```\n\nIt will print out `$` for all commands:\n\n```sh\n$ sh \u003c xargstest.sh\n$ $ $ $ $ $ hello\nhello\nhello\n$ $\n```\n\nThe problem is that we need to determine where the input comes from.\nIf it comes from terminal, the program should print out `$`. If it\ncomes from file, the program should not print out `$`.\n\n## isatty\n\n`isatty` is a system call that telling us whether the file descriptor comes from terminal or not.\n\n```c\nint main()\n{\n  if(isatty(0)){\n    printf(\"0 is device\\n\");\n  } else {\n    printf(\"0 is file\\n\");\n  }\n  exit(0);\n}\n```\n\nAfter writing some tests, we can see that when `isatty` is false when we send commands to `stdin` by\nfile redirection.\n\n```sh\n$ ./main\n0 is device\n$ ./main \u003c input.txt\n0 is file\n```\n\nTherefore, we need to implement `isatty` on xv6 to support this feature. The logic here is simple\nand not be tested for every scenario.\n\n```c\n// kernel/sysfile.c\nuint64\nsys_isatty(void)\n{\n  int fd;\n  struct file *f;\n\n  if(argfd(0, \u0026fd, \u0026f) \u003c 0){\n    return -1;\n  }\n\n  return f-\u003etype == FD_DEVICE;\n}\n```\n\nFinally, we modify `user/sh.c` and only print out `$` when commands come from terminal.\n\n```c\n// user/sh.c\nint\ngetcmd(char *buf, int nbuf)\n{\n  if(isatty(0)){\n    fprintf(2, \"$ \");\n  }\n  memset(buf, 0, nbuf);\n  gets(buf, nbuf);\n  if(buf[0] == 0) // EOF\n    return -1;\n  return 0;\n}\n```\n\n## Test\n\n```sh\n$ sh \u003c xargstest.sh\nhello\nhello\nhello\n```","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/xv6/xv6-lab-trap":{"title":"xv6 lab trap","content":"\n# Lab Trap\n\n- [x] RISC-V assembly (easy)\n- [x] Backtrace (moderate)\n- [ ] Alarm (hard)\n\n## RISC-V assembly (easy)\n\n\u003e Which registers contain arguments to functions? For example, which register holds 13 in main's call to¬†printf?\n\nAns: `a1`, `a2` will store arguments. Here `li a2,13` means that load immediate 13 to `a2`.\n\n```bash\nvoid main(void) {\n  1c:\t1141                \tadd\tsp,sp,-16\n  1e:\te406                \tsd\tra,8(sp)\n  20:\te022                \tsd\ts0,0(sp)\n  22:\t0800                \tadd\ts0,sp,16\n  printf(\"%d %d\\n\", f(8)+1, 13);\n  24:\t4635                \tli\ta2,13\n  26:\t45b1                \tli\ta1,12\n\t//...\t\n}\n```\n\n\u003e Where is the call to function¬†f¬†in the assembly code for main? Where is the call to¬†g? (Hint: the compiler may inline functions.)\n\u003e \n\n`f()` stored at `000000000000000e` and `g()` stored at `0000000000000000.`\n\n```bash\n0000000000000000 \u003cg\u003e:\n// ...\n\nint g(int x) {\n\t// ...\n}\n  // ...\n\n000000000000000e \u003cf\u003e:\n\nint f(int x) {\n\t// ...\n}\n```\n\n\u003e At what address is the function¬†printf¬†located?\n\u003e \n\n```bash\n0000000000000616 \u003cprintf\u003e:\n```\n\nWe can also get the same result by looking at how compiler calculates address\n\nauipc: add upper immediate to program counter and save to register\n\njalr: jump to certain address based on register and offset\n\n```bash\n30:\t00000097          \tauipc\tra,0x0\n34:\t5e6080e7          \tjalr\t1510(ra) # 616 \u003cprintf\u003e\n```\n\nSo the following steps are:\n\n1. program counter = 30\n2. add 0 to program counter and save to `ra`\n3. jump to ra + 1510: `hex(1510) + 0x30 = 0x5e6 + 0x30 = 0x616`\n\n\u003e What value is in the register¬†ra¬†just after the¬†jalr¬†to¬†printf¬†in¬†main?\n\u003e \n\nRead [risc-v-spec](https://riscv.org/wp-content/uploads/2017/05/riscv-spec-v2.2.pdf) at page 16:\n\n\u003caside\u003e\nüí° The indirect jump instruction JALR (jump and link register) uses the I-type encoding. The target address is obtained by adding the 12-bit signed I-immediate to the register rs1, then setting the least-significant bit of the result to zero. The address of the instruction following the jump (pc+4) is written to register rd. Register x0 can be used as the destination if the result is not required.\n\nWhen used with a base rs1=x0, JALR can be used to implement a single instruction subroutine call to the lowest 2 KiB or highest 2 KiB address region from anywhere in the address space, which could be used to implement fast calls to a small runtime library.\n\n\u003c/aside\u003e\n\nRegister `ra` is used for return address. Therefore, `jalr 1510(ra)` ra store `pc+4`, 34 + 4 = 38.\n\n## Backtrace (moderate)\n\n```c\nvoid\nbacktrace(void)\n{\n  uint64 fp = r_fp();\n\n  while(fp \u003c PGROUNDUP(fp)) {\n    uint64 ra = *(uint64*)(fp - 8); // return address at offset(-8)\n    printf(\"%p\\n\", ra);\n    fp = *(uint64*)(fp - 16); // previous frame pointer at offset(-16)\n  }\n}\n```\n\n## Alarm (hard)\n\nTBD","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/xv6/xv6-pwd":{"title":"Implement pwd on xv6","content":"\n## Flow\n\n- Open current path and get file stat\n- Keep finding the path like:   `./..` ‚Üí `./../..` ‚Üí `./../../..`\n- Iterate all files and folder by `read()` and find corresponding folder name by comparing parent inode number and current inode number.\n- Stop loop when parent inode number is equal to current inode number because it reaches the root.\n\n```sh\n// Use fstat to get current folder inode = 9\n// Iterate all inodes in parent folder to find\n// which folder inode = 9\n\n// root folder (parent)\n---- .  1\n |-- .. 1\n |-- a  9\n\n// folder /a (current)\n---- .  9\n |-- .. 1\n```\n\n```c\n#include \"kernel/types.h\"\n#include \"kernel/stat.h\"\n#include \"user/user.h\"\n#include \"kernel/fs.h\"\n\nvoid\npwd()\n{\n  char *path = \".\";\n  char buf[512];\n  int fd;\n  struct dirent de;\n  struct stat st, parentst;\n  char *result = \"\";\n\n  if((fd = open(path, 0)) \u003c 0){\n    fprintf(2, \"pwd: cannot open %s\\n\", path);\n    return;\n  }\n\n  if(fstat(fd, \u0026st) \u003c 0){\n    fprintf(2, \"pwd: cannot stat %s\\n\", path);\n    close(fd);\n    return;\n  }\n\n  strcpy(buf, path);\n  \n  int maxdepth = 20;\n  int depth = 0;\n\n  for(; depth \u003c maxdepth; depth++){\n\n    // Go to parent directory\n    strcpy(buf + strlen(buf), \"/..\");\n    \n    if((fd = open(buf, 0)) \u003c 0){\n      fprintf(2, \"pwd: cannot open %s\\n\", buf);\n      return;\n    }\n\n    if(fstat(fd, \u0026parentst) \u003c 0){\n      fprintf(2, \"pwd: cannot stat %s\\n\", buf);\n      close(fd);\n      return;\n    }\n\n    // If parent ino is equal to current ino,\n    // it indicates that it reaches the root\n    if(parentst.ino == st.ino)\n      break;\n\n    // Iterate parent directory and find the folder\n    // that match current directory by checking ino\n    while(read(fd, \u0026de, sizeof(de)) == sizeof(de)){\n      if(de.inum == 0)\n        continue;\n      if(de.inum == st.ino){\n        char resultbuf[512];\n        strcpy(resultbuf, result);\n        strcpy(result, \"/\");\n        strcpy(result+1, de.name);\n        strcpy(result+strlen(result), resultbuf);\n      }\n    }\n\n    // Move to parent folder\n    st = parentst;\n  }\n\n  // Root folder\n  if(strlen(result) == 0)\n    result = \"/\";\n\n  printf(\"%s\\n\", result);\n  close(fd);\n}\n\nint\nmain(int argc, char *argv[])\n{\n  pwd();\n  exit(0);\n}\n```\n\n## Test\n\n```sh\n$ mkdir a\n$ mkdir a/b\n$ /pwd\n/a/b\n$ cd ..\n$ /pwd\n/a\n$ cd ..\n$ pwd\n/\n```","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null},"/xv6/xv6-xargs":{"title":"Implement xargs on xv6","content":"\n## Flow\n\n- Read `user/sh.c` and get more ideas\n- Read command by `gets`\n- Child process will execute the commands after xargs.\n- Parent process will execute the front commands after child process is finished.\n\n```c\n#include \"kernel/types.h\"\n#include \"kernel/param.h\"\n#include \"user/user.h\"\n\nint\ngetcmd(char *buf, int nbuf)\n{\n  memset(buf, 0, nbuf);\n  gets(buf, nbuf);\n  if(buf[0] == 0) // EOF\n    return -1;\n  return 0;\n}\n\nint\nmain(int argc, char *argv[])\n{\n  char *args[argc+1];\n  int i;\n  char buf[512];\n\n  for(i=1; i\u003cargc; i++)\n    args[i-1] = argv[i];\n\n  while(getcmd(buf, sizeof(buf)) \u003e= 0){\n    buf[strlen(buf)-1] = 0; // chop \\n\n    args[argc-1] = buf;\n    args[argc] = 0;\n\n    if(fork() == 0){\n      exec(args[0], args);\n      printf(\"xargs: exec error\\n\");\n      exit(1);\n    } else {\n      wait(0);\n    }\n  }\n\n  exit(0);\n}\n```\n\n## Test\n\n```sh\n$ echo hello jack | xargs echo bye\nbye hello jack\n```","lastmodified":"2024-03-05T20:23:49.291473932Z","tags":null}}