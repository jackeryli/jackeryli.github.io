<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Welcome! on</title><link>https://jackeryli.github.io/</link><description>Recent content in Welcome! on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://jackeryli.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Configure gdb for qemu</title><link>https://jackeryli.github.io/bare-metal/qemu-gdb/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/bare-metal/qemu-gdb/</guid><description> Compile code with gdb # Enable layout src when you use gdb.
CFLAGS = -ggdb Add flag to qemu # qemu-system-aarch64 -M raspi3b -s -S -kernel kernel.img Create .gdbinit under project folders # Connect gdb on 127.0.0.1:1234 Symbol-file enables breakpoint in gdb set architecture aarch64 target remote 127.0.0.1:1234 symbol-file kernel.elf Run qemu with gdb # make qemu-gdb # Run on another window gdb-multiarch -x .gdbinit # Start using gdb b printk layout src c</description></item><item><title>Debug xv6 with gdb</title><link>https://jackeryli.github.io/xv6/xv6-gdb/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/xv6/xv6-gdb/</guid><description> Preparation # # Run xv6 with gdb make qemu-gdb # Change to another terminal and connect to xv6-gdb gdb-multiarch -x .gdbinit Basic Command # # Set break point b syscall b module.c:67 # Print source code layout src layout asm # Continue c # Step into step # Step over next # Print register or value p /x $stvec p /x $a7 p /x p-&amp;gt;proc # List value of register info register # List args info args # See who call it backtrace # Set value set xxx # Watching variable watch a</description></item><item><title>Write bootloader for raspberry pi 3</title><link>https://jackeryli.github.io/bare-metal/bootloader/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/bare-metal/bootloader/</guid><description>We need three files:
kernel.ld: define the memory layout and tell the hardware where to find entry.S. entry.S: run on single core, do initialization and jump to start.c. start.c: first code. Compile to the kernel image:
Link entry.S and kernel.ld to create kernel.elf Build kernel.img by kernel.elf Boot qemu with kernel.img kernel.ld # ENTRY( _xxx ): tell system to find _entry for the following execution 0x80000: first code will put at 0x800000 because 0 ~ 0x80000 are for io-mapping in arm64 text: put codes data: initialized variable bss: uinitialized variable ENTRY( _entry ) SECTIONS { .</description></item><item><title>Configure miniUART to print characters to terminal</title><link>https://jackeryli.github.io/bare-metal/uart/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/bare-metal/uart/</guid><description>From rpi3 docs, IO physical address started from 0x3F000000.
Physical addresses range from 0x3F000000 to 0x3FFFFFFF for peripherals. The bus addresses for peripherals are set up to map onto the peripheral bus address range starting at 0x7E000000. Thus a peripheral advertised here at bus address 0x7Ennnnnn is available at physical address 0x3Fnnnnnn. And the docs said miniuart register virtual address is at:
Address Reg Name Description 0x7E21 5000 AUX_IRQ Auxiliary Interrupt status 0x7E21 5004 AUX_ENABLES Auxiliary enables 0x7E21 5040 AUX_MU_IO_REG Mini Uart I/O Data So we define the registers we need for miniuart:</description></item><item><title>Write a simple shell</title><link>https://jackeryli.github.io/bare-metal/shell/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/bare-metal/shell/</guid><description>We write a shell that can run the following commands:
help hello timestamp reboot typedef struct cmd_struct { char* name; char* msg; int (*func)(char**); } cmd_struct; int help(char**); int hello(char**); int timestamp(char**); int reboot(char**); // TODO: argv for each commands char* argv[10]; cmd_struct cmds[NCOMMANDS] = { { .name = &amp;#34;help&amp;#34;, .msg = &amp;#34;print available commands&amp;#34;, .func = help }, { .name = &amp;#34;hello&amp;#34;, .msg = &amp;#34;print hello world&amp;#34;, .func = hello }, { .</description></item><item><title>Add system call to linux</title><link>https://jackeryli.github.io/linux-kernel/add_system_call/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/linux-kernel/add_system_call/</guid><description>Open include/uapi/asm-generic/unistd.h
#define __NR_get_cpuid 452 __SYSCALL(__NR_get_cpuid, sys_get_cpuid) #undef __NR_syscalls #define __NR_syscalls 453 Open linux/kernel/sys.c
SYSCALL_DEFINE0(get_cpuid) { return raw_smp_processor_id(); }</description></item><item><title>Write your first kernel module</title><link>https://jackeryli.github.io/linux-kernel/write_first_kernel_module/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/linux-kernel/write_first_kernel_module/</guid><description>Building Kernel Module # Create rootkit.c
#include &amp;lt;linux/module.h&amp;gt; #include &amp;lt;linux/syscalls.h&amp;gt; #include &amp;lt;linux/types.h&amp;gt; #define OURMODNAME &amp;#34;rootkit&amp;#34; MODULE_AUTHOR(&amp;#34;FOOBAR&amp;#34;); MODULE_DESCRIPTION(&amp;#34;FOOBAR&amp;#34;); MODULE_LICENSE(&amp;#34;Dual MIT/GPL&amp;#34;); MODULE_VERSION(&amp;#34;0.1&amp;#34;); static int __init rootkit_init(void) { printk(KERN_INFO &amp;#34;hello, world!\n&amp;#34;); return 0; } static void __exit rootkit_exit(void) { printk(KERN_INFO &amp;#34;Goodbye, world!\n&amp;#34;); } module_init(rootkit_init); module_exit(rootkit_exit); Create Makefile. Remember to update KDIR with your linux source code dir.
obj-m = rootkit.o PWD := $(shell pwd) EXTRA_CFLAGS = -Wall -g CROSS = aarch64-linux-gnu- KDIR = /home/jack/Desktop/linux/ all: $(MAKE) ARCH=arm64 CROSS_COMPILE=$(CROSS) -C $(KDIR) M=$(PWD) modules clean: $(MAKE) -C $(KDIR) M=$(PWD) clean Compile kernel module</description></item><item><title>Implement isatty on xv6</title><link>https://jackeryli.github.io/xv6/xv6-isatty/</link><pubDate>Wed, 24 Jan 2024 12:16:46 +0800</pubDate><guid>https://jackeryli.github.io/xv6/xv6-isatty/</guid><description>I desire to fix the bug that it prints a $ when processing shell commands from a file.</description></item><item><title>Implement xargs on xv6</title><link>https://jackeryli.github.io/xv6/xv6-xargs/</link><pubDate>Tue, 23 Jan 2024 12:16:46 +0800</pubDate><guid>https://jackeryli.github.io/xv6/xv6-xargs/</guid><description>Implement xargs on xv6</description></item><item><title>Implement pwd on xv6</title><link>https://jackeryli.github.io/xv6/xv6-pwd/</link><pubDate>Mon, 22 Jan 2024 12:16:46 +0800</pubDate><guid>https://jackeryli.github.io/xv6/xv6-pwd/</guid><description>pwd will print working directory. Here we will implement pwd on xv6.</description></item><item><title>xv6 lab trap</title><link>https://jackeryli.github.io/xv6/xv6-lab-trap/</link><pubDate>Wed, 11 Oct 2023 12:16:46 +0800</pubDate><guid>https://jackeryli.github.io/xv6/xv6-lab-trap/</guid><description>Implement MIT xv6 lab:trap</description></item><item><title>0003.Longest Substring Without Repeating Character</title><link>https://jackeryli.github.io/leetcode/sliding-window/0003/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/sliding-window/0003/</guid><description>class Solution { public int lengthOfLongestSubstring(String s) { int n = s.length(); int i = 0; int ans = 0; Set&amp;lt;Character&amp;gt; existSet = new HashSet&amp;lt;&amp;gt;(); for(int j = 0; j &amp;lt; n; j++) { Character c = s.charAt(j); while(existSet.contains(c)) { existSet.remove(s.charAt(i)); i++; } existSet.add(c); ans = Math.max(ans, j - i + 1); } return ans; } }</description></item><item><title>0006.Zigzag Conversion</title><link>https://jackeryli.github.io/leetcode/string/0006/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/string/0006/</guid><description>class Solution { public String convert(String s, int numRows) { if(numRows == 1) return s; int n = s.length(); StringBuilder[] sb = new StringBuilder[numRows]; int row = 0; int dir = 1; for(int i = 0; i &amp;lt; n; i++) { if(sb[row] == null) sb[row] = new StringBuilder(); sb[row].append(s.charAt(i)); if(row == numRows - 1 || ((row == 0) &amp;amp;&amp;amp; (i != 0))) dir = -dir; row += dir; } StringBuilder result = new StringBuilder(); for(int i = 0; i &amp;lt; numRows; i++) { if(sb[i] == null) continue; result.</description></item><item><title>0011.Container With Most Water</title><link>https://jackeryli.github.io/leetcode/two-pointer/0011/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/two-pointer/0011/</guid><description>class Solution { public: int maxArea(vector&amp;lt;int&amp;gt;&amp;amp; height) { int l = 0; int r = height.size() - 1; int result = 0; while(l &amp;lt; r) { result = max(result, (r - l) * min(height[l], height[r])); if(height[l] &amp;lt; height[r]) l++; else r--; } return result; } };</description></item><item><title>0015. Three Sum</title><link>https://jackeryli.github.io/leetcode/two-pointer/0015/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/two-pointer/0015/</guid><description>class Solution { public: void twoSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target, int left, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; result) { int l = left; int r = nums.size() - 1; while(l &amp;lt; r) { int sum = nums[l] + nums[r]; if(target &amp;gt; sum) { l++; } else if (target &amp;lt; sum) { r--; } else { result.push_back({-target, nums[l], nums[r]}); l++; r--; while(nums[l] == nums[l-1] &amp;amp;&amp;amp; l &amp;lt; r) l++; while(nums[r] == nums[r+1] &amp;amp;&amp;amp; l &amp;lt; r) r--; } } } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; threeSum(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.</description></item><item><title>0017.Letter Combination</title><link>https://jackeryli.github.io/leetcode/backtracking/0017/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/backtracking/0017/</guid><description>class Solution { public: vector&amp;lt;string&amp;gt; result; string path = &amp;#34;&amp;#34;; unordered_map&amp;lt;char, string&amp;gt; num2alpha; void backtracking(const string&amp;amp; digits, int index) { if(index == digits.size()) { result.emplace_back(path); return; } for(char c : num2alpha[digits[index]]) { path.push_back(c); backtracking(digits, index + 1); path.pop_back(); } } vector&amp;lt;string&amp;gt; letterCombinations(string digits) { if(digits.size() == 0) return {}; num2alpha[&amp;#39;2&amp;#39;] = &amp;#34;abc&amp;#34;; num2alpha[&amp;#39;3&amp;#39;] = &amp;#34;def&amp;#34;; num2alpha[&amp;#39;4&amp;#39;] = &amp;#34;ghi&amp;#34;; num2alpha[&amp;#39;5&amp;#39;] = &amp;#34;jkl&amp;#34;; num2alpha[&amp;#39;6&amp;#39;] = &amp;#34;mno&amp;#34;; num2alpha[&amp;#39;7&amp;#39;] = &amp;#34;pqrs&amp;#34;; num2alpha[&amp;#39;8&amp;#39;] = &amp;#34;tuv&amp;#34;; num2alpha[&amp;#39;9&amp;#39;] = &amp;#34;wxyz&amp;#34;; backtracking(digits, 0); return result; } };</description></item><item><title>0020.Valid Parentheses</title><link>https://jackeryli.github.io/leetcode/stack/0020/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/stack/0020/</guid><description>class Solution { public: bool isValid(string s) { stack&amp;lt;char&amp;gt; sta; for(char c : s){ if(c == &amp;#39;(&amp;#39; || c == &amp;#39;[&amp;#39; || c == &amp;#39;{&amp;#39;){ sta.push(c); } else { if(sta.empty()){ return false; } int t = sta.top(); if(c == &amp;#39;)&amp;#39; &amp;amp;&amp;amp; t != &amp;#39;(&amp;#39;){ return false; } else if (c == &amp;#39;]&amp;#39; &amp;amp;&amp;amp; t != &amp;#39;[&amp;#39;){ return false; } else if (c == &amp;#39;}&amp;#39; &amp;amp;&amp;amp; t != &amp;#39;{&amp;#39;){ return false; } sta.</description></item><item><title>0022.Generate Parentheses</title><link>https://jackeryli.github.io/leetcode/backtracking/0022/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/backtracking/0022/</guid><description>class Solution { public: vector&amp;lt;string&amp;gt; result; string path; void backtracking(int left, int right, int n) { if(left &amp;gt; n || right &amp;gt; n) return; if(left == n &amp;amp;&amp;amp; right == n) { result.push_back(path); return; } if(left &amp;gt;= right) { path.push_back(&amp;#39;(&amp;#39;); backtracking(left+1, right, n); path.pop_back(); } if(left &amp;gt; right) { path.push_back(&amp;#39;)&amp;#39;); backtracking(left, right+1, n); path.pop_back(); } } vector&amp;lt;string&amp;gt; generateParenthesis(int n) { path = &amp;#34;(&amp;#34;; backtracking(1, 0, n); return result; } };</description></item><item><title>0024. Swap nodes by pairs</title><link>https://jackeryli.github.io/leetcode/linkedlist/0024/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/linkedlist/0024/</guid><description>/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* swapPairs(ListNode* head) { // 1 2 3 4 // s f ListNode* dummy = new ListNode(); dummy-&amp;gt;next = head; ListNode* fast = dummy; ListNode* slow = dummy; ListNode* before = dummy; while(fast-&amp;gt;next !</description></item><item><title>0026. Remove Duplicates from Sorted Array</title><link>https://jackeryli.github.io/leetcode/two-pointer/0026/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/two-pointer/0026/</guid><description>class Solution { public: int removeDuplicates(vector&amp;lt;int&amp;gt;&amp;amp; nums) { // fast and slow start from 0 // fast go first // if nums[fast] != nums[slow], slow++ and swap // return slow int fast = 1, slow = 0; // 0 1 0 1 1 2 2 3 3 4 // 0 1 2 1 1 0 2 3 3 4 // s f for(; fast &amp;lt; nums.size(); fast++) { if(nums[fast] != nums[slow]) { slow++; nums[slow] = nums[fast]; } } return slow + 1; } };</description></item><item><title>0034. Find First and Last Position of Element in Sorted Array</title><link>https://jackeryli.github.io/leetcode/binary-search/0034/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/0034/</guid><description>class Solution { public: int binarySearch(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target, bool isSame){ int left = 0; int right = nums.size() - 1; int mid; int index = -1; while(left &amp;lt;= right){ mid = left + (right - left) / 2; if(nums[mid] == target){ index = mid; if(isSame) right = mid - 1; else left = mid + 1; } else if (nums[mid] &amp;gt; target){ right = mid - 1; } else { left = mid + 1; } } return index; } vector&amp;lt;int&amp;gt; searchRange(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int left = binarySearch(nums, target, true); if(left == -1) return {-1, -1}; int right = binarySearch(nums, target, false); return {left, right}; } };</description></item><item><title>0035. Search Insert Position</title><link>https://jackeryli.github.io/leetcode/binary-search/0035/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/0035/</guid><description>class Solution { public: int searchInsert(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int left = 0; int right = nums.size() - 1; while(left &amp;lt;= right){ int mid = left + (right - left) / 2; if(target == nums[mid]){ return mid; } else if (target &amp;gt; nums[mid]){ left = mid + 1; } else { right = mid - 1; } } return left; } };</description></item><item><title>0036.Valid Sudoku</title><link>https://jackeryli.github.io/leetcode/hashmap/0036/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/hashmap/0036/</guid><description>class Solution { public: bool isValidSudoku(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board) { int m = board.size(); int n = board[0].size(); int columnMap[9][9]; int rowMap[9][9]; int threeMap[9][9]; memset(rowMap, 0, sizeof(rowMap)); memset(columnMap, 0, sizeof(columnMap)); memset(threeMap, 0, sizeof(threeMap)); for(int i = 0; i &amp;lt; m; i++){ for(int j = 0; j &amp;lt; n; j++){ if(isdigit(board[i][j])) { int idx = board[i][j] - &amp;#39;1&amp;#39;; // columnMap if(columnMap[j][idx] != 0) return false; columnMap[j][idx] = 1; // rowMap if(rowMap[i][idx] != 0) return false; rowMap[i][idx] = 1; // threeMap int threeIdx = i/3 * 3 + j/3; if(threeMap[threeIdx][idx] !</description></item><item><title>0039. Combination Sum</title><link>https://jackeryli.github.io/leetcode/backtracking/0039/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/backtracking/0039/</guid><description>class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result; vector&amp;lt;int&amp;gt; path; void backtracking(vector&amp;lt;int&amp;gt;&amp;amp; candidates, int target, int sum) { if(target == sum) { result.push_back(path); return; } else if(sum &amp;gt; target) { return; } for(int i = 0; i &amp;lt; candidates.size(); i++) { if(path.size() == 0 || path[path.size()-1] &amp;lt;= candidates[i]) { path.push_back(candidates[i]); backtracking(candidates, target, sum + candidates[i]); path.pop_back(); } } } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; combinationSum(vector&amp;lt;int&amp;gt;&amp;amp; candidates, int target) { backtracking(candidates, target, 0); return result; } }; class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result; vector&amp;lt;int&amp;gt; path; void backtracking(vector&amp;lt;int&amp;gt;&amp;amp; candidates, int target, int sum, int startIndex) { if(target == sum) { result.</description></item><item><title>0046.Permutations</title><link>https://jackeryli.github.io/leetcode/backtracking/0046/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/backtracking/0046/</guid><description>class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result; vector&amp;lt;int&amp;gt; path; void backtracking(vector&amp;lt;int&amp;gt;&amp;amp; nums, vector&amp;lt;bool&amp;gt;&amp;amp; visited) { if(path.size() == nums.size()) { result.push_back(path); return; } for(int i = 0; i &amp;lt; nums.size(); i++) { if(visited[i] == false) { path.push_back(nums[i]); visited[i] = true; backtracking(nums, visited); path.pop_back(); visited[i] = false; } } } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; permute(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;bool&amp;gt; visited(nums.size(), false); backtracking(nums, visited); return result; } };</description></item><item><title>0048.Rotate Image</title><link>https://jackeryli.github.io/leetcode/array/0048/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/array/0048/</guid><description>class Solution { public: void rotate(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix) { // row column to column row // left to right int m = matrix.size(); for(int i = 0; i &amp;lt; m; i++){ for(int j = i; j &amp;lt; m; j++) { swap(matrix[i][j], matrix[j][i]); } } for(int i = 0; i &amp;lt; m; i++){ for(int j = 0; j &amp;lt; m/2; j++){ swap(matrix[i][j], matrix[i][m-j-1]); } } } };</description></item><item><title>0049.Group Anagrams</title><link>https://jackeryli.github.io/leetcode/hashmap/0049/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/hashmap/0049/</guid><description>class Solution { public: vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; groupAnagrams(vector&amp;lt;string&amp;gt;&amp;amp; strs) { unordered_map&amp;lt;string, vector&amp;lt;string&amp;gt;&amp;gt; map1; vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; result; for(string str : strs){ string key = str; sort(key.begin(), key.end()); map1[key].push_back(str); } for(auto it = map1.begin(); it != map1.end(); it++){ result.push_back(it-&amp;gt;second); } return result; } };</description></item><item><title>0053.Maximum Subarray</title><link>https://jackeryli.github.io/leetcode/dp/0053/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/dp/0053/</guid><description>DP # class Solution { public: int maxSubArray(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.size(); // dp[i]: subarray with largest sum end at i vector&amp;lt;int&amp;gt; dp(n); int result = nums[0]; dp[0] = nums[0]; for(int i = 1; i &amp;lt; n; i++) { dp[i] = max(dp[i-1] + nums[i], nums[i]); result = max(result, dp[i]); } return result; } }; Greedy # class Solution { public: int maxSubArray(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int sum = 0; int n = nums.</description></item><item><title>0063. Unique Path II</title><link>https://jackeryli.github.io/leetcode/dp/0063/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/dp/0063/</guid><description>class Solution { public: int uniquePathsWithObstacles(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; obstacleGrid) { int m = obstacleGrid.size(); int n = obstacleGrid[0].size(); int dp[m][n]; memset(dp, 0, sizeof(dp)); for(int i = 0; i &amp;lt; m &amp;amp;&amp;amp; obstacleGrid[i][0] == 0; i++) dp[i][0] = 1; for(int j = 0; j &amp;lt; n &amp;amp;&amp;amp; obstacleGrid[0][j] == 0; j++) dp[0][j] = 1; for(int i = 1; i &amp;lt; m; i++) { for(int j = 1; j &amp;lt; n; j++) { if(obstacleGrid[i][j] !</description></item><item><title>0074. Search a 2D Matrix</title><link>https://jackeryli.github.io/leetcode/binary-search/0074/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/0074/</guid><description>class Solution { public: bool searchMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix, int target) { int m = matrix.size(); int n = matrix[0].size(); int left = 0; int right = m*n - 1; int mid; while(left &amp;lt;= right){ mid = left + (right - left) / 2; int row = mid / n; int col = mid % n; if(matrix[row][col] == target) return true; else if(target &amp;gt; matrix[row][col]){ left = mid + 1; } else { right = mid - 1; } } return false; } };</description></item><item><title>0077.Combinations</title><link>https://jackeryli.github.io/leetcode/backtracking/0077/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/backtracking/0077/</guid><description>class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result; vector&amp;lt;int&amp;gt; path; void backtracking(int n, int k, int start) { if(path.size() == k) { result.push_back(path); return; } for(int i = start; i &amp;lt;= n; i++) { path.push_back(i); backtracking(n, k, i + 1); path.pop_back(); } } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; combine(int n, int k) { backtracking(n, k, 1); return result; } };</description></item><item><title>0079. Word Search</title><link>https://jackeryli.github.io/leetcode/backtracking/0079/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/backtracking/0079/</guid><description>class Solution { public: bool backtracking(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board, string&amp;amp; word, int index, int row, int col) { if(index == word.size()) { return true; } if(row &amp;lt; 0 || row == board.size() || col &amp;lt; 0 || col == board[0].size() || word[index] != board[row][col]) { return false; } board[row][col] = &amp;#39;#&amp;#39;; bool r1 = backtracking(board, word, index + 1, row + 1, col); bool r2 = backtracking(board, word, index + 1, row - 1, col); bool r3 = backtracking(board, word, index + 1, row, col + 1); bool r4 = backtracking(board, word, index + 1, row, col - 1); board[row][col] = word[index]; return r1 || r2 || r3 || r4; } bool exist(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board, string word) { for(int i = 0; i &amp;lt; board.</description></item><item><title>0100.Same Tree</title><link>https://jackeryli.github.io/leetcode/binary-tree/0100/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-tree/0100/</guid><description>class Solution { public: bool isSameTree(TreeNode* p, TreeNode* q) { if(p == nullptr &amp;amp;&amp;amp; q == nullptr) return true; if(p == nullptr || q == nullptr) return false; if(p-&amp;gt;val != q-&amp;gt;val) return false; return isSameTree(p-&amp;gt;left, q-&amp;gt;left) &amp;amp;&amp;amp; isSameTree(p-&amp;gt;right, q-&amp;gt;right); } };</description></item><item><title>0101.Symmetric Tree</title><link>https://jackeryli.github.io/leetcode/binary-tree/0101/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-tree/0101/</guid><description>Recursive # class Solution { public: bool compare(TreeNode* left, TreeNode* right) { if(left == nullptr &amp;amp;&amp;amp; right == nullptr) return true; if(left != nullptr &amp;amp;&amp;amp; right == nullptr) return false; if(left == nullptr &amp;amp;&amp;amp; right != nullptr) return false; if(left-&amp;gt;val != right-&amp;gt;val) return false; bool c1 = compare(left-&amp;gt;left, right-&amp;gt;right); bool c2 = compare(left-&amp;gt;right, right-&amp;gt;left); return c1 &amp;amp;&amp;amp; c2; } bool isSymmetric(TreeNode* root) { if(root == nullptr) return true; return compare(root-&amp;gt;left, root-&amp;gt;right); } }; Queue # class Solution { public: bool isSymmetric(TreeNode* root) { if(root == nullptr) return true; queue&amp;lt;TreeNode*&amp;gt; que; que.</description></item><item><title>0104. Maximum Depth of Binary Tree</title><link>https://jackeryli.github.io/leetcode/binary-tree/0104/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-tree/0104/</guid><description>class Solution { public: int maxDepth(TreeNode* root) { if(root == nullptr) return 0; return max(maxDepth(root-&amp;gt;left), maxDepth(root-&amp;gt;right)) + 1; } };</description></item><item><title>0105.Construct Binary Tree from Preorder and Inorder Traversal</title><link>https://jackeryli.github.io/leetcode/binary-tree/0105/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-tree/0105/</guid><description>struct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {} }; class Solution { public: TreeNode* traverse(vector&amp;lt;int&amp;gt;&amp;amp; preorder, vector&amp;lt;int&amp;gt;&amp;amp; inorder, int pl, int pr, int il, int ir) { if(pl == pr) return nullptr; TreeNode* root = new TreeNode(preorder[pl]); if(pr - pl == 1) return root; int delimeter = 0; for(delimeter = il; delimeter &amp;lt; ir; delimeter++) { if(inorder[delimeter] == preorder[pl]) { break; } } root-&amp;gt;left = traverse(preorder, inorder, pl+1, pl+1+delimeter-il, il, delimeter); root-&amp;gt;right = traverse(preorder, inorder, pl+1+delimeter-il, pr, delimeter+1, ir); return root; } TreeNode* buildTree(vector&amp;lt;int&amp;gt;&amp;amp; preorder, vector&amp;lt;int&amp;gt;&amp;amp; inorder) { if(preorder.</description></item><item><title>0106.Construct Binary Tree from Inorder and Postorder Traversal</title><link>https://jackeryli.github.io/leetcode/binary-tree/0106/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-tree/0106/</guid><description>struct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode() : val(-1), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {} }; class Solution { public: TreeNode* traverse(vector&amp;lt;int&amp;gt;&amp;amp; inorder, vector&amp;lt;int&amp;gt;&amp;amp; postorder, int inorderBegin, int inorderEnd, int postorderBegin, int postorderEnd) { if(postorderBegin == postorderEnd) return nullptr; TreeNode* root = new TreeNode(postorder[postorderEnd-1]); if(postorderEnd - postorderBegin == 1) return root; int delimeter = 0; for(delimeter = inorderBegin; delimeter &amp;lt; inorderEnd; delimeter++) { if(inorder[delimeter] == root-&amp;gt;val) break; } root-&amp;gt;left = traverse(inorder, postorder, inorderBegin, delimeter, postorderBegin, postorderBegin + (delimeter - inorderBegin)); root-&amp;gt;right = traverse(inorder, postorder, delimeter + 1, inorderEnd, postorderBegin + (delimeter - inorderBegin), postorderEnd-1); return root; } TreeNode* buildTree(vector&amp;lt;int&amp;gt;&amp;amp; inorder, vector&amp;lt;int&amp;gt;&amp;amp; postorder) { if(inorder.</description></item><item><title>0108. Convert Sorted Array to Binary Search Tree</title><link>https://jackeryli.github.io/leetcode/divide_conquer/0108/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/divide_conquer/0108/</guid><description>class Solution { public: TreeNode* sortedArrayToBST(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if(nums.size() == 0) return nullptr; int mid = nums.size() / 2; TreeNode* root = new TreeNode(nums[mid]); vector&amp;lt;int&amp;gt; leftNodes(nums.begin(), nums.begin() + mid); vector&amp;lt;int&amp;gt; rightNodes(nums.begin() + mid + 1, nums.end()); root-&amp;gt;left = sortedArrayToBST(leftNodes); root-&amp;gt;right = sortedArrayToBST(rightNodes); return root; } }; class Solution { public: TreeNode* helper(vector&amp;lt;int&amp;gt;&amp;amp; nums, int left, int right) { if(left &amp;gt; right) return nullptr; int mid = left + (right - left) / 2; TreeNode* root = new TreeNode(nums[mid]); root-&amp;gt;left = helper(nums, left, mid - 1); root-&amp;gt;right = helper(nums, mid + 1, right); return root; } TreeNode* sortedArrayToBST(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if(nums.</description></item><item><title>0112.Path Sum</title><link>https://jackeryli.github.io/leetcode/binary-tree/0112/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-tree/0112/</guid><description>Recursive # class Solution { public: bool traverse(TreeNode* root, int targetSum, int currentSum) { if(root == nullptr) return false; currentSum += root-&amp;gt;val; if(root-&amp;gt;left == nullptr &amp;amp;&amp;amp; root-&amp;gt;right == nullptr) { return currentSum == targetSum; } return traverse(root-&amp;gt;left, targetSum, currentSum) || traverse(root-&amp;gt;right, targetSum, currentSum); } bool hasPathSum(TreeNode* root, int targetSum) { if(root == nullptr) return false; return traverse(root, targetSum, 0); } }; Stack # class Solution { public: bool hasPathSum(TreeNode* root, int targetSum) { if(root == nullptr) return false; stack&amp;lt;pair&amp;lt;TreeNode*, int&amp;gt;&amp;gt; sta; sta.</description></item><item><title>0114. Flatten Binary Tree to Linked List</title><link>https://jackeryli.github.io/leetcode/binary-tree/0114/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-tree/0114/</guid><description>Recursion # class Solution { public: TreeNode* traverse(TreeNode* root) { if(root == nullptr) return nullptr; if(root-&amp;gt;left == nullptr &amp;amp;&amp;amp; root-&amp;gt;right == nullptr) { return root; } TreeNode* leftTail = traverse(root-&amp;gt;left); TreeNode* rightTail = traverse(root-&amp;gt;right); if(leftTail != nullptr) { leftTail-&amp;gt;right = root-&amp;gt;right; root-&amp;gt;right = root-&amp;gt;left; root-&amp;gt;left = nullptr; } return rightTail != nullptr ? rightTail : leftTail; } void flatten(TreeNode* root) { if(root == nullptr) return; traverse(root); } }; Linkedlist # class Solution { public: void flatten(TreeNode* root) { if(root == nullptr) return; TreeNode* node = root; while(node !</description></item><item><title>0117.Populating Next Right Pointers in Each Node</title><link>https://jackeryli.github.io/leetcode/binary-tree/0117/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-tree/0117/</guid><description>Level Order Traversal # Time Comlexity: O(n) Space Complexity: O(n) class Solution { public: Node* connect(Node* root) { if(root == nullptr) return nullptr; queue&amp;lt;Node*&amp;gt; que; que.push(root); while(!que.empty()) { int size = que.size(); Node* node = que.front(); if(que.front()-&amp;gt;left != nullptr) que.push(que.front()-&amp;gt;left); if(que.front()-&amp;gt;right != nullptr) que.push(que.front()-&amp;gt;right); que.pop(); for(int i = 1; i &amp;lt; size; i++){ node-&amp;gt;next = que.front(); node = que.front(); if(que.front()-&amp;gt;left != nullptr) que.push(que.front()-&amp;gt;left); if(que.front()-&amp;gt;right != nullptr) que.push(que.front()-&amp;gt;right); que.pop(); } } return root; } }; Linkedlist # Time Complexity: O(n) Space Complexity: O(1) class Solution { public: Node* prev; Node* leftmost; void processChild(Node* childNode) { if(childNode !</description></item><item><title>0121.Best Time to Buy and Sell Stock</title><link>https://jackeryli.github.io/leetcode/greedy/0121/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/greedy/0121/</guid><description>class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices) { int result = 0; int minPrice = 100000; for(int&amp;amp; price : prices) { // find minPrice // if price is smaller than minPrice, replace minPrice // else, stock can be selled, compare to the result if(price &amp;lt; minPrice){ minPrice = price; } else { result = max(result, price - minPrice); } } return result; } };</description></item><item><title>0123. Best Time to Buy and Sell Stock III</title><link>https://jackeryli.github.io/leetcode/dp/0123/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/dp/0123/</guid><description>class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices) { int firstBuy = -prices[0]; int firstSell = 0; int secondBuy = -prices[0]; int secondSell = 0; for(int i = 1; i &amp;lt; prices.size(); i++) { firstBuy = max(firstBuy, -prices[i]); firstSell = max(firstSell, prices[i] + firstBuy); secondBuy = max(secondBuy, -prices[i] + firstSell); secondSell = max(secondSell, prices[i] + secondBuy); } return secondSell; } };</description></item><item><title>0125. Valid Palindrome</title><link>https://jackeryli.github.io/leetcode/two-pointer/0125/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/two-pointer/0125/</guid><description>class Solution { public: bool isPalindrome(string s) { // two point left and right // if meet not alpha or number, skip // compare s[left] and s[right] // if equal, continue // if not equal return false // if left == right, return true int left = 0, right = s.size() - 1; for(; left &amp;lt; right; left++, right--) { while(left &amp;lt; right &amp;amp;&amp;amp; !isalnum(s[left])) { left++; } while(left &amp;lt; right &amp;amp;&amp;amp; !</description></item><item><title>0128.Longest Consecutive Sequence</title><link>https://jackeryli.github.io/leetcode/hashmap/0128/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/hashmap/0128/</guid><description>class Solution { public: int longestConsecutive(vector&amp;lt;int&amp;gt;&amp;amp; nums) { unordered_set&amp;lt;int&amp;gt; set1; int result = 0; for(int&amp;amp; num : nums){ set1.insert(num); } for(int&amp;amp; num : nums){ int start; if(set1.find(num-1) == set1.end()){ start = num; } int distance = 0; while(set1.find(start) != set1.end()){ start = start + 1; distance++; } result = max(result, distance); } return result; } };</description></item><item><title>0129. Sum Root to Leaf Numbers</title><link>https://jackeryli.github.io/leetcode/binary-tree/0129/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-tree/0129/</guid><description>Recursion # class Solution { public: int result = 0; void traverse(TreeNode* root, int sum) { if(root == nullptr) return; int newSum = sum + root-&amp;gt;val; if(root-&amp;gt;left == nullptr &amp;amp;&amp;amp; root-&amp;gt;right == nullptr) { // leaf, add sum to result result += newSum; return; } newSum *= 10; if(root-&amp;gt;left != nullptr) traverse(root-&amp;gt;left, newSum); if(root-&amp;gt;right != nullptr) traverse(root-&amp;gt;right, newSum); } int sumNumbers(TreeNode* root) { traverse(root, 0); return result; } }; Stack # class Solution { public: int sumNumbers(TreeNode* root) { if(root == nullptr) return 0; int result = 0; int currentSum = 0; stack&amp;lt;pair&amp;lt;TreeNode*,int&amp;gt;&amp;gt; sta; sta.</description></item><item><title>0133.Clone Graph</title><link>https://jackeryli.github.io/leetcode/graph/0133/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/graph/0133/</guid><description>DFS # class Solution { public: unordered_map&amp;lt;int, Node*&amp;gt; visited; Node* cloneGraph(Node* node) { if(node == nullptr) return nullptr; if(visited.find(node-&amp;gt;val) != visited.end()) { return visited[node-&amp;gt;val]; } Node* newNode = new Node(node-&amp;gt;val); visited[node-&amp;gt;val] = newNode; for(auto neighbor : node-&amp;gt;neighbors) { newNode-&amp;gt;neighbors.emplace_back(cloneGraph(neighbor)); } return newNode; } }; BFS # class Solution { public: Node* cloneGraph(Node* node) { if(node == nullptr) return nullptr; queue&amp;lt;Node*&amp;gt; que; unordered_map&amp;lt;int, Node*&amp;gt; visited; Node* newNode = new Node(node-&amp;gt;val); visited[node-&amp;gt;val] = newNode; que.</description></item><item><title>0134. Gas Station</title><link>https://jackeryli.github.io/leetcode/greedy/0134/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/greedy/0134/</guid><description>Naive (TLE) # class Solution { public int canCompleteCircuit(int[] gas, int[] cost) { // 1 2 3 4 5 1 2 3 4 5 // 3 4 5 1 2 3 4 5 1 2 // 2 3 4 2 3 4 // 3 4 3 3 4 3 int n = gas.length; int[] circleGas = new int[n*2]; int[] circleCost = new int[n*2]; for(int i = 0; i &amp;lt; n; i++) { circleGas[i] = gas[i]; circleGas[i + n] = gas[i]; circleCost[i] = cost[i]; circleCost[i + n] = cost[i]; } for(int i = 0; i &amp;lt; n; i++) { if(gas[i] &amp;gt;= cost[i]) { // start checking int gasSum = gas[i]; int costSum = cost[i]; boolean isFailed = false; for(int j = i+1; j &amp;lt; i + n; j++) { gasSum += circleGas[j]; costSum += circleCost[j]; if(costSum &amp;gt; gasSum) { // failed isFailed = true; break; } } if(!</description></item><item><title>0139. Word Break</title><link>https://jackeryli.github.io/leetcode/dp/0139/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/dp/0139/</guid><description>class Solution { public: bool wordBreak(string s, vector&amp;lt;string&amp;gt;&amp;amp; wordDict) { unordered_set&amp;lt;string&amp;gt; wordSet(wordDict.begin(), wordDict.end()); int n = s.size(); // dp[i]: sub string length i can be segament in Dict vector&amp;lt;bool&amp;gt; dp(n + 1, false); dp[0] = true; // Because the order of the string is important // Iterate bag then iterate items for(int i = 1; i &amp;lt;= n; i++) { for(int j = 0; j &amp;lt; i; j++) { string sub = s.</description></item><item><title>0141. Linked List Cycle</title><link>https://jackeryli.github.io/leetcode/two-pointer/0141/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/two-pointer/0141/</guid><description>/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: bool hasCycle(ListNode *head) { ListNode* fast = head; ListNode* slow = head; while(fast != nullptr &amp;amp;&amp;amp; fast-&amp;gt;next != nullptr){ fast = fast-&amp;gt;next-&amp;gt;next; slow = slow-&amp;gt;next; if(fast == slow) { return true; } } return false; } };</description></item><item><title>0142. Linked List Cycle II</title><link>https://jackeryli.github.io/leetcode/two-pointer/0142/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/two-pointer/0142/</guid><description>/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *detectCycle(ListNode *head) { // fast move 2 pos // slow move 1 pos // pos count: 2(x+y) = x + y + n(y + z) // n = 1, x = z ListNode* fast = head; ListNode* slow = head; while(fast !</description></item><item><title>0146.LRU Cache</title><link>https://jackeryli.github.io/leetcode/design/0146/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/design/0146/</guid><description>struct Node { int key; int val; Node* next; Node* prev; Node(int key, int val) : key(key), val(val), next(nullptr), prev(nullptr){} }; class LRUCache { public: int cap; Node* head = new Node(-1, -1); Node* tail = new Node(-1, -1); unordered_map&amp;lt;int, Node*&amp;gt; kv; LRUCache(int capacity) { this-&amp;gt;cap = capacity; head-&amp;gt;next = tail; tail-&amp;gt;prev = head; } void removeNode(Node* curr) { // prev -&amp;gt; curr -&amp;gt; next; Node* prev = curr-&amp;gt;prev; Node* next = curr-&amp;gt;next; prev-&amp;gt;next = next; next-&amp;gt;prev = prev; } void addNode(Node* curr) { // head -&amp;gt; next; Node* next = head-&amp;gt;next; head-&amp;gt;next = curr; curr-&amp;gt;prev = head; curr-&amp;gt;next = next; next-&amp;gt;prev = curr; } // If not found, return -1 // If found, // 1.</description></item><item><title>0148. Sort List</title><link>https://jackeryli.github.io/leetcode/divide_conquer/0148/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/divide_conquer/0148/</guid><description>/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* findMiddle(ListNode* head) { ListNode* fast = head; ListNode* slow = nullptr; while(fast != nullptr &amp;amp;&amp;amp; fast-&amp;gt;next != nullptr) { fast = fast-&amp;gt;next-&amp;gt;next; slow = (slow == nullptr) ?</description></item><item><title>0151.Reverse Words in a String</title><link>https://jackeryli.github.io/leetcode/two-pointer/0151/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/two-pointer/0151/</guid><description>class Solution { public void reverseStr(char[] s, int l, int r) { while(l &amp;lt; r) { char temp = s[l]; s[l++] = s[r]; s[r--] = temp; } } public String reverseWords(String s) { char[] str = s.toCharArray(); int n = str.length; reverseStr(str, 0 , n - 1); int slow = 0; int fast = 0; while(fast &amp;lt; n) { // skip whitespace while(fast &amp;lt; n &amp;amp;&amp;amp; str[fast] == &amp;#39; &amp;#39;) fast++; // add whitespace if(slow &amp;gt; 0 &amp;amp;&amp;amp; fast &amp;lt; n) str[slow++] = &amp;#39; &amp;#39;; int start = slow; // move word to correct place while(fast &amp;lt; n &amp;amp;&amp;amp; str[fast] !</description></item><item><title>0167. Two Sum - Input Array is Sorted</title><link>https://jackeryli.github.io/leetcode/two-pointer/0167/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/two-pointer/0167/</guid><description>class Solution { public: vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; numbers, int target) { int l = 0; int r = numbers.size() - 1; int sum; while(l &amp;lt; r) { sum = numbers[l] + numbers[r]; if(sum == target) return {l+1, r+1}; else if (sum &amp;gt; target) r--; else l++; } return {}; } };</description></item><item><title>0188. Best Time to Buy and Sell Stock IV</title><link>https://jackeryli.github.io/leetcode/dp/0188/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/dp/0188/</guid><description>class Solution { public: int maxProfit(int k, vector&amp;lt;int&amp;gt;&amp;amp; prices) { // Do nothing, firstBuy, firstSell, secondBuy, secondSell, ... vector&amp;lt;int&amp;gt; dp(2 * k + 1); for(int i = 1; i &amp;lt; 2 * k + 1; i += 2) { dp[i] = -prices[0]; } for(int i = 1; i &amp;lt; prices.size(); i++) { for(int j = 1; j &amp;lt; 2 * k + 1; j++) { if(j % 2 == 1) { // buy score // last day sell score - today stock price dp[j] = max(dp[j], dp[j-1] - prices[i]); } else { // sell score // today stock price + last day buy score dp[j] = max(dp[j], prices[i] + dp[j-1]); } } } return dp[2 * k]; } };</description></item><item><title>0189.Rotate Array</title><link>https://jackeryli.github.io/leetcode/two-pointer/0189/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/two-pointer/0189/</guid><description>class Solution { public: void rotate(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { reverse(nums.begin(), nums.end()); if(k &amp;gt; nums.size()) k = k % nums.size(); reverse(nums.begin(), nums.begin() + k); reverse(nums.begin() + k, nums.end()); } };</description></item><item><title>0200.Number of Islands</title><link>https://jackeryli.github.io/leetcode/graph/0200/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/graph/0200/</guid><description>DFS # Time Complexity: O(M*N) Space Complexity: O(M*N) class Solution { public: void dfs(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; grid, int i, int j) { if(i &amp;lt; 0 || i &amp;gt;= grid.size() || j &amp;lt; 0 || j &amp;gt;= grid[0].size() || grid[i][j] != &amp;#39;1&amp;#39;) return; grid[i][j] = &amp;#39;2&amp;#39;; dfs(grid, i+1, j); dfs(grid, i-1, j); dfs(grid, i, j+1); dfs(grid, i, j-1); } int numIslands(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; grid) { int m = grid.size(); int n = grid[0].size(); int result = 0; for(int i = 0; i &amp;lt; m; i++) { for(int j = 0; j &amp;lt; n; j++) { if(grid[i][j] == &amp;#39;1&amp;#39;) { result++; dfs(grid, i, j); } } } return result; } }; BFS # Time Complexity: O(M*N) Space Complexity: class Solution { public: int numIslands(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; grid) { int result = 0; int m = grid.</description></item><item><title>0202.Happy Number</title><link>https://jackeryli.github.io/leetcode/hashmap/0202/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/hashmap/0202/</guid><description>class Solution { public: bool isHappy(int n) { int sum = 0; unordered_set&amp;lt;int&amp;gt; sumSet; while(1){ sum = 0; while(n &amp;gt; 0){ int digit = n % 10; sum += (digit * digit); n /= 10; } if(sum == 1) return true; if(sumSet.find(sum) != sumSet.end()) return false; else sumSet.insert(sum); n = sum; } return false; } }; class Solution { public: unordered_set&amp;lt;int&amp;gt; sumSet; int getNext(int num){ int sum = 0; while(num &amp;gt; 0){ int digit = num % 10; sum += (digit * digit); num /= 10; } return sum; } bool isHappy(int n) { while(n !</description></item><item><title>0207.Course Schedule</title><link>https://jackeryli.github.io/leetcode/graph/0207/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/graph/0207/</guid><description>DFS # Draw colors
0: unvisited 1: visiting 2: visited class Solution { public: bool isCycle(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; graph, vector&amp;lt;int&amp;gt;&amp;amp; visited, int current) { if(visited[current] == 1) return true; if(visited[current] == 2) return false; visited[current] = 1; for(int&amp;amp; edge : graph[current]) { if(isCycle(graph, visited, edge) == true) return true; } visited[current] = 2; return false; } bool canFinish(int numCourses, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; prerequisites) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; graph(numCourses, vector&amp;lt;int&amp;gt;(0)); // Establish graph for(auto pre : prerequisites) { graph[pre[1]].</description></item><item><title>0209. Minimum Size Subarray Sum</title><link>https://jackeryli.github.io/leetcode/sliding-window/0209/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/sliding-window/0209/</guid><description>C++ # class Solution { public: int minSubArrayLen(int target, vector&amp;lt;int&amp;gt;&amp;amp; nums) { int left = 0; int sum = 0; int ans = INT_MAX; for(int right = 0; right &amp;lt; nums.size(); right++) { sum += nums[right]; while(sum &amp;gt;= target) { ans = min(ans, right - left + 1); sum -= nums[left++]; } } return ans == INT_MAX ? 0 : ans; } }; Java # class Solution { public int minSubArrayLen(int target, int[] nums) { int i = 0; int n = nums.</description></item><item><title>0210. Course Schedule II</title><link>https://jackeryli.github.io/leetcode/graph/0201/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/graph/0201/</guid><description>class Solution { public: vector&amp;lt;int&amp;gt; findOrder(int numCourses, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; prerequisites) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; graph(numCourses); vector&amp;lt;int&amp;gt; indegree(numCourses); vector&amp;lt;int&amp;gt; result; queue&amp;lt;int&amp;gt; que; for(auto&amp;amp; pre : prerequisites) { graph[pre[1]].push_back(pre[0]); indegree[pre[0]]++; } for(int i = 0; i &amp;lt; numCourses; i++) { if(indegree[i] == 0) que.push(i); } if(que.empty() == true) return {}; int nodeVisited = 0; while(que.empty() == false) { int current = que.front(); que.pop(); nodeVisited++; result.push_back(current); for(auto&amp;amp; edge : graph[current]) { indegree[edge]--; if(indegree[edge] == 0) que.push(edge); } } if(nodeVisited !</description></item><item><title>0215.Kth Largest Element in an Array</title><link>https://jackeryli.github.io/leetcode/quickselect/0215/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/quickselect/0215/</guid><description>class Solution { public: int partition(vector&amp;lt;int&amp;gt;&amp;amp; nums, int left, int right) { // choose pivot int pivot = nums[right]; int l = left; int r = right - 1; // swap left and right based on pivot while(l &amp;lt;= r) { if(nums[l] &amp;lt; pivot &amp;amp;&amp;amp; nums[r] &amp;gt; pivot) swap(nums[l++], nums[r--]); if(nums[l] &amp;gt;= pivot) l++; if(nums[r] &amp;lt;= pivot) r--; } // 5 3 4 // lr // 5 3 4 // r l // swap pivot to l swap(nums[right], nums[l]); return l; } int findKthLargest(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { // use quickselect // Time: O(n) // Space: O(1) int l = 0; int r = nums.</description></item><item><title>0219. Contains Duplicated II</title><link>https://jackeryli.github.io/leetcode/hashmap/0219/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/hashmap/0219/</guid><description>class Solution { public: bool containsNearbyDuplicate(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { unordered_map&amp;lt;int, int&amp;gt; num2FirstIdx; for(int i = 0; i &amp;lt; nums.size(); i++) { if(num2FirstIdx.find(nums[i]) == num2FirstIdx.end()){ num2FirstIdx[nums[i]] = i; } else { if(i - num2FirstIdx[nums[i]] &amp;lt;= k) return true; num2FirstIdx[nums[i]] = i; } } return false; } };</description></item><item><title>0222.Count Complete Tree Nodes</title><link>https://jackeryli.github.io/leetcode/binary-tree/0222/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-tree/0222/</guid><description>class Solution { public: int countNodes(TreeNode* root) { if(root == nullptr) return 0; return countNodes(root-&amp;gt;left) + countNodes(root-&amp;gt;right) + 1; } };</description></item><item><title>0226.Invert Binary Tree</title><link>https://jackeryli.github.io/leetcode/binary-tree/0226/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-tree/0226/</guid><description> Recursive # class Solution { public: TreeNode* invertTree(TreeNode* root) { if(root == nullptr) return nullptr; swap(root-&amp;gt;left, root-&amp;gt;right); invertTree(root-&amp;gt;left); invertTree(root-&amp;gt;right); return root; } }; Stack # class Solution { public: TreeNode* invertTree(TreeNode* root) { if(root == nullptr) return nullptr; stack&amp;lt;TreeNode*&amp;gt; sta; sta.push(root); while(!sta.empty()){ TreeNode* node = sta.top(); sta.pop(); swap(node-&amp;gt;left, node-&amp;gt;right); if(node-&amp;gt;right != nullptr) sta.push(node-&amp;gt;right); if(node-&amp;gt;left != nullptr) sta.push(node-&amp;gt;left); } return root; } };</description></item><item><title>0227. Basic Calculator II</title><link>https://jackeryli.github.io/leetcode/recursion/227/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/recursion/227/</guid><description>class Solution { public: int getNumber(string&amp;amp; expression, int&amp;amp; pos){ int result = 0; while((isdigit(expression[pos]) || expression[pos] == &amp;#39; &amp;#39;) &amp;amp;&amp;amp; pos &amp;lt; expression.size()){ if(isdigit(expression[pos])){ result = result * 10 + (expression[pos] - &amp;#39;0&amp;#39;); } pos++; } return result; } int parseTerm(string&amp;amp; expression, int&amp;amp; pos){ int result = getNumber(expression, pos); while(pos &amp;lt; expression.size() &amp;amp;&amp;amp; (expression[pos] == &amp;#39;*&amp;#39; || expression[pos] == &amp;#39;/&amp;#39;)){ char op = expression[pos++]; int nextNumber = getNumber(expression, pos); if(op == &amp;#39;*&amp;#39;){ result *= nextNumber; } else if(op == &amp;#39;/&amp;#39;){ result /= nextNumber; } } return result; } int parseExpression(string&amp;amp; expression, int&amp;amp; pos){ int result = parseTerm(expression, pos); while(pos &amp;lt; expression.</description></item><item><title>0236. Lowest Common Ancestor of a Binary Tree</title><link>https://jackeryli.github.io/leetcode/binary-tree/0236/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-tree/0236/</guid><description>class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(root == nullptr) return nullptr; if(root == p || root == q) return root; TreeNode* left = lowestCommonAncestor(root-&amp;gt;left, p, q); TreeNode* right = lowestCommonAncestor(root-&amp;gt;right, p, q); if(left != nullptr &amp;amp;&amp;amp; right != nullptr) { return root; } return left != nullptr ? left : right; } };</description></item><item><title>0242. Valid Anagrams</title><link>https://jackeryli.github.io/leetcode/hashmap/0242/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/hashmap/0242/</guid><description>class Solution { public: bool isAnagram(string s, string t) { // If size different, it isn&amp;#39;t anagram if(s.size() != t.size()) return false; unordered_map&amp;lt;char, int&amp;gt; charToCount; for(char c : s) { charToCount[c]++; } for(char c : t) { charToCount[c]--; } for(int i = 0; i &amp;lt; 26; i++) { char c = &amp;#39;a&amp;#39; + i; if(charToCount[c] != 0) return false; } return true; } }; class Solution { public: bool isAnagram(string s, string t) { int mapS2count[26]; memset(mapS2count, 0, sizeof(mapS2count)); for(char c : s){ mapS2count[c - &amp;#39;a&amp;#39;]++; } for(char c : t){ mapS2count[c - &amp;#39;a&amp;#39;]--; } for(int i = 0; i &amp;lt; 26; i++){ if(mapS2count[i] !</description></item><item><title>0268. Missing Number</title><link>https://jackeryli.github.io/leetcode/recursion/268/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/recursion/268/</guid><description>class Solution { public: int missingNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int size = nums.size(); int expect_sum = size * (size+1) / 2; int actual_sum = 0; for(int i = 0; i &amp;lt; size; i++) { actual_sum += nums[i]; } return expect_sum - actual_sum; } };</description></item><item><title>0279. Perfect Squares</title><link>https://jackeryli.github.io/leetcode/dp/0279/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/dp/0279/</guid><description>class Solution { public: int numSquares(int n) { // dp[i] = least number of perfect square numbers vector&amp;lt;int&amp;gt; dp(n+1, 10001); dp[0] = 0; for(int i = 0; i &amp;lt;= n; i++) { for(int j = 1; j * j &amp;lt;= i; j++) { dp[i] = min(dp[i], dp[i - j*j] + 1); } } return dp[n] == 10001 ? 0 : dp[n]; } };</description></item><item><title>0285. Inorder Successor in BST</title><link>https://jackeryli.github.io/leetcode/recursion/285/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/recursion/285/</guid><description>class Solution { public: bool isTarget = false; TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) { if(root == nullptr) return nullptr; TreeNode* left = inorderSuccessor(root-&amp;gt;left, p); if(left != nullptr) return left; if(isTarget){ return root; } if(p-&amp;gt;val == root-&amp;gt;val){ isTarget = true; } TreeNode* right = inorderSuccessor(root-&amp;gt;right, p); if(right != nullptr) return right; return nullptr; } }; class Solution { public: TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) { TreeNode* sucessor = nullptr; while(root != nullptr){ if(root-&amp;gt;val &amp;lt;= p-&amp;gt;val){ root = root-&amp;gt;right; } else { sucessor = root; root = root-&amp;gt;left; } } return sucessor; } };</description></item><item><title>0290.Word Pattern</title><link>https://jackeryli.github.io/leetcode/hashmap/0290/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/hashmap/0290/</guid><description>class Solution { public: bool wordPattern(string pattern, string s) { unordered_map&amp;lt;char, string&amp;gt; mapP2S; unordered_map&amp;lt;string, char&amp;gt; mapS2P; int i = 0; int l = 0, r = 0; int n = s.size(); while(l &amp;lt; n &amp;amp;&amp;amp; r &amp;lt; n){ // Split the string by space while(s[r] != &amp;#39; &amp;#39; &amp;amp;&amp;amp; r &amp;lt; n) r++; // ensure r range string sub = s.substr(l, r - l); // blank index to left index // if pattern and string are all not recorded before, record it if(mapP2S.</description></item><item><title>0300.Longest Increasing Subsequence</title><link>https://jackeryli.github.io/leetcode/dp/0300/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/dp/0300/</guid><description>class Solution { public: int lengthOfLIS(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.size(); if(n == 1) return 1; int result = 0; // dp[i]: max length end at i vector&amp;lt;int&amp;gt; dp(n, 1); for(int i = 0; i &amp;lt; nums.size(); i++) { for(int j = 0; j &amp;lt; i; j++) { if(nums[i] &amp;gt; nums[j]) { dp[i] = max(dp[i], dp[j] + 1); } } result = max(result, dp[i]); } return result; } };</description></item><item><title>0309. Best Time to Buy and Sell Stock with Cooldown</title><link>https://jackeryli.github.io/leetcode/dp/0309/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/dp/0309/</guid><description>2-DP # class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices) { int n = prices.size(); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(n, vector&amp;lt;int&amp;gt;(4)); for(int i = 0; i &amp;lt; n; i++) { dp[i][0] = -prices[0]; } for(int i = 1; i &amp;lt; n; i++) { dp[i][0] = max(dp[i-1][0], max(dp[i-1][1] - prices[i], dp[i-1][3] - prices[i])); dp[i][1] = max(dp[i-1][3], dp[i-1][1]); dp[i][2] = dp[i-1][0] + prices[i]; dp[i][3] = dp[i-1][2]; } return max(dp[n-1][1], max(dp[n-1][2], dp[n-1][3])); } }; 1-DP # class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices) { int n = prices.</description></item><item><title>0322. Coin Change</title><link>https://jackeryli.github.io/leetcode/dp/0322/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/dp/0322/</guid><description>class Solution { public: int coinChange(vector&amp;lt;int&amp;gt;&amp;amp; coins, int amount) { // dp[j]: fewest number of coins to make amount=j // dp[j] = min(dp[j], dp[j - coins[i]] + 1) // max will be amount+1 because the min value of coin is 1 // only possible amount of coins is amount vector&amp;lt;int&amp;gt; dp(amount+1, amount+1); dp[0] = 0; for(int coin : coins) { for(int j = coin; j &amp;lt;= amount; j++) { dp[j] = min(dp[j], dp[j - coin] + 1); } } if(dp[amount] &amp;gt; amount) return -1; return dp[amount]; } };</description></item><item><title>0382.Rawsom Note</title><link>https://jackeryli.github.io/leetcode/hashmap/0383/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/hashmap/0383/</guid><description>class Solution { public: bool canConstruct(string ransomNote, string magazine) { // put magazine in hashmap, key: character, value: count // check each character in ransomNote and minus count // If unvalid situation, return false // return true if completely iterates ransomNote int magazineCharToCount[26]; memset(magazineCharToCount, 0, sizeof(magazineCharToCount)); for(char c : magazine){ magazineCharToCount[c - &amp;#39;a&amp;#39;]++; } for(char c : ransomNote){ int idx = c - &amp;#39;a&amp;#39;; if(magazineCharToCount[idx] == 0){ return false; } magazineCharToCount[idx]--; } return true; } };</description></item><item><title>0392. Is Subsequence</title><link>https://jackeryli.github.io/leetcode/two-pointer/0392/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/two-pointer/0392/</guid><description>class Solution { public: bool isSubsequence(string s, string t) { if(t.size() &amp;lt; s.size()) return false; int index1 = 0; int index2 = 0; while(index1 &amp;lt; s.size() &amp;amp;&amp;amp; index2 &amp;lt; t.size()) { if(s[index1] == t[index2]){ index1++; index2++; } else { index2++; } } return index1 == s.size(); } };</description></item><item><title>0427. Construct Quad Tree</title><link>https://jackeryli.github.io/leetcode/divide_conquer/0427/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/divide_conquer/0427/</guid><description>/* // Definition for a QuadTree node. class Node { public: bool val; bool isLeaf; Node* topLeft; Node* topRight; Node* bottomLeft; Node* bottomRight; Node() { val = false; isLeaf = false; topLeft = NULL; topRight = NULL; bottomLeft = NULL; bottomRight = NULL; } Node(bool _val, bool _isLeaf) { val = _val; isLeaf = _isLeaf; topLeft = NULL; topRight = NULL; bottomLeft = NULL; bottomRight = NULL; } Node(bool _val, bool _isLeaf, Node* _topLeft, Node* _topRight, Node* _bottomLeft, Node* _bottomRight) { val = _val; isLeaf = _isLeaf; topLeft = _topLeft; topRight = _topRight; bottomLeft = _bottomLeft; bottomRight = _bottomRight; } }; */ class Solution { public: bool isDifferent(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid, int rowStart, int rowEnd, int colStart, int colEnd) { int curr = grid[rowStart][colStart]; for(int i = rowStart; i &amp;lt;= rowEnd; i++) { for(int j = colStart; j &amp;lt;= colEnd; j++) { if(grid[i][j] !</description></item><item><title>0433. Minimum Genetic Mutation</title><link>https://jackeryli.github.io/leetcode/graph/0433/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/graph/0433/</guid><description>class Solution { public: int minMutation(string startGene, string endGene, vector&amp;lt;string&amp;gt;&amp;amp; bank) { unordered_set&amp;lt;string&amp;gt; bankSet(bank.begin(), bank.end()); unordered_set&amp;lt;string&amp;gt; seen; queue&amp;lt;string&amp;gt; que; int level = 0; que.push(startGene); seen.insert(startGene); while(!que.empty()) { int size = que.size(); // use level order traversal for(int i = 0; i &amp;lt; size; i++) { string currGene = que.front(); que.pop(); // if currGene is equal to endGene, return step if(currGene == endGene) return level; for(char c : &amp;#34;ATCG&amp;#34;) { for(int i = 0; i &amp;lt; 8; i++) { string updateGene = currGene; // only update a character updateGene[i] = c; // if we visit the gene before, we should not visit again if(bankSet.</description></item><item><title>0436. Find Right Interval</title><link>https://jackeryli.github.io/leetcode/binary-search/0436/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/0436/</guid><description>class Solution { public: int binarySearch(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; intervals, int target){ int left = 0; int right = intervals.size() - 1; int mid; // [[1,4], [2,3], [6,7]] while(left &amp;lt;= right){ mid = left + (right - left) / 2; if(target == intervals[mid][0]){ right = mid - 1; } else if (target &amp;gt; intervals[mid][0]){ left = mid + 1; } else { right = mid - 1; } } return left == intervals.size() ?</description></item><item><title>0518. Coin Change II</title><link>https://jackeryli.github.io/leetcode/dp/0518/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/dp/0518/</guid><description>class Solution { public: int change(int amount, vector&amp;lt;int&amp;gt;&amp;amp; coins) { // dp[j] = number of combination to make amount = j int dp[amount+1]; memset(dp, 0, sizeof(dp)); dp[0] = 1; for(int coin : coins) { for(int j = coin; j &amp;lt;= amount; j++) { dp[j] += dp[j - coin]; } } return dp[amount]; } };</description></item><item><title>0611. Valid Triangle Number</title><link>https://jackeryli.github.io/leetcode/binary-search/0611/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/0611/</guid><description>class Solution { public: int binarySearch(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target, int left){ // find the number that smaller than a + b // for example: 2 2 3 3 4 4 // final: r l // return (l - left) number are smaller than a + b int l = left; int r = nums.size() - 1; int mid; while(l &amp;lt;= r){ mid = l + (r - l) / 2; if(nums[mid] == target){ r = mid - 1; } else if(nums[mid] &amp;gt; target){ r = mid - 1; } else { l = mid + 1; } } return l - left; } int triangleNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.</description></item><item><title>0674.Longest Continuous Increasing Subsequence</title><link>https://jackeryli.github.io/leetcode/dp/0674/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/dp/0674/</guid><description> DP # class Solution { public: int findLengthOfLCIS(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.size(); if(n == 1) return 1; int result = 1; vector&amp;lt;int&amp;gt; dp(n, 1); for(int i = 1; i &amp;lt; n; i++) { if(nums[i] &amp;gt; nums[i-1]) { dp[i] = dp[i-1] + 1; } result = max(result, dp[i]); } return result; } }; Greedy # class Solution { public: int findLengthOfLCIS(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.size(); if(n == 1) return 1; int result = 1; int count = 1; for(int i = 1; i &amp;lt; n; i++) { if(nums[i] &amp;gt; nums[i-1]) { count++; } else { count = 1; } result = max(result, count); } return result; } };</description></item><item><title>0695. Max Area of Island</title><link>https://jackeryli.github.io/leetcode/graph/0695/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/graph/0695/</guid><description>DFS # class Solution { public: int space; int result = 0; void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid, int i, int j) { if(i &amp;lt; 0 || i &amp;gt;= grid.size() || j &amp;lt; 0 || j &amp;gt;= grid[0].size() || grid[i][j] != 1) return; grid[i][j] = 2; space++; dfs(grid, i+1, j); dfs(grid, i-1, j); dfs(grid, i, j-1); dfs(grid, i, j+1); } int maxAreaOfIsland(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) { for(int i = 0; i &amp;lt; grid.size(); i++) { for(int j = 0; j &amp;lt; grid[0].</description></item><item><title>0702. Search in a Sorted Array of Unknown Size</title><link>https://jackeryli.github.io/leetcode/binary-search/0702/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/0702/</guid><description>/** * // This is the ArrayReader&amp;#39;s API interface. * // You should not implement it, or speculate about its implementation * class ArrayReader { * public: * int get(int index); * }; */ class Solution { public: int search(const ArrayReader&amp;amp; reader, int target) { int l = 0; int r = 1; int mid; int num; // Find right most point which covered by 2^right-1 and 2^right while(reader.get(r) != INT_MAX){ l = r; r = r &amp;lt;&amp;lt; 1; } // Find right most point while(l &amp;lt;= r){ mid = l + (r - l) / 2; if(reader.</description></item><item><title>0704. Binary Search</title><link>https://jackeryli.github.io/leetcode/binary-search/0704/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/0704/</guid><description>class Solution { public: int search(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int left = 0; int right = nums.size()-1; while(left &amp;lt;= right){ int mid = left + (right - left) / 2; if(nums[mid] == target) { return mid; } else if(target &amp;gt; nums[mid]) { left = mid + 1; } else { right = mid - 1; } } return -1; } };</description></item><item><title>0714.Best Time to Buy and Sell Stock with Transaction Fee</title><link>https://jackeryli.github.io/leetcode/dp/0714/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/dp/0714/</guid><description>2-DP # class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices, int fee) { int n = prices.size(); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(n, vector&amp;lt;int&amp;gt;(2)); for(int i = 0; i &amp;lt; n; i++) { dp[i][0] = -prices[0]; } for(int i = 1; i &amp;lt; n; i++) { // buy score // i-1 day no buy and buy in i day // i-1 already buy dp[i][0] = max(dp[i-1][1] - prices[i], dp[i-1][0]); // sell score // i-1 buy and sell at i day // i-1 no buy dp[i][1] = max(dp[i-1][0] + prices[i] - fee, dp[i-1][1]); } return dp[n-1][1]; } }; 1-DP # class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices, int fee) { int n = prices.</description></item><item><title>0718.Maximum Length of Repeated Subarray</title><link>https://jackeryli.github.io/leetcode/dp/0718/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/dp/0718/</guid><description>2-DP # class Solution { public: int findLength(vector&amp;lt;int&amp;gt;&amp;amp; nums1, vector&amp;lt;int&amp;gt;&amp;amp; nums2) { int m = nums1.size(); int n = nums2.size(); int result = 0; // dp[i][j]: max length when (i,j) vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(m+1, vector&amp;lt;int&amp;gt;(n+1)); for(int i = 1; i &amp;lt;= m; i++) { for(int j = 1; j &amp;lt;= n; j++) { if(nums1[i-1] == nums2[j-1]) { // (i,j) depends on (i-1, j-1) is valid dp[i][j] = dp[i-1][j-1] + 1; } result = max(result, dp[i][j]); } } return result; } }; 1-DP # class Solution { public: int findLength(vector&amp;lt;int&amp;gt;&amp;amp; nums1, vector&amp;lt;int&amp;gt;&amp;amp; nums2) { int m = nums1.</description></item><item><title>0744. Find Smallest Letter Greater Than Target</title><link>https://jackeryli.github.io/leetcode/binary-search/0744/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/0744/</guid><description>class Solution { public: char nextGreatestLetter(vector&amp;lt;char&amp;gt;&amp;amp; letters, char target) { int left = 0; int right = letters.size() - 1; int mid; while(left &amp;lt;= right){ mid = left + (right - left) / 2; if(letters[mid] &amp;lt;= target){ left = mid + 1; } else { right = mid - 1; } } return left == letters.size() ? letters[0] : letters[left]; } };</description></item><item><title>0772. Basic Calculator III</title><link>https://jackeryli.github.io/leetcode/recursion/772/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/recursion/772/</guid><description>class Solution { public: int getNumber(string&amp;amp; expression, int&amp;amp; pos){ int result = 0; while(isdigit(expression[pos]) &amp;amp;&amp;amp; pos &amp;lt; expression.size()){ result = result * 10 + (expression[pos] - &amp;#39;0&amp;#39;); pos++; } return result; } int parseFactor(string&amp;amp; expression, int&amp;amp; pos){ if(expression[pos] == &amp;#39;(&amp;#39;){ pos++; int result = parseExpression(expression, pos); pos++; return result; } return getNumber(expression, pos); } int parseTerm(string&amp;amp; expression, int&amp;amp; pos){ int result = parseFactor(expression, pos); while(pos &amp;lt; expression.size() &amp;amp;&amp;amp; (expression[pos] == &amp;#39;*&amp;#39; || expression[pos] == &amp;#39;/&amp;#39;)){ char op = expression[pos++]; int nextFactor = parseFactor(expression, pos); if(op == &amp;#39;*&amp;#39;){ result *= nextFactor; } else if(op == &amp;#39;/&amp;#39;){ result /= nextFactor; } } return result; } int parseExpression(string&amp;amp; expression, int&amp;amp; pos){ int result = parseTerm(expression, pos); while(pos &amp;lt; expression.</description></item><item><title>0797.All Paths From Source to Target</title><link>https://jackeryli.github.io/leetcode/graph/0797/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/graph/0797/</guid><description>class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result; vector&amp;lt;int&amp;gt; path; void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; graph, int current) { if(current == graph.size() - 1) { result.emplace_back(path); return; } for(int i = 0; i &amp;lt; graph[current].size(); i++) { path.emplace_back(graph[current][i]); dfs(graph, graph[current][i]); path.pop_back(); } } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; allPathsSourceTarget(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; graph) { path.emplace_back(0); dfs(graph, 0); return result; } };</description></item><item><title>0852. Peak Index in a Mountatin Array</title><link>https://jackeryli.github.io/leetcode/binary-search/0852/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/0852/</guid><description>class Solution { public: int peakIndexInMountainArray(vector&amp;lt;int&amp;gt;&amp;amp; arr) { int l = 0; int r = arr.size() - 1; int mid; // Use l &amp;lt; r rather than l &amp;lt;= r because I want to stop at l == r // Seems like no effect in this question while(l &amp;lt; r){ mid = l + (r - l) / 2; // Current is peak if left and right are smaller than mid if(arr[mid-1] &amp;lt; arr[mid] &amp;amp;&amp;amp; arr[mid] &amp;gt; arr[mid+1]){ return mid; } // Only move to mid to avoid illegal condition if(arr[mid-1] &amp;lt; arr[mid]){ l = mid; } else { r = mid; } } return l; } };</description></item><item><title>0875. Koko Eating Bananas</title><link>https://jackeryli.github.io/leetcode/binary-search/0875/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/0875/</guid><description>If we set l &amp;lt; r and r = m
state n-1 3 4 5 6 7 l r m state n 3 4 5 6 7 l r class Solution { public: int minEatingSpeed(vector&amp;lt;int&amp;gt;&amp;amp; piles, int h) { int l = 1; int r = *max_element(piles.begin(), piles.end()); int m; long long hours; while(l &amp;lt;= r){ m = l + (r - l) / 2; hours = 0; for(int&amp;amp; pile : piles){ hours += ((pile / m) + (pile % m !</description></item><item><title>0909. Snakes and Ladders</title><link>https://jackeryli.github.io/leetcode/graph/0909/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/graph/0909/</guid><description>BFS # class Solution { public: int snakesAndLadders(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; board) { int n = board.size(); // Create a mapping between pos and {row,col} vector&amp;lt;pair&amp;lt;int,int&amp;gt;&amp;gt; posMap(n * n + 1); int pdx = 1; int revFlag = 0; // col is reverse for(int row = n - 1; row &amp;gt;= 0; row--) { for(int col = 0; col &amp;lt; n; col++) { posMap[pdx++] = (revFlag == 0) ? make_pair(row, col) : make_pair(row, n - 1 - col); } revFlag = !</description></item><item><title>0977. Squares of a Sorted Array</title><link>https://jackeryli.github.io/leetcode/two-pointer/0977/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/two-pointer/0977/</guid><description> Method 1 # Time Complexity: O(n) Space Complexity: O(n) class Solution { public: vector&amp;lt;int&amp;gt; sortedSquares(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int l = 0; int r = nums.size() - 1; int index = nums.size() - 1; vector&amp;lt;int&amp;gt; result(nums.size(), 1); while(l &amp;lt;= r) { int leftpower = nums[l] * nums[l]; int rightpower = nums[r] * nums[r]; if(leftpower &amp;gt; rightpower) { result[index--] = leftpower; l++; } else { result[index--] = rightpower; r--; } } return result; } };</description></item><item><title>1011. Capacity To Ship Packages Within D Days</title><link>https://jackeryli.github.io/leetcode/binary-search/1011/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/1011/</guid><description>class Solution { public: int countShipDays(vector&amp;lt;int&amp;gt;&amp;amp; weights, int capacity){ int usedDays = 1; int current = capacity; for(int&amp;amp; weight : weights){ if(weight &amp;gt; capacity){ return INT_MAX; } if(current &amp;gt;= weight){ current -= weight; } else { usedDays++; current = capacity - weight; } } return usedDays; } int shipWithinDays(vector&amp;lt;int&amp;gt;&amp;amp; weights, int days) { int l = 0; int r = *max_element(weights.begin(), weights.end()); int usedDays; int mid; while(l &amp;lt; r){ usedDays = countShipDays(weights, r); if(usedDays &amp;lt;= days) break; l = r; r = r &amp;lt;&amp;lt; 1; } while(l &amp;lt;= r){ mid = l + (r - l) / 2; usedDays = countShipDays(weights, mid); if(usedDays == days){ r = mid-1; } else if(usedDays &amp;gt; days){ l = mid + 1; } else { r = mid-1; } } return l; } };</description></item><item><title>1035.Uncrossed Lines</title><link>https://jackeryli.github.io/leetcode/dp/1035/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/dp/1035/</guid><description>class Solution { public: int maxUncrossedLines(vector&amp;lt;int&amp;gt;&amp;amp; nums1, vector&amp;lt;int&amp;gt;&amp;amp; nums2) { int m = nums1.size(); int n = nums2.size(); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(m+1, vector&amp;lt;int&amp;gt;(n+1)); for(int i = 1; i &amp;lt;= m; i++) { for(int j = 1; j &amp;lt;= n; j++) { if(nums1[i-1] == nums2[j-1]) { dp[i][j] = dp[i-1][j-1] + 1; } else { dp[i][j] = max(dp[i-1][j], dp[i][j-1]); } } } return dp[m][n]; } };</description></item><item><title>1143.Longest Common Subsequence</title><link>https://jackeryli.github.io/leetcode/dp/1143/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/dp/1143/</guid><description>class Solution { public: int maxUncrossedLines(vector&amp;lt;int&amp;gt;&amp;amp; nums1, vector&amp;lt;int&amp;gt;&amp;amp; nums2) { int m = nums1.size(); int n = nums2.size(); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(m+1, vector&amp;lt;int&amp;gt;(n+1)); for(int i = 1; i &amp;lt;= m; i++) { for(int j = 1; j &amp;lt;= n; j++) { if(nums1[i-1] == nums2[j-1]) { dp[i][j] = dp[i-1][j-1] + 1; } else { dp[i][j] = max(dp[i-1][j], dp[i][j-1]); } } } return dp[m][n]; } };</description></item><item><title>1283. Find the Smallest Divisor Given a Threshold</title><link>https://jackeryli.github.io/leetcode/binary-search/1283/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/1283/</guid><description>class Solution { public: int calDivisionSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int divisor){ int result = 0; for(int&amp;amp; num : nums){ result += (num / divisor) + (num % divisor != 0); } return result; } int smallestDivisor(vector&amp;lt;int&amp;gt;&amp;amp; nums, int threshold) { int l = 1; int r = *max_element(nums.begin(), nums.end()); int m; int pivot; while(l &amp;lt;= r){ m = l + (r - l) / 2; pivot = calDivisionSum(nums, m); if(pivot == threshold){ r = m - 1; } else if(pivot &amp;gt; threshold){ l = m + 1; } else { r = m - 1; } } return l; } };</description></item><item><title>130.Surrounded Regions</title><link>https://jackeryli.github.io/leetcode/graph/0130/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/graph/0130/</guid><description> DFS # class Solution { public: void dfs(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board, int i, int j, char c) { if(i &amp;lt; 0 || i &amp;gt;= board.size() || j &amp;lt; 0 || j &amp;gt;= board[0].size() || board[i][j] != &amp;#39;O&amp;#39;) return; board[i][j] = c; dfs(board, i-1, j, c); dfs(board, i+1, j, c); dfs(board, i, j-1, c); dfs(board, i, j+1, c); } void solve(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board) { int m = board.size(); int n = board[0].size(); for(int i = 0; i &amp;lt; m; i++) { if(board[i][0] == &amp;#39;O&amp;#39;) dfs(board, i , 0, &amp;#39;A&amp;#39;); if(board[i][n-1] == &amp;#39;O&amp;#39;) dfs(board, i, n-1, &amp;#39;A&amp;#39;); } for(int j = 0; j &amp;lt; n; j++) { if(board[0][j] == &amp;#39;O&amp;#39;) dfs(board, 0, j, &amp;#39;A&amp;#39;); if(board[m-1][j] == &amp;#39;O&amp;#39;) dfs(board, m-1, j, &amp;#39;A&amp;#39;); } for(int i = 0; i &amp;lt; m; i++) { for(int j = 0; j &amp;lt; n; j++) { if(board[i][j] == &amp;#39;O&amp;#39;) { board[i][j] = &amp;#39;X&amp;#39;; } if(board[i][j] == &amp;#39;A&amp;#39;) { board[i][j] = &amp;#39;O&amp;#39;; } } } } };</description></item><item><title>1351. Count Negative Numbers in a Sorted Matrix</title><link>https://jackeryli.github.io/leetcode/binary-search/1351/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/1351/</guid><description>class Solution { public: int binarySearch(vector&amp;lt;int&amp;gt;&amp;amp; arr){ int left = 0; int right = arr.size() - 1; int mid; while(left &amp;lt;= right){ mid = left + (right - left) / 2; if(arr[mid] &amp;gt;= 0){ left = mid + 1; } else { right = mid - 1; } } return arr.size() - left; } int countNegatives(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) { int m = grid.size(); int n = grid[0].size(); int ans = 0; for(auto&amp;amp; arr: grid){ ans += binarySearch(arr); } return ans; } }; class Solution { public: int countNegatives(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) { int m = grid.</description></item><item><title>1870. Minimum Speed to Arrive on Time</title><link>https://jackeryli.github.io/leetcode/binary-search/1870/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/1870/</guid><description>class Solution { public: double calHourSpent(vector&amp;lt;int&amp;gt;&amp;amp; dist, int speed) { int n = dist.size() - 1; double hourSpent = 0; for(int i = 0; i &amp;lt; n; i++) { hourSpent += (dist[i] / speed + (dist[i] % speed != 0)); } return hourSpent + (double) dist[n] / speed; } int minSpeedOnTime(vector&amp;lt;int&amp;gt;&amp;amp; dist, double hour) { if(hour &amp;lt;= dist.size() - 1){ return -1; } int l = 1; int r = 10e7; // two digit decimal after 10e5 int m; double pivot; while(l &amp;lt; r) { m = l + (r - l) / 2; pivot = calHourSpent(dist, m); if(pivot == hour){ r = m; } else if (pivot &amp;gt; hour){ l = m + 1; } else { r = m; } } return r; } };</description></item><item><title>2300. Successful Pairs of Spells and Potions</title><link>https://jackeryli.github.io/leetcode/binary-search/2300/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/2300/</guid><description>class Solution { public: int binarySearch(vector&amp;lt;int&amp;gt;&amp;amp; potions, long long target) { int n = potions.size(); int l = 0; int r = n - 1; while(l &amp;lt;= r) { long long m = l + (r - l) / 2; if(potions[m] == target) { r = m - 1; } else if (potions[m] &amp;gt; target) { r = m - 1; } else { l = m + 1; } } // 1 2 3 4 5 // lr // r l return n - l; } vector&amp;lt;int&amp;gt; successfulPairs(vector&amp;lt;int&amp;gt;&amp;amp; spells, vector&amp;lt;int&amp;gt;&amp;amp; potions, long long success) { vector&amp;lt;int&amp;gt; result; sort(potions.</description></item><item><title>2966. Divide Array Into Arrays With Max Difference</title><link>https://jackeryli.github.io/leetcode/array/2966/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/array/2966/</guid><description>class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; divideArray(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { // sort array from small to large // divide into 3 part // iterate and check if part[0] - part[2] is bigger than k // if yes, return empty vector // if no, assign part[0], part[1], part[2] to one vector sort(nums.begin(), nums.end()); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans = {nums.size()/3, vector&amp;lt;int&amp;gt;{}}; for(int i = 0; i &amp;lt; nums.size(); i+=3){ if((nums[i+2] - nums[i]) &amp;lt;= k) { ans[i/3] = {nums[i], nums[i+1], nums[i+2]}; } else { return vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;{}; } } return ans; } };</description></item><item><title>58. Length of Last Word</title><link>https://jackeryli.github.io/leetcode/string/0058/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/string/0058/</guid><description>class Solution { public: int lengthOfLastWord(string s) { int n = s.size(); int l = n-1; int r = l; while(r &amp;gt;= 0 &amp;amp;&amp;amp; s[r] == &amp;#39; &amp;#39;) r--; l = r; while(l &amp;gt;= 0 &amp;amp;&amp;amp; s[l] != &amp;#39; &amp;#39;) l--; return r - l; } };</description></item><item><title>647. Palindromic Substrings</title><link>https://jackeryli.github.io/leetcode/two-pointer/0647/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/two-pointer/0647/</guid><description>class Solution { public: int findPalindrome(string s, int l, int r) { int count = 0; while(l &amp;gt;= 0 &amp;amp;&amp;amp; r &amp;lt; s.size() &amp;amp;&amp;amp; s[l] == s[r]) { count++; l--; r++; } return count; } int countSubstrings(string s) { int result = 0; for(int i = 0; i &amp;lt; s.size(); i++) { result += findPalindrome(s, i, i); result += findPalindrome(s, i, i+1); } return result; } };</description></item><item><title>739. Daily Temperatures</title><link>https://jackeryli.github.io/leetcode/stack/0739/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/stack/0739/</guid><description>class Solution { public: vector&amp;lt;int&amp;gt; dailyTemperatures(vector&amp;lt;int&amp;gt;&amp;amp; temperatures) { stack&amp;lt;int&amp;gt; sta; vector&amp;lt;int&amp;gt; result(temperatures.size(), 0); for(int i = 0; i &amp;lt; temperatures.size(); i++){ while(!sta.empty() &amp;amp;&amp;amp; temperatures[sta.top()] &amp;lt; temperatures[i]){ result[sta.top()] = i - sta.top(); sta.pop(); } sta.push(i); } return result; } };</description></item><item><title>How TCP establish and close connection?</title><link>https://jackeryli.github.io/network/tcp-connection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/network/tcp-connection/</guid><description>TCP establish connection # sequenceDiagram participant Client participant Server Note over Client, Server: CLOSED Note right of Server: LISTEN Client->>Server: SYN seq=100 Note left of Client: SYN-SENT Server->>Client: SYN ACK seq=300 ack=101 Note right of Server: SYN_RCVD Note left of Client: ESTABLISHED Client->>Server: ACK seq=101 ack=301 Note right of Server: ESTABLISHED TCP close connection # sequenceDiagram participant Client participant Server Note left of Client: ESTABLISHED Note right of Server: ESTABLISHED Client->>Server: FIN seq=300 Note left of Client: FIN_WAIT Note right of Server: CLOSE_WAIT Server->>Client: ACK ack=301 Note right of Server: LAST_ACK Note left of Client: FIN_WAIT2 Server->>Client: FIN seq=500 ack=301 Note left of Client: TIME_WAIT Client->>Server: ACK seq=301 ack=501 Note right of Server: CLOSED Note left of Client: CLOSED Why TCP has TIME_WAIT?</description></item></channel></rss>