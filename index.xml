<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Welcome! on</title><link>https://jackeryli.github.io/</link><description>Recent content in Welcome! on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://jackeryli.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Debug xv6 with gdb</title><link>https://jackeryli.github.io/xv6/xv6-gdb/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/xv6/xv6-gdb/</guid><description> Preparation # # Run xv6 with gdb make qemu-gdb # Change to another terminal and connect to xv6-gdb gdb-multiarch -x .gdbinit Basic Command # # Set break point b syscall b module.c:67 # Continue c # Step into step # Step over next # List value of register info register # List args info args # See who call it backtrace # Set value set xxx # Watching variable watch a</description></item><item><title>Add system call to linux</title><link>https://jackeryli.github.io/linux-kernel/add_system_call/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/linux-kernel/add_system_call/</guid><description>Open include/uapi/asm-generic/unistd.h
#define __NR_get_cpuid 452 __SYSCALL(__NR_get_cpuid, sys_get_cpuid) #undef __NR_syscalls #define __NR_syscalls 453 Open linux/kernel/sys.c
SYSCALL_DEFINE0(get_cpuid) { return raw_smp_processor_id(); }</description></item><item><title>Write your first kernel module</title><link>https://jackeryli.github.io/linux-kernel/write_first_kernel_module/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/linux-kernel/write_first_kernel_module/</guid><description>Building Kernel Module # Create rootkit.c
#include &amp;lt;linux/module.h&amp;gt; #include &amp;lt;linux/syscalls.h&amp;gt; #include &amp;lt;linux/types.h&amp;gt; #define OURMODNAME &amp;#34;rootkit&amp;#34; MODULE_AUTHOR(&amp;#34;FOOBAR&amp;#34;); MODULE_DESCRIPTION(&amp;#34;FOOBAR&amp;#34;); MODULE_LICENSE(&amp;#34;Dual MIT/GPL&amp;#34;); MODULE_VERSION(&amp;#34;0.1&amp;#34;); static int __init rootkit_init(void) { printk(KERN_INFO &amp;#34;hello, world!\n&amp;#34;); return 0; } static void __exit rootkit_exit(void) { printk(KERN_INFO &amp;#34;Goodbye, world!\n&amp;#34;); } module_init(rootkit_init); module_exit(rootkit_exit); Create Makefile. Remember to update KDIR with your linux source code dir.
obj-m = rootkit.o PWD := $(shell pwd) EXTRA_CFLAGS = -Wall -g CROSS = aarch64-linux-gnu- KDIR = /home/jack/Desktop/linux/ all: $(MAKE) ARCH=arm64 CROSS_COMPILE=$(CROSS) -C $(KDIR) M=$(PWD) modules clean: $(MAKE) -C $(KDIR) M=$(PWD) clean Compile kernel module</description></item><item><title>Implement isatty on xv6</title><link>https://jackeryli.github.io/xv6/xv6-isatty/</link><pubDate>Wed, 24 Jan 2024 12:16:46 +0800</pubDate><guid>https://jackeryli.github.io/xv6/xv6-isatty/</guid><description>I desire to fix the bug that it prints a $ when processing shell commands from a file.</description></item><item><title>Implement xargs on xv6</title><link>https://jackeryli.github.io/xv6/xv6-xargs/</link><pubDate>Tue, 23 Jan 2024 12:16:46 +0800</pubDate><guid>https://jackeryli.github.io/xv6/xv6-xargs/</guid><description>Implement xargs on xv6</description></item><item><title>Implement pwd on xv6</title><link>https://jackeryli.github.io/xv6/xv6-pwd/</link><pubDate>Mon, 22 Jan 2024 12:16:46 +0800</pubDate><guid>https://jackeryli.github.io/xv6/xv6-pwd/</guid><description>pwd will print working directory. Here we will implement pwd on xv6.</description></item><item><title>xv6 lab trap</title><link>https://jackeryli.github.io/xv6/xv6-lab-trap/</link><pubDate>Wed, 11 Oct 2023 12:16:46 +0800</pubDate><guid>https://jackeryli.github.io/xv6/xv6-lab-trap/</guid><description>Implement MIT xv6 lab:trap</description></item><item><title>1011. Capacity To Ship Packages Within D Days</title><link>https://jackeryli.github.io/leetcode/binary-search/1011/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/1011/</guid><description>class Solution { public: int countShipDays(vector&amp;lt;int&amp;gt;&amp;amp; weights, int capacity){ int usedDays = 1; int current = capacity; for(int&amp;amp; weight : weights){ if(weight &amp;gt; capacity){ return INT_MAX; } if(current &amp;gt;= weight){ current -= weight; } else { usedDays++; current = capacity - weight; } } return usedDays; } int shipWithinDays(vector&amp;lt;int&amp;gt;&amp;amp; weights, int days) { int l = 0; int r = *max_element(weights.begin(), weights.end()); int usedDays; int mid; while(l &amp;lt; r){ usedDays = countShipDays(weights, r); if(usedDays &amp;lt;= days) break; l = r; r = r &amp;lt;&amp;lt; 1; } while(l &amp;lt;= r){ mid = l + (r - l) / 2; usedDays = countShipDays(weights, mid); if(usedDays == days){ r = mid-1; } else if(usedDays &amp;gt; days){ l = mid + 1; } else { r = mid-1; } } return l; } };</description></item><item><title>125. Valid Palindrome</title><link>https://jackeryli.github.io/leetcode/two-pointer/125/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/two-pointer/125/</guid><description>class Solution { public: bool isPalindrome(string s) { // two point left and right // if meet not alpha or number, skip // compare s[left] and s[right] // if equal, continue // if not equal return false // if left == right, return true int left = 0, right = s.size() - 1; for(; left &amp;lt; right; left++, right--) { while(left &amp;lt; right &amp;amp;&amp;amp; !isalnum(s[left])) { left++; } while(left &amp;lt; right &amp;amp;&amp;amp; !</description></item><item><title>1283. Find the Smallest Divisor Given a Threshold</title><link>https://jackeryli.github.io/leetcode/binary-search/1283/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/1283/</guid><description>class Solution { public: int calDivisionSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int divisor){ int result = 0; for(int&amp;amp; num : nums){ result += (num / divisor) + (num % divisor != 0); } return result; } int smallestDivisor(vector&amp;lt;int&amp;gt;&amp;amp; nums, int threshold) { int l = 1; int r = *max_element(nums.begin(), nums.end()); int m; int pivot; while(l &amp;lt;= r){ m = l + (r - l) / 2; pivot = calDivisionSum(nums, m); if(pivot == threshold){ r = m - 1; } else if(pivot &amp;gt; threshold){ l = m + 1; } else { r = m - 1; } } return l; } };</description></item><item><title>1351. Count Negative Numbers in a Sorted Matrix</title><link>https://jackeryli.github.io/leetcode/binary-search/1351/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/1351/</guid><description>class Solution { public: int binarySearch(vector&amp;lt;int&amp;gt;&amp;amp; arr){ int left = 0; int right = arr.size() - 1; int mid; while(left &amp;lt;= right){ mid = left + (right - left) / 2; if(arr[mid] &amp;gt;= 0){ left = mid + 1; } else { right = mid - 1; } } return arr.size() - left; } int countNegatives(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) { int m = grid.size(); int n = grid[0].size(); int ans = 0; for(auto&amp;amp; arr: grid){ ans += binarySearch(arr); } return ans; } }; class Solution { public: int countNegatives(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) { int m = grid.</description></item><item><title>141. Linked List Cycle</title><link>https://jackeryli.github.io/leetcode/two-pointer/141/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/two-pointer/141/</guid><description>/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: bool hasCycle(ListNode *head) { ListNode* fast = head; ListNode* slow = head; while(fast != nullptr &amp;amp;&amp;amp; fast-&amp;gt;next != nullptr){ fast = fast-&amp;gt;next-&amp;gt;next; slow = slow-&amp;gt;next; if(fast == slow) { return true; } } return false; } };</description></item><item><title>142. Linked List Cycle II</title><link>https://jackeryli.github.io/leetcode/two-pointer/142/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/two-pointer/142/</guid><description>/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *detectCycle(ListNode *head) { // fast move 2 pos // slow move 1 pos // pos count: 2(x+y) = x + y + n(y + z) // n = 1, x = z ListNode* fast = head; ListNode* slow = head; while(fast !</description></item><item><title>15. Three Sum</title><link>https://jackeryli.github.io/leetcode/two-pointer/15/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/two-pointer/15/</guid><description>class Solution { public: void twoSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target, int left, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; result) { int l = left; int r = nums.size() - 1; while(l &amp;lt; r) { int sum = nums[l] + nums[r]; if(target &amp;gt; sum) { l++; } else if (target &amp;lt; sum) { r--; } else { result.push_back({-target, nums[l], nums[r]}); l++; r--; while(nums[l] == nums[l-1] &amp;amp;&amp;amp; l &amp;lt; r) l++; while(nums[r] == nums[r+1] &amp;amp;&amp;amp; l &amp;lt; r) r--; } } } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; threeSum(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.</description></item><item><title>1870. Minimum Speed to Arrive on Time</title><link>https://jackeryli.github.io/leetcode/binary-search/1870/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/1870/</guid><description>class Solution { public: double calHourSpent(vector&amp;lt;int&amp;gt;&amp;amp; dist, int speed) { int n = dist.size() - 1; double hourSpent = 0; for(int i = 0; i &amp;lt; n; i++) { hourSpent += (dist[i] / speed + (dist[i] % speed != 0)); } return hourSpent + (double) dist[n] / speed; } int minSpeedOnTime(vector&amp;lt;int&amp;gt;&amp;amp; dist, double hour) { if(hour &amp;lt;= dist.size() - 1){ return -1; } int l = 1; int r = 10e7; // two digit decimal after 10e5 int m; double pivot; while(l &amp;lt; r) { m = l + (r - l) / 2; pivot = calHourSpent(dist, m); if(pivot == hour){ r = m; } else if (pivot &amp;gt; hour){ l = m + 1; } else { r = m; } } return r; } };</description></item><item><title>209. Minimum Size Subarray Sum</title><link>https://jackeryli.github.io/leetcode/sliding-window/209/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/sliding-window/209/</guid><description>class Solution { public: int minSubArrayLen(int target, vector&amp;lt;int&amp;gt;&amp;amp; nums) { int left = 0; int sum = 0; int ans = INT_MAX; for(int right = 0; right &amp;lt; nums.size(); right++) { sum += nums[right]; while(sum &amp;gt;= target) { ans = min(ans, right - left + 1); sum -= nums[left++]; } } return ans == INT_MAX ? 0 : ans; } };</description></item><item><title>227. Basic Calculator II</title><link>https://jackeryli.github.io/leetcode/recursion/227/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/recursion/227/</guid><description>class Solution { public: int getNumber(string&amp;amp; expression, int&amp;amp; pos){ int result = 0; while((isdigit(expression[pos]) || expression[pos] == &amp;#39; &amp;#39;) &amp;amp;&amp;amp; pos &amp;lt; expression.size()){ if(isdigit(expression[pos])){ result = result * 10 + (expression[pos] - &amp;#39;0&amp;#39;); } pos++; } return result; } int parseTerm(string&amp;amp; expression, int&amp;amp; pos){ int result = getNumber(expression, pos); while(pos &amp;lt; expression.size() &amp;amp;&amp;amp; (expression[pos] == &amp;#39;*&amp;#39; || expression[pos] == &amp;#39;/&amp;#39;)){ char op = expression[pos++]; int nextNumber = getNumber(expression, pos); if(op == &amp;#39;*&amp;#39;){ result *= nextNumber; } else if(op == &amp;#39;/&amp;#39;){ result /= nextNumber; } } return result; } int parseExpression(string&amp;amp; expression, int&amp;amp; pos){ int result = parseTerm(expression, pos); while(pos &amp;lt; expression.</description></item><item><title>2300. Successful Pairs of Spells and Potions</title><link>https://jackeryli.github.io/leetcode/binary-search/2300/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/2300/</guid><description>class Solution { public: int binarySearch(vector&amp;lt;int&amp;gt;&amp;amp; potions, long long target) { int n = potions.size(); int l = 0; int r = n - 1; while(l &amp;lt;= r) { long long m = l + (r - l) / 2; if(potions[m] == target) { r = m - 1; } else if (potions[m] &amp;gt; target) { r = m - 1; } else { l = m + 1; } } // 1 2 3 4 5 // lr // r l return n - l; } vector&amp;lt;int&amp;gt; successfulPairs(vector&amp;lt;int&amp;gt;&amp;amp; spells, vector&amp;lt;int&amp;gt;&amp;amp; potions, long long success) { vector&amp;lt;int&amp;gt; result; sort(potions.</description></item><item><title>24. Swap nodes by pairs</title><link>https://jackeryli.github.io/leetcode/linkedlist/24/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/linkedlist/24/</guid><description>/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* swapPairs(ListNode* head) { // 1 2 3 4 // s f ListNode* dummy = new ListNode(); dummy-&amp;gt;next = head; ListNode* fast = dummy; ListNode* slow = dummy; ListNode* before = dummy; while(fast-&amp;gt;next !</description></item><item><title>26. Remove Duplicates from Sorted Array</title><link>https://jackeryli.github.io/leetcode/two-pointer/26/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/two-pointer/26/</guid><description>class Solution { public: int removeDuplicates(vector&amp;lt;int&amp;gt;&amp;amp; nums) { // fast and slow start from 0 // fast go first // if nums[fast] != nums[slow], slow++ and swap // return slow int fast = 1, slow = 0; // 0 1 0 1 1 2 2 3 3 4 // 0 1 2 1 1 0 2 3 3 4 // s f for(; fast &amp;lt; nums.size(); fast++) { if(nums[fast] != nums[slow]) { slow++; nums[slow] = nums[fast]; } } return slow + 1; } };</description></item><item><title>268. Missing Number</title><link>https://jackeryli.github.io/leetcode/recursion/268/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/recursion/268/</guid><description>class Solution { public: int missingNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int size = nums.size(); int expect_sum = size * (size+1) / 2; int actual_sum = 0; for(int i = 0; i &amp;lt; size; i++) { actual_sum += nums[i]; } return expect_sum - actual_sum; } };</description></item><item><title>285. Inorder Successor in BST</title><link>https://jackeryli.github.io/leetcode/recursion/285/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/recursion/285/</guid><description>class Solution { public: bool isTarget = false; TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) { if(root == nullptr) return nullptr; TreeNode* left = inorderSuccessor(root-&amp;gt;left, p); if(left != nullptr) return left; if(isTarget){ return root; } if(p-&amp;gt;val == root-&amp;gt;val){ isTarget = true; } TreeNode* right = inorderSuccessor(root-&amp;gt;right, p); if(right != nullptr) return right; return nullptr; } }; class Solution { public: TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) { TreeNode* sucessor = nullptr; while(root != nullptr){ if(root-&amp;gt;val &amp;lt;= p-&amp;gt;val){ root = root-&amp;gt;right; } else { sucessor = root; root = root-&amp;gt;left; } } return sucessor; } };</description></item><item><title>2966. Divide Array Into Arrays With Max Difference</title><link>https://jackeryli.github.io/leetcode/array/2966/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/array/2966/</guid><description>class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; divideArray(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { // sort array from small to large // divide into 3 part // iterate and check if part[0] - part[2] is bigger than k // if yes, return empty vector // if no, assign part[0], part[1], part[2] to one vector sort(nums.begin(), nums.end()); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans = {nums.size()/3, vector&amp;lt;int&amp;gt;{}}; for(int i = 0; i &amp;lt; nums.size(); i+=3){ if((nums[i+2] - nums[i]) &amp;lt;= k) { ans[i/3] = {nums[i], nums[i+1], nums[i+2]}; } else { return vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;{}; } } return ans; } };</description></item><item><title>34. Find First and Last Position of Element in Sorted Array</title><link>https://jackeryli.github.io/leetcode/binary-search/34/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/34/</guid><description>class Solution { public: int binarySearch(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target, bool isSame){ int left = 0; int right = nums.size() - 1; int mid; int index = -1; while(left &amp;lt;= right){ mid = left + (right - left) / 2; if(nums[mid] == target){ index = mid; if(isSame) right = mid - 1; else left = mid + 1; } else if (nums[mid] &amp;gt; target){ right = mid - 1; } else { left = mid + 1; } } return index; } vector&amp;lt;int&amp;gt; searchRange(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int left = binarySearch(nums, target, true); if(left == -1) return {-1, -1}; int right = binarySearch(nums, target, false); return {left, right}; } };</description></item><item><title>35. Search Insert Position</title><link>https://jackeryli.github.io/leetcode/binary-search/35/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/35/</guid><description>class Solution { public: int searchInsert(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int left = 0; int right = nums.size() - 1; while(left &amp;lt;= right){ int mid = left + (right - left) / 2; if(target == nums[mid]){ return mid; } else if (target &amp;gt; nums[mid]){ left = mid + 1; } else { right = mid - 1; } } return left; } };</description></item><item><title>436. Find Right Interval</title><link>https://jackeryli.github.io/leetcode/binary-search/436/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/436/</guid><description>class Solution { public: int binarySearch(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; intervals, int target){ int left = 0; int right = intervals.size() - 1; int mid; // [[1,4], [2,3], [6,7]] while(left &amp;lt;= right){ mid = left + (right - left) / 2; if(target == intervals[mid][0]){ right = mid - 1; } else if (target &amp;gt; intervals[mid][0]){ left = mid + 1; } else { right = mid - 1; } } return left == intervals.size() ?</description></item><item><title>611. Valid Triangle Number</title><link>https://jackeryli.github.io/leetcode/binary-search/611/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/611/</guid><description>class Solution { public: int binarySearch(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target, int left){ // find the number that smaller than a + b // for example: 2 2 3 3 4 4 // final: r l // return (l - left) number are smaller than a + b int l = left; int r = nums.size() - 1; int mid; while(l &amp;lt;= r){ mid = l + (r - l) / 2; if(nums[mid] == target){ r = mid - 1; } else if(nums[mid] &amp;gt; target){ r = mid - 1; } else { l = mid + 1; } } return l - left; } int triangleNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.</description></item><item><title>702. Search in a Sorted Array of Unknown Size</title><link>https://jackeryli.github.io/leetcode/binary-search/702/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/702/</guid><description>/** * // This is the ArrayReader&amp;#39;s API interface. * // You should not implement it, or speculate about its implementation * class ArrayReader { * public: * int get(int index); * }; */ class Solution { public: int search(const ArrayReader&amp;amp; reader, int target) { int l = 0; int r = 1; int mid; int num; // Find right most point which covered by 2^right-1 and 2^right while(reader.get(r) != INT_MAX){ l = r; r = r &amp;lt;&amp;lt; 1; } // Find right most point while(l &amp;lt;= r){ mid = l + (r - l) / 2; if(reader.</description></item><item><title>704. Binary Search</title><link>https://jackeryli.github.io/leetcode/binary-search/704/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/704/</guid><description>class Solution { public: int search(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int left = 0; int right = nums.size()-1; while(left &amp;lt;= right){ int mid = left + (right - left) / 2; if(nums[mid] == target) { return mid; } else if(target &amp;gt; nums[mid]) { left = mid + 1; } else { right = mid - 1; } } return -1; } };</description></item><item><title>74. Search a 2D Matrix</title><link>https://jackeryli.github.io/leetcode/binary-search/74/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/74/</guid><description>class Solution { public: bool searchMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix, int target) { int m = matrix.size(); int n = matrix[0].size(); int left = 0; int right = m*n - 1; int mid; while(left &amp;lt;= right){ mid = left + (right - left) / 2; int row = mid / n; int col = mid % n; if(matrix[row][col] == target) return true; else if(target &amp;gt; matrix[row][col]){ left = mid + 1; } else { right = mid - 1; } } return false; } };</description></item><item><title>744. Find Smallest Letter Greater Than Target</title><link>https://jackeryli.github.io/leetcode/binary-search/744/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/744/</guid><description>class Solution { public: char nextGreatestLetter(vector&amp;lt;char&amp;gt;&amp;amp; letters, char target) { int left = 0; int right = letters.size() - 1; int mid; while(left &amp;lt;= right){ mid = left + (right - left) / 2; if(letters[mid] &amp;lt;= target){ left = mid + 1; } else { right = mid - 1; } } return left == letters.size() ? letters[0] : letters[left]; } };</description></item><item><title>772. Basic Calculator III</title><link>https://jackeryli.github.io/leetcode/recursion/772/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/recursion/772/</guid><description>class Solution { public: int getNumber(string&amp;amp; expression, int&amp;amp; pos){ int result = 0; while(isdigit(expression[pos]) &amp;amp;&amp;amp; pos &amp;lt; expression.size()){ result = result * 10 + (expression[pos] - &amp;#39;0&amp;#39;); pos++; } return result; } int parseFactor(string&amp;amp; expression, int&amp;amp; pos){ if(expression[pos] == &amp;#39;(&amp;#39;){ pos++; int result = parseExpression(expression, pos); pos++; return result; } return getNumber(expression, pos); } int parseTerm(string&amp;amp; expression, int&amp;amp; pos){ int result = parseFactor(expression, pos); while(pos &amp;lt; expression.size() &amp;amp;&amp;amp; (expression[pos] == &amp;#39;*&amp;#39; || expression[pos] == &amp;#39;/&amp;#39;)){ char op = expression[pos++]; int nextFactor = parseFactor(expression, pos); if(op == &amp;#39;*&amp;#39;){ result *= nextFactor; } else if(op == &amp;#39;/&amp;#39;){ result /= nextFactor; } } return result; } int parseExpression(string&amp;amp; expression, int&amp;amp; pos){ int result = parseTerm(expression, pos); while(pos &amp;lt; expression.</description></item><item><title>852. Peak Index in a Mountatin Array</title><link>https://jackeryli.github.io/leetcode/binary-search/852/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/852/</guid><description>class Solution { public: int peakIndexInMountainArray(vector&amp;lt;int&amp;gt;&amp;amp; arr) { int l = 0; int r = arr.size() - 1; int mid; // Use l &amp;lt; r rather than l &amp;lt;= r because I want to stop at l == r // Seems like no effect in this question while(l &amp;lt; r){ mid = l + (r - l) / 2; // Current is peak if left and right are smaller than mid if(arr[mid-1] &amp;lt; arr[mid] &amp;amp;&amp;amp; arr[mid] &amp;gt; arr[mid+1]){ return mid; } // Only move to mid to avoid illegal condition if(arr[mid-1] &amp;lt; arr[mid]){ l = mid; } else { r = mid; } } return l; } };</description></item><item><title>875. Koko Eating Bananas</title><link>https://jackeryli.github.io/leetcode/binary-search/875/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/875/</guid><description>If we set l &amp;lt; r and r = m
state n-1 3 4 5 6 7 l r m state n 3 4 5 6 7 l r class Solution { public: int minEatingSpeed(vector&amp;lt;int&amp;gt;&amp;amp; piles, int h) { int l = 1; int r = *max_element(piles.begin(), piles.end()); int m; long long hours; while(l &amp;lt;= r){ m = l + (r - l) / 2; hours = 0; for(int&amp;amp; pile : piles){ hours += ((pile / m) + (pile % m !</description></item><item><title>977. Squares of a Sorted Array</title><link>https://jackeryli.github.io/leetcode/two-pointer/977/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/two-pointer/977/</guid><description> Method 1 # Time Complexity: O(n) Space Complexity: O(n) class Solution { public: vector&amp;lt;int&amp;gt; sortedSquares(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int l = 0; int r = nums.size() - 1; int index = nums.size() - 1; vector&amp;lt;int&amp;gt; result(nums.size(), 1); while(l &amp;lt;= r) { int leftpower = nums[l] * nums[l]; int rightpower = nums[r] * nums[r]; if(leftpower &amp;gt; rightpower) { result[index--] = leftpower; l++; } else { result[index--] = rightpower; r--; } } return result; } };</description></item></channel></rss>