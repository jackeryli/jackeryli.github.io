<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Welcome! on</title><link>https://jackeryli.github.io/</link><description>Recent content in Welcome! on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://jackeryli.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Debug xv6 with gdb</title><link>https://jackeryli.github.io/xv6/xv6-gdb/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/xv6/xv6-gdb/</guid><description> Preparation # # Run xv6 with gdb make qemu-gdb # Change to another terminal and connect to xv6-gdb gdb-multiarch -x .gdbinit Basic Command # # Set break point b syscall b module.c:67 # Continue c # Step into step # Step over next # List value of register info register # List args info args # See who call it backtrace # Set value set xxx # Watching variable watch a</description></item><item><title>Implement isatty on xv6</title><link>https://jackeryli.github.io/xv6/xv6-isatty/</link><pubDate>Wed, 24 Jan 2024 12:16:46 +0800</pubDate><guid>https://jackeryli.github.io/xv6/xv6-isatty/</guid><description>I desire to fix the bug that it prints a $ when processing shell commands from a file.</description></item><item><title>Implement xargs on xv6</title><link>https://jackeryli.github.io/xv6/xv6-xargs/</link><pubDate>Tue, 23 Jan 2024 12:16:46 +0800</pubDate><guid>https://jackeryli.github.io/xv6/xv6-xargs/</guid><description>Implement xargs on xv6</description></item><item><title>Implement pwd on xv6</title><link>https://jackeryli.github.io/xv6/xv6-pwd/</link><pubDate>Mon, 22 Jan 2024 12:16:46 +0800</pubDate><guid>https://jackeryli.github.io/xv6/xv6-pwd/</guid><description>pwd will print working directory. Here we will implement pwd on xv6.</description></item><item><title>xv6 lab trap</title><link>https://jackeryli.github.io/xv6/xv6-lab-trap/</link><pubDate>Wed, 11 Oct 2023 12:16:46 +0800</pubDate><guid>https://jackeryli.github.io/xv6/xv6-lab-trap/</guid><description>Implement MIT xv6 lab:trap</description></item><item><title>125. Valid Palindrome</title><link>https://jackeryli.github.io/leetcode/125/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/125/</guid><description>class Solution { public: bool isPalindrome(string s) { // two point left and right // if meet not alpha or number, skip // compare s[left] and s[right] // if equal, continue // if not equal return false // if left == right, return true int left = 0, right = s.size() - 1; for(; left &amp;lt; right; left++, right--) { while(left &amp;lt; right &amp;amp;&amp;amp; !isalnum(s[left])) { left++; } while(left &amp;lt; right &amp;amp;&amp;amp; !</description></item><item><title>1351. Count Negative Numbers in a Sorted Matrix</title><link>https://jackeryli.github.io/leetcode/1351/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/1351/</guid><description>class Solution { public: int binarySearch(vector&amp;lt;int&amp;gt;&amp;amp; arr){ int left = 0; int right = arr.size() - 1; int mid; while(left &amp;lt;= right){ mid = left + (right - left) / 2; if(arr[mid] &amp;gt;= 0){ left = mid + 1; } else { right = mid - 1; } } return arr.size() - left; } int countNegatives(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) { int m = grid.size(); int n = grid[0].size(); int ans = 0; for(auto&amp;amp; arr: grid){ ans += binarySearch(arr); } return ans; } }; class Solution { public: int countNegatives(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) { int m = grid.</description></item><item><title>227. Basic Calculator II</title><link>https://jackeryli.github.io/leetcode/227/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/227/</guid><description>class Solution { public: int getNumber(string&amp;amp; expression, int&amp;amp; pos){ int result = 0; while((isdigit(expression[pos]) || expression[pos] == &amp;#39; &amp;#39;) &amp;amp;&amp;amp; pos &amp;lt; expression.size()){ if(isdigit(expression[pos])){ result = result * 10 + (expression[pos] - &amp;#39;0&amp;#39;); } pos++; } return result; } int parseTerm(string&amp;amp; expression, int&amp;amp; pos){ int result = getNumber(expression, pos); while(pos &amp;lt; expression.size() &amp;amp;&amp;amp; (expression[pos] == &amp;#39;*&amp;#39; || expression[pos] == &amp;#39;/&amp;#39;)){ char op = expression[pos++]; int nextNumber = getNumber(expression, pos); if(op == &amp;#39;*&amp;#39;){ result *= nextNumber; } else if(op == &amp;#39;/&amp;#39;){ result /= nextNumber; } } return result; } int parseExpression(string&amp;amp; expression, int&amp;amp; pos){ int result = parseTerm(expression, pos); while(pos &amp;lt; expression.</description></item><item><title>268. Missing Number</title><link>https://jackeryli.github.io/leetcode/268/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/268/</guid><description>class Solution { public: int missingNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int size = nums.size(); int expect_sum = size * (size+1) / 2; int actual_sum = 0; for(int i = 0; i &amp;lt; size; i++) { actual_sum += nums[i]; } return expect_sum - actual_sum; } };</description></item><item><title>285. Inorder Successor in BST</title><link>https://jackeryli.github.io/leetcode/285/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/285/</guid><description>class Solution { public: bool isTarget = false; TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) { if(root == nullptr) return nullptr; TreeNode* left = inorderSuccessor(root-&amp;gt;left, p); if(left != nullptr) return left; if(isTarget){ return root; } if(p-&amp;gt;val == root-&amp;gt;val){ isTarget = true; } TreeNode* right = inorderSuccessor(root-&amp;gt;right, p); if(right != nullptr) return right; return nullptr; } }; class Solution { public: TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) { TreeNode* sucessor = nullptr; while(root != nullptr){ if(root-&amp;gt;val &amp;lt;= p-&amp;gt;val){ root = root-&amp;gt;right; } else { sucessor = root; root = root-&amp;gt;left; } } return sucessor; } };</description></item><item><title>2966. Divide Array Into Arrays With Max Difference</title><link>https://jackeryli.github.io/leetcode/2966/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/2966/</guid><description>class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; divideArray(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { // sort array from small to large // divide into 3 part // iterate and check if part[0] - part[2] is bigger than k // if yes, return empty vector // if no, assign part[0], part[1], part[2] to one vector sort(nums.begin(), nums.end()); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans = {nums.size()/3, vector&amp;lt;int&amp;gt;{}}; for(int i = 0; i &amp;lt; nums.size(); i+=3){ if((nums[i+2] - nums[i]) &amp;lt;= k) { ans[i/3] = {nums[i], nums[i+1], nums[i+2]}; } else { return vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;{}; } } return ans; } };</description></item><item><title>34. Find First and Last Position of Element in Sorted Array</title><link>https://jackeryli.github.io/leetcode/34/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/34/</guid><description>class Solution { public: int binarySearch(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target, bool isSame){ int left = 0; int right = nums.size() - 1; int mid; int index = -1; while(left &amp;lt;= right){ mid = left + (right - left) / 2; if(nums[mid] == target){ index = mid; if(isSame) right = mid - 1; else left = mid + 1; } else if (nums[mid] &amp;gt; target){ right = mid - 1; } else { left = mid + 1; } } return index; } vector&amp;lt;int&amp;gt; searchRange(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int left = binarySearch(nums, target, true); if(left == -1) return {-1, -1}; int right = binarySearch(nums, target, false); return {left, right}; } };</description></item><item><title>35. Search Insert Position</title><link>https://jackeryli.github.io/leetcode/35/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/35/</guid><description>class Solution { public: int searchInsert(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int left = 0; int right = nums.size() - 1; while(left &amp;lt;= right){ int mid = left + (right - left) / 2; if(target == nums[mid]){ return mid; } else if (target &amp;gt; nums[mid]){ left = mid + 1; } else { right = mid - 1; } } return left; } };</description></item><item><title>436. Find Right Interval</title><link>https://jackeryli.github.io/leetcode/436/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/436/</guid><description>class Solution { public: int binarySearch(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; intervals, int target){ int left = 0; int right = intervals.size() - 1; int mid; // [[1,4], [2,3], [6,7]] while(left &amp;lt;= right){ mid = left + (right - left) / 2; if(target == intervals[mid][0]){ right = mid - 1; } else if (target &amp;gt; intervals[mid][0]){ left = mid + 1; } else { right = mid - 1; } } return left == intervals.size() ?</description></item><item><title>704. Binary Search</title><link>https://jackeryli.github.io/leetcode/704/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/704/</guid><description>class Solution { public: int search(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int left = 0; int right = nums.size()-1; while(left &amp;lt;= right){ int mid = left + (right - left) / 2; if(nums[mid] == target) { return mid; } else if(target &amp;gt; nums[mid]) { left = mid + 1; } else { right = mid - 1; } } return -1; } };</description></item><item><title>744. Find Smallest Letter Greater Than Target</title><link>https://jackeryli.github.io/leetcode/744/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/744/</guid><description>class Solution { public: char nextGreatestLetter(vector&amp;lt;char&amp;gt;&amp;amp; letters, char target) { int left = 0; int right = letters.size() - 1; int mid; while(left &amp;lt;= right){ mid = left + (right - left) / 2; if(letters[mid] &amp;lt;= target){ left = mid + 1; } else { right = mid - 1; } } return left == letters.size() ? letters[0] : letters[left]; } };</description></item><item><title>772. Basic Calculator III</title><link>https://jackeryli.github.io/leetcode/772/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/772/</guid><description>class Solution { public: int getNumber(string&amp;amp; expression, int&amp;amp; pos){ int result = 0; while(isdigit(expression[pos]) &amp;amp;&amp;amp; pos &amp;lt; expression.size()){ result = result * 10 + (expression[pos] - &amp;#39;0&amp;#39;); pos++; } return result; } int parseFactor(string&amp;amp; expression, int&amp;amp; pos){ if(expression[pos] == &amp;#39;(&amp;#39;){ pos++; int result = parseExpression(expression, pos); pos++; return result; } return getNumber(expression, pos); } int parseTerm(string&amp;amp; expression, int&amp;amp; pos){ int result = parseFactor(expression, pos); while(pos &amp;lt; expression.size() &amp;amp;&amp;amp; (expression[pos] == &amp;#39;*&amp;#39; || expression[pos] == &amp;#39;/&amp;#39;)){ char op = expression[pos++]; int nextFactor = parseFactor(expression, pos); if(op == &amp;#39;*&amp;#39;){ result *= nextFactor; } else if(op == &amp;#39;/&amp;#39;){ result /= nextFactor; } } return result; } int parseExpression(string&amp;amp; expression, int&amp;amp; pos){ int result = parseTerm(expression, pos); while(pos &amp;lt; expression.</description></item></channel></rss>