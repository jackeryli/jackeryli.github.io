<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Welcome! on</title><link>https://jackeryli.github.io/</link><description>Recent content in Welcome! on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://jackeryli.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>Configure gdb for qemu</title><link>https://jackeryli.github.io/bare-metal/qemu-gdb/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/bare-metal/qemu-gdb/</guid><description> Compile code with gdb # Enable layout src when you use gdb.
CFLAGS = -ggdb Add flag to qemu # qemu-system-aarch64 -M raspi3b -s -S -kernel kernel.img Create .gdbinit under project folders # Connect gdb on 127.0.0.1:1234 Symbol-file enables breakpoint in gdb set architecture aarch64 target remote 127.0.0.1:1234 symbol-file kernel.elf Run qemu with gdb # make qemu-gdb # Run on another window gdb-multiarch -x .gdbinit # Start using gdb b printk layout src c</description></item><item><title>Debug xv6 with gdb</title><link>https://jackeryli.github.io/xv6/xv6-gdb/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/xv6/xv6-gdb/</guid><description> Preparation # # Run xv6 with gdb make qemu-gdb # Change to another terminal and connect to xv6-gdb gdb-multiarch -x .gdbinit Basic Command # # Set break point b syscall b module.c:67 # Print source code layout src layout asm # Continue c # Step into step # Step over next # Print register or value p /x $stvec p /x $a7 p /x p-&amp;gt;proc # List value of register info register # List args info args # See who call it backtrace # Set value set xxx # Watching variable watch a</description></item><item><title>Write bootloader for raspberry pi 3</title><link>https://jackeryli.github.io/bare-metal/bootloader/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/bare-metal/bootloader/</guid><description>We need three files:
kernel.ld: define the memory layout and tell the hardware where to find entry.S. entry.S: run on single core, do initialization and jump to start.c. start.c: first code. Compile to the kernel image:
Link entry.S and kernel.ld to create kernel.elf Build kernel.img by kernel.elf Boot qemu with kernel.img kernel.ld # ENTRY( _xxx ): tell system to find _entry for the following execution 0x80000: first code will put at 0x800000 because 0 ~ 0x80000 are for io-mapping in arm64 text: put codes data: initialized variable bss: uinitialized variable ENTRY( _entry ) SECTIONS { .</description></item><item><title>Configure miniUART to print characters to terminal</title><link>https://jackeryli.github.io/bare-metal/uart/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/bare-metal/uart/</guid><description>From rpi3 docs, IO physical address started from 0x3F000000.
Physical addresses range from 0x3F000000 to 0x3FFFFFFF for peripherals. The bus addresses for peripherals are set up to map onto the peripheral bus address range starting at 0x7E000000. Thus a peripheral advertised here at bus address 0x7Ennnnnn is available at physical address 0x3Fnnnnnn. And the docs said miniuart register virtual address is at:
Address Reg Name Description 0x7E21 5000 AUX_IRQ Auxiliary Interrupt status 0x7E21 5004 AUX_ENABLES Auxiliary enables 0x7E21 5040 AUX_MU_IO_REG Mini Uart I/O Data So we define the registers we need for miniuart:</description></item><item><title>Write a simple shell</title><link>https://jackeryli.github.io/bare-metal/shell/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/bare-metal/shell/</guid><description>We write a shell that can run the following commands:
help hello timestamp reboot typedef struct cmd_struct { char* name; char* msg; int (*func)(char**); } cmd_struct; int help(char**); int hello(char**); int timestamp(char**); int reboot(char**); // TODO: argv for each commands char* argv[10]; cmd_struct cmds[NCOMMANDS] = { { .name = &amp;#34;help&amp;#34;, .msg = &amp;#34;print available commands&amp;#34;, .func = help }, { .name = &amp;#34;hello&amp;#34;, .msg = &amp;#34;print hello world&amp;#34;, .func = hello }, { .</description></item><item><title>Add system call to linux</title><link>https://jackeryli.github.io/linux-kernel/add_system_call/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/linux-kernel/add_system_call/</guid><description>Open include/uapi/asm-generic/unistd.h
#define __NR_get_cpuid 452 __SYSCALL(__NR_get_cpuid, sys_get_cpuid) #undef __NR_syscalls #define __NR_syscalls 453 Open linux/kernel/sys.c
SYSCALL_DEFINE0(get_cpuid) { return raw_smp_processor_id(); }</description></item><item><title>Write your first kernel module</title><link>https://jackeryli.github.io/linux-kernel/write_first_kernel_module/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/linux-kernel/write_first_kernel_module/</guid><description>Building Kernel Module # Create rootkit.c
#include &amp;lt;linux/module.h&amp;gt; #include &amp;lt;linux/syscalls.h&amp;gt; #include &amp;lt;linux/types.h&amp;gt; #define OURMODNAME &amp;#34;rootkit&amp;#34; MODULE_AUTHOR(&amp;#34;FOOBAR&amp;#34;); MODULE_DESCRIPTION(&amp;#34;FOOBAR&amp;#34;); MODULE_LICENSE(&amp;#34;Dual MIT/GPL&amp;#34;); MODULE_VERSION(&amp;#34;0.1&amp;#34;); static int __init rootkit_init(void) { printk(KERN_INFO &amp;#34;hello, world!\n&amp;#34;); return 0; } static void __exit rootkit_exit(void) { printk(KERN_INFO &amp;#34;Goodbye, world!\n&amp;#34;); } module_init(rootkit_init); module_exit(rootkit_exit); Create Makefile. Remember to update KDIR with your linux source code dir.
obj-m = rootkit.o PWD := $(shell pwd) EXTRA_CFLAGS = -Wall -g CROSS = aarch64-linux-gnu- KDIR = /home/jack/Desktop/linux/ all: $(MAKE) ARCH=arm64 CROSS_COMPILE=$(CROSS) -C $(KDIR) M=$(PWD) modules clean: $(MAKE) -C $(KDIR) M=$(PWD) clean Compile kernel module</description></item><item><title>Implement isatty on xv6</title><link>https://jackeryli.github.io/xv6/xv6-isatty/</link><pubDate>Wed, 24 Jan 2024 12:16:46 +0800</pubDate><guid>https://jackeryli.github.io/xv6/xv6-isatty/</guid><description>I desire to fix the bug that it prints a $ when processing shell commands from a file.</description></item><item><title>Implement xargs on xv6</title><link>https://jackeryli.github.io/xv6/xv6-xargs/</link><pubDate>Tue, 23 Jan 2024 12:16:46 +0800</pubDate><guid>https://jackeryli.github.io/xv6/xv6-xargs/</guid><description>Implement xargs on xv6</description></item><item><title>Implement pwd on xv6</title><link>https://jackeryli.github.io/xv6/xv6-pwd/</link><pubDate>Mon, 22 Jan 2024 12:16:46 +0800</pubDate><guid>https://jackeryli.github.io/xv6/xv6-pwd/</guid><description>pwd will print working directory. Here we will implement pwd on xv6.</description></item><item><title>xv6 lab trap</title><link>https://jackeryli.github.io/xv6/xv6-lab-trap/</link><pubDate>Wed, 11 Oct 2023 12:16:46 +0800</pubDate><guid>https://jackeryli.github.io/xv6/xv6-lab-trap/</guid><description>Implement MIT xv6 lab:trap</description></item><item><title>0015. Three Sum</title><link>https://jackeryli.github.io/leetcode/two-pointer/0015/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/two-pointer/0015/</guid><description>class Solution { public: void twoSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target, int left, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; result) { int l = left; int r = nums.size() - 1; while(l &amp;lt; r) { int sum = nums[l] + nums[r]; if(target &amp;gt; sum) { l++; } else if (target &amp;lt; sum) { r--; } else { result.push_back({-target, nums[l], nums[r]}); l++; r--; while(nums[l] == nums[l-1] &amp;amp;&amp;amp; l &amp;lt; r) l++; while(nums[r] == nums[r+1] &amp;amp;&amp;amp; l &amp;lt; r) r--; } } } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; threeSum(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.</description></item><item><title>0020.Valid Parentheses</title><link>https://jackeryli.github.io/leetcode/stack/0020/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/stack/0020/</guid><description>class Solution { public: bool isValid(string s) { stack&amp;lt;char&amp;gt; sta; for(char c : s){ if(c == &amp;#39;(&amp;#39; || c == &amp;#39;[&amp;#39; || c == &amp;#39;{&amp;#39;){ sta.push(c); } else { if(sta.empty()){ return false; } int t = sta.top(); if(c == &amp;#39;)&amp;#39; &amp;amp;&amp;amp; t != &amp;#39;(&amp;#39;){ return false; } else if (c == &amp;#39;]&amp;#39; &amp;amp;&amp;amp; t != &amp;#39;[&amp;#39;){ return false; } else if (c == &amp;#39;}&amp;#39; &amp;amp;&amp;amp; t != &amp;#39;{&amp;#39;){ return false; } sta.</description></item><item><title>0024. Swap nodes by pairs</title><link>https://jackeryli.github.io/leetcode/linkedlist/0024/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/linkedlist/0024/</guid><description>/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* swapPairs(ListNode* head) { // 1 2 3 4 // s f ListNode* dummy = new ListNode(); dummy-&amp;gt;next = head; ListNode* fast = dummy; ListNode* slow = dummy; ListNode* before = dummy; while(fast-&amp;gt;next !</description></item><item><title>0026. Remove Duplicates from Sorted Array</title><link>https://jackeryli.github.io/leetcode/two-pointer/0026/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/two-pointer/0026/</guid><description>class Solution { public: int removeDuplicates(vector&amp;lt;int&amp;gt;&amp;amp; nums) { // fast and slow start from 0 // fast go first // if nums[fast] != nums[slow], slow++ and swap // return slow int fast = 1, slow = 0; // 0 1 0 1 1 2 2 3 3 4 // 0 1 2 1 1 0 2 3 3 4 // s f for(; fast &amp;lt; nums.size(); fast++) { if(nums[fast] != nums[slow]) { slow++; nums[slow] = nums[fast]; } } return slow + 1; } };</description></item><item><title>0034. Find First and Last Position of Element in Sorted Array</title><link>https://jackeryli.github.io/leetcode/binary-search/0034/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/0034/</guid><description>class Solution { public: int binarySearch(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target, bool isSame){ int left = 0; int right = nums.size() - 1; int mid; int index = -1; while(left &amp;lt;= right){ mid = left + (right - left) / 2; if(nums[mid] == target){ index = mid; if(isSame) right = mid - 1; else left = mid + 1; } else if (nums[mid] &amp;gt; target){ right = mid - 1; } else { left = mid + 1; } } return index; } vector&amp;lt;int&amp;gt; searchRange(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int left = binarySearch(nums, target, true); if(left == -1) return {-1, -1}; int right = binarySearch(nums, target, false); return {left, right}; } };</description></item><item><title>0035. Search Insert Position</title><link>https://jackeryli.github.io/leetcode/binary-search/0035/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/0035/</guid><description>class Solution { public: int searchInsert(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int left = 0; int right = nums.size() - 1; while(left &amp;lt;= right){ int mid = left + (right - left) / 2; if(target == nums[mid]){ return mid; } else if (target &amp;gt; nums[mid]){ left = mid + 1; } else { right = mid - 1; } } return left; } };</description></item><item><title>0036.Valid Sudoku</title><link>https://jackeryli.github.io/leetcode/hashmap/0036/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/hashmap/0036/</guid><description>class Solution { public: bool isValidSudoku(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board) { int m = board.size(); int n = board[0].size(); int columnMap[9][9]; int rowMap[9][9]; int threeMap[9][9]; memset(rowMap, 0, sizeof(rowMap)); memset(columnMap, 0, sizeof(columnMap)); memset(threeMap, 0, sizeof(threeMap)); for(int i = 0; i &amp;lt; m; i++){ for(int j = 0; j &amp;lt; n; j++){ if(isdigit(board[i][j])) { int idx = board[i][j] - &amp;#39;1&amp;#39;; // columnMap if(columnMap[j][idx] != 0) return false; columnMap[j][idx] = 1; // rowMap if(rowMap[i][idx] != 0) return false; rowMap[i][idx] = 1; // threeMap int threeIdx = i/3 * 3 + j/3; if(threeMap[threeIdx][idx] !</description></item><item><title>0048.Rotate Image</title><link>https://jackeryli.github.io/leetcode/array/0048/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/array/0048/</guid><description>class Solution { public: void rotate(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix) { // row column to column row // left to right int m = matrix.size(); for(int i = 0; i &amp;lt; m; i++){ for(int j = i; j &amp;lt; m; j++) { swap(matrix[i][j], matrix[j][i]); } } for(int i = 0; i &amp;lt; m; i++){ for(int j = 0; j &amp;lt; m/2; j++){ swap(matrix[i][j], matrix[i][m-j-1]); } } } };</description></item><item><title>0049.Group Anagrams</title><link>https://jackeryli.github.io/leetcode/hashmap/0049/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/hashmap/0049/</guid><description>class Solution { public: vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; groupAnagrams(vector&amp;lt;string&amp;gt;&amp;amp; strs) { unordered_map&amp;lt;string, vector&amp;lt;string&amp;gt;&amp;gt; map1; vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; result; for(string str : strs){ string key = str; sort(key.begin(), key.end()); map1[key].push_back(str); } for(auto it = map1.begin(); it != map1.end(); it++){ result.push_back(it-&amp;gt;second); } return result; } };</description></item><item><title>0074. Search a 2D Matrix</title><link>https://jackeryli.github.io/leetcode/binary-search/0074/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/0074/</guid><description>class Solution { public: bool searchMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix, int target) { int m = matrix.size(); int n = matrix[0].size(); int left = 0; int right = m*n - 1; int mid; while(left &amp;lt;= right){ mid = left + (right - left) / 2; int row = mid / n; int col = mid % n; if(matrix[row][col] == target) return true; else if(target &amp;gt; matrix[row][col]){ left = mid + 1; } else { right = mid - 1; } } return false; } };</description></item><item><title>0121.Best Time to Buy and Sell Stock</title><link>https://jackeryli.github.io/leetcode/greedy/121/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/greedy/121/</guid><description>class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices) { int result = 0; int minPrice = 100000; for(int&amp;amp; price : prices) { // find minPrice // if price is smaller than minPrice, replace minPrice // else, stock can be selled, compare to the result if(price &amp;lt; minPrice){ minPrice = price; } else { result = max(result, price - minPrice); } } return result; } };</description></item><item><title>0125. Valid Palindrome</title><link>https://jackeryli.github.io/leetcode/two-pointer/0125/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/two-pointer/0125/</guid><description>class Solution { public: bool isPalindrome(string s) { // two point left and right // if meet not alpha or number, skip // compare s[left] and s[right] // if equal, continue // if not equal return false // if left == right, return true int left = 0, right = s.size() - 1; for(; left &amp;lt; right; left++, right--) { while(left &amp;lt; right &amp;amp;&amp;amp; !isalnum(s[left])) { left++; } while(left &amp;lt; right &amp;amp;&amp;amp; !</description></item><item><title>0128.Longest Consecutive Sequence</title><link>https://jackeryli.github.io/leetcode/hashmap/0128/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/hashmap/0128/</guid><description>class Solution { public: int longestConsecutive(vector&amp;lt;int&amp;gt;&amp;amp; nums) { unordered_set&amp;lt;int&amp;gt; set1; int result = 0; for(int&amp;amp; num : nums){ set1.insert(num); } for(int&amp;amp; num : nums){ int start; if(set1.find(num-1) == set1.end()){ start = num; } int distance = 0; while(set1.find(start) != set1.end()){ start = start + 1; distance++; } result = max(result, distance); } return result; } };</description></item><item><title>0141. Linked List Cycle</title><link>https://jackeryli.github.io/leetcode/two-pointer/0141/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/two-pointer/0141/</guid><description>/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: bool hasCycle(ListNode *head) { ListNode* fast = head; ListNode* slow = head; while(fast != nullptr &amp;amp;&amp;amp; fast-&amp;gt;next != nullptr){ fast = fast-&amp;gt;next-&amp;gt;next; slow = slow-&amp;gt;next; if(fast == slow) { return true; } } return false; } };</description></item><item><title>0142. Linked List Cycle II</title><link>https://jackeryli.github.io/leetcode/two-pointer/0142/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/two-pointer/0142/</guid><description>/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *detectCycle(ListNode *head) { // fast move 2 pos // slow move 1 pos // pos count: 2(x+y) = x + y + n(y + z) // n = 1, x = z ListNode* fast = head; ListNode* slow = head; while(fast !</description></item><item><title>0189.Rotate Array</title><link>https://jackeryli.github.io/leetcode/two-pointer/0189/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/two-pointer/0189/</guid><description>class Solution { public: void rotate(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { reverse(nums.begin(), nums.end()); if(k &amp;gt; nums.size()) k = k % nums.size(); reverse(nums.begin(), nums.begin() + k); reverse(nums.begin() + k, nums.end()); } };</description></item><item><title>0202.Happy Number</title><link>https://jackeryli.github.io/leetcode/hashmap/0202/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/hashmap/0202/</guid><description>class Solution { public: bool isHappy(int n) { int sum = 0; unordered_set&amp;lt;int&amp;gt; sumSet; while(1){ sum = 0; while(n &amp;gt; 0){ int digit = n % 10; sum += (digit * digit); n /= 10; } if(sum == 1) return true; if(sumSet.find(sum) != sumSet.end()) return false; else sumSet.insert(sum); n = sum; } return false; } }; class Solution { public: unordered_set&amp;lt;int&amp;gt; sumSet; int getNext(int num){ int sum = 0; while(num &amp;gt; 0){ int digit = num % 10; sum += (digit * digit); num /= 10; } return sum; } bool isHappy(int n) { while(n !</description></item><item><title>0209. Minimum Size Subarray Sum</title><link>https://jackeryli.github.io/leetcode/sliding-window/209/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/sliding-window/209/</guid><description>class Solution { public: int minSubArrayLen(int target, vector&amp;lt;int&amp;gt;&amp;amp; nums) { int left = 0; int sum = 0; int ans = INT_MAX; for(int right = 0; right &amp;lt; nums.size(); right++) { sum += nums[right]; while(sum &amp;gt;= target) { ans = min(ans, right - left + 1); sum -= nums[left++]; } } return ans == INT_MAX ? 0 : ans; } };</description></item><item><title>0219. Contains Duplicated II</title><link>https://jackeryli.github.io/leetcode/hashmap/0219/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/hashmap/0219/</guid><description>class Solution { public: bool containsNearbyDuplicate(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { unordered_map&amp;lt;int, int&amp;gt; num2FirstIdx; for(int i = 0; i &amp;lt; nums.size(); i++) { if(num2FirstIdx.find(nums[i]) == num2FirstIdx.end()){ num2FirstIdx[nums[i]] = i; } else { if(i - num2FirstIdx[nums[i]] &amp;lt;= k) return true; num2FirstIdx[nums[i]] = i; } } return false; } };</description></item><item><title>0227. Basic Calculator II</title><link>https://jackeryli.github.io/leetcode/recursion/227/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/recursion/227/</guid><description>class Solution { public: int getNumber(string&amp;amp; expression, int&amp;amp; pos){ int result = 0; while((isdigit(expression[pos]) || expression[pos] == &amp;#39; &amp;#39;) &amp;amp;&amp;amp; pos &amp;lt; expression.size()){ if(isdigit(expression[pos])){ result = result * 10 + (expression[pos] - &amp;#39;0&amp;#39;); } pos++; } return result; } int parseTerm(string&amp;amp; expression, int&amp;amp; pos){ int result = getNumber(expression, pos); while(pos &amp;lt; expression.size() &amp;amp;&amp;amp; (expression[pos] == &amp;#39;*&amp;#39; || expression[pos] == &amp;#39;/&amp;#39;)){ char op = expression[pos++]; int nextNumber = getNumber(expression, pos); if(op == &amp;#39;*&amp;#39;){ result *= nextNumber; } else if(op == &amp;#39;/&amp;#39;){ result /= nextNumber; } } return result; } int parseExpression(string&amp;amp; expression, int&amp;amp; pos){ int result = parseTerm(expression, pos); while(pos &amp;lt; expression.</description></item><item><title>0242. Valid Anagrams</title><link>https://jackeryli.github.io/leetcode/hashmap/0242/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/hashmap/0242/</guid><description>class Solution { public: bool isAnagram(string s, string t) { // If size different, it isn&amp;#39;t anagram if(s.size() != t.size()) return false; unordered_map&amp;lt;char, int&amp;gt; charToCount; for(char c : s) { charToCount[c]++; } for(char c : t) { charToCount[c]--; } for(int i = 0; i &amp;lt; 26; i++) { char c = &amp;#39;a&amp;#39; + i; if(charToCount[c] != 0) return false; } return true; } }; class Solution { public: bool isAnagram(string s, string t) { int mapS2count[26]; memset(mapS2count, 0, sizeof(mapS2count)); for(char c : s){ mapS2count[c - &amp;#39;a&amp;#39;]++; } for(char c : t){ mapS2count[c - &amp;#39;a&amp;#39;]--; } for(int i = 0; i &amp;lt; 26; i++){ if(mapS2count[i] !</description></item><item><title>0268. Missing Number</title><link>https://jackeryli.github.io/leetcode/recursion/268/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/recursion/268/</guid><description>class Solution { public: int missingNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int size = nums.size(); int expect_sum = size * (size+1) / 2; int actual_sum = 0; for(int i = 0; i &amp;lt; size; i++) { actual_sum += nums[i]; } return expect_sum - actual_sum; } };</description></item><item><title>0285. Inorder Successor in BST</title><link>https://jackeryli.github.io/leetcode/recursion/285/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/recursion/285/</guid><description>class Solution { public: bool isTarget = false; TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) { if(root == nullptr) return nullptr; TreeNode* left = inorderSuccessor(root-&amp;gt;left, p); if(left != nullptr) return left; if(isTarget){ return root; } if(p-&amp;gt;val == root-&amp;gt;val){ isTarget = true; } TreeNode* right = inorderSuccessor(root-&amp;gt;right, p); if(right != nullptr) return right; return nullptr; } }; class Solution { public: TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) { TreeNode* sucessor = nullptr; while(root != nullptr){ if(root-&amp;gt;val &amp;lt;= p-&amp;gt;val){ root = root-&amp;gt;right; } else { sucessor = root; root = root-&amp;gt;left; } } return sucessor; } };</description></item><item><title>0290.Word Pattern</title><link>https://jackeryli.github.io/leetcode/hashmap/0290/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/hashmap/0290/</guid><description>class Solution { public: bool wordPattern(string pattern, string s) { unordered_map&amp;lt;char, string&amp;gt; mapP2S; unordered_map&amp;lt;string, char&amp;gt; mapS2P; int i = 0; int l = 0, r = 0; int n = s.size(); while(l &amp;lt; n &amp;amp;&amp;amp; r &amp;lt; n){ // Split the string by space while(s[r] != &amp;#39; &amp;#39; &amp;amp;&amp;amp; r &amp;lt; n) r++; // ensure r range string sub = s.substr(l, r - l); // blank index to left index // if pattern and string are all not recorded before, record it if(mapP2S.</description></item><item><title>0382.Rawsom Note</title><link>https://jackeryli.github.io/leetcode/hashmap/0383/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/hashmap/0383/</guid><description>class Solution { public: bool canConstruct(string ransomNote, string magazine) { // put magazine in hashmap, key: character, value: count // check each character in ransomNote and minus count // If unvalid situation, return false // return true if completely iterates ransomNote int magazineCharToCount[26]; memset(magazineCharToCount, 0, sizeof(magazineCharToCount)); for(char c : magazine){ magazineCharToCount[c - &amp;#39;a&amp;#39;]++; } for(char c : ransomNote){ int idx = c - &amp;#39;a&amp;#39;; if(magazineCharToCount[idx] == 0){ return false; } magazineCharToCount[idx]--; } return true; } };</description></item><item><title>0392. Is Subsequence</title><link>https://jackeryli.github.io/leetcode/two-pointer/0392/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/two-pointer/0392/</guid><description>class Solution { public: bool isSubsequence(string s, string t) { if(t.size() &amp;lt; s.size()) return false; int index1 = 0; int index2 = 0; while(index1 &amp;lt; s.size() &amp;amp;&amp;amp; index2 &amp;lt; t.size()) { if(s[index1] == t[index2]){ index1++; index2++; } else { index2++; } } return index1 == s.size(); } };</description></item><item><title>0436. Find Right Interval</title><link>https://jackeryli.github.io/leetcode/binary-search/0436/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/0436/</guid><description>class Solution { public: int binarySearch(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; intervals, int target){ int left = 0; int right = intervals.size() - 1; int mid; // [[1,4], [2,3], [6,7]] while(left &amp;lt;= right){ mid = left + (right - left) / 2; if(target == intervals[mid][0]){ right = mid - 1; } else if (target &amp;gt; intervals[mid][0]){ left = mid + 1; } else { right = mid - 1; } } return left == intervals.size() ?</description></item><item><title>0611. Valid Triangle Number</title><link>https://jackeryli.github.io/leetcode/binary-search/0611/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/0611/</guid><description>class Solution { public: int binarySearch(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target, int left){ // find the number that smaller than a + b // for example: 2 2 3 3 4 4 // final: r l // return (l - left) number are smaller than a + b int l = left; int r = nums.size() - 1; int mid; while(l &amp;lt;= r){ mid = l + (r - l) / 2; if(nums[mid] == target){ r = mid - 1; } else if(nums[mid] &amp;gt; target){ r = mid - 1; } else { l = mid + 1; } } return l - left; } int triangleNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.</description></item><item><title>0702. Search in a Sorted Array of Unknown Size</title><link>https://jackeryli.github.io/leetcode/binary-search/0702/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/0702/</guid><description>/** * // This is the ArrayReader&amp;#39;s API interface. * // You should not implement it, or speculate about its implementation * class ArrayReader { * public: * int get(int index); * }; */ class Solution { public: int search(const ArrayReader&amp;amp; reader, int target) { int l = 0; int r = 1; int mid; int num; // Find right most point which covered by 2^right-1 and 2^right while(reader.get(r) != INT_MAX){ l = r; r = r &amp;lt;&amp;lt; 1; } // Find right most point while(l &amp;lt;= r){ mid = l + (r - l) / 2; if(reader.</description></item><item><title>0704. Binary Search</title><link>https://jackeryli.github.io/leetcode/binary-search/0704/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/0704/</guid><description>class Solution { public: int search(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int left = 0; int right = nums.size()-1; while(left &amp;lt;= right){ int mid = left + (right - left) / 2; if(nums[mid] == target) { return mid; } else if(target &amp;gt; nums[mid]) { left = mid + 1; } else { right = mid - 1; } } return -1; } };</description></item><item><title>0744. Find Smallest Letter Greater Than Target</title><link>https://jackeryli.github.io/leetcode/binary-search/0744/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/0744/</guid><description>class Solution { public: char nextGreatestLetter(vector&amp;lt;char&amp;gt;&amp;amp; letters, char target) { int left = 0; int right = letters.size() - 1; int mid; while(left &amp;lt;= right){ mid = left + (right - left) / 2; if(letters[mid] &amp;lt;= target){ left = mid + 1; } else { right = mid - 1; } } return left == letters.size() ? letters[0] : letters[left]; } };</description></item><item><title>0772. Basic Calculator III</title><link>https://jackeryli.github.io/leetcode/recursion/772/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/recursion/772/</guid><description>class Solution { public: int getNumber(string&amp;amp; expression, int&amp;amp; pos){ int result = 0; while(isdigit(expression[pos]) &amp;amp;&amp;amp; pos &amp;lt; expression.size()){ result = result * 10 + (expression[pos] - &amp;#39;0&amp;#39;); pos++; } return result; } int parseFactor(string&amp;amp; expression, int&amp;amp; pos){ if(expression[pos] == &amp;#39;(&amp;#39;){ pos++; int result = parseExpression(expression, pos); pos++; return result; } return getNumber(expression, pos); } int parseTerm(string&amp;amp; expression, int&amp;amp; pos){ int result = parseFactor(expression, pos); while(pos &amp;lt; expression.size() &amp;amp;&amp;amp; (expression[pos] == &amp;#39;*&amp;#39; || expression[pos] == &amp;#39;/&amp;#39;)){ char op = expression[pos++]; int nextFactor = parseFactor(expression, pos); if(op == &amp;#39;*&amp;#39;){ result *= nextFactor; } else if(op == &amp;#39;/&amp;#39;){ result /= nextFactor; } } return result; } int parseExpression(string&amp;amp; expression, int&amp;amp; pos){ int result = parseTerm(expression, pos); while(pos &amp;lt; expression.</description></item><item><title>0852. Peak Index in a Mountatin Array</title><link>https://jackeryli.github.io/leetcode/binary-search/0852/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/0852/</guid><description>class Solution { public: int peakIndexInMountainArray(vector&amp;lt;int&amp;gt;&amp;amp; arr) { int l = 0; int r = arr.size() - 1; int mid; // Use l &amp;lt; r rather than l &amp;lt;= r because I want to stop at l == r // Seems like no effect in this question while(l &amp;lt; r){ mid = l + (r - l) / 2; // Current is peak if left and right are smaller than mid if(arr[mid-1] &amp;lt; arr[mid] &amp;amp;&amp;amp; arr[mid] &amp;gt; arr[mid+1]){ return mid; } // Only move to mid to avoid illegal condition if(arr[mid-1] &amp;lt; arr[mid]){ l = mid; } else { r = mid; } } return l; } };</description></item><item><title>0875. Koko Eating Bananas</title><link>https://jackeryli.github.io/leetcode/binary-search/0875/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/0875/</guid><description>If we set l &amp;lt; r and r = m
state n-1 3 4 5 6 7 l r m state n 3 4 5 6 7 l r class Solution { public: int minEatingSpeed(vector&amp;lt;int&amp;gt;&amp;amp; piles, int h) { int l = 1; int r = *max_element(piles.begin(), piles.end()); int m; long long hours; while(l &amp;lt;= r){ m = l + (r - l) / 2; hours = 0; for(int&amp;amp; pile : piles){ hours += ((pile / m) + (pile % m !</description></item><item><title>0977. Squares of a Sorted Array</title><link>https://jackeryli.github.io/leetcode/two-pointer/0977/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/two-pointer/0977/</guid><description> Method 1 # Time Complexity: O(n) Space Complexity: O(n) class Solution { public: vector&amp;lt;int&amp;gt; sortedSquares(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int l = 0; int r = nums.size() - 1; int index = nums.size() - 1; vector&amp;lt;int&amp;gt; result(nums.size(), 1); while(l &amp;lt;= r) { int leftpower = nums[l] * nums[l]; int rightpower = nums[r] * nums[r]; if(leftpower &amp;gt; rightpower) { result[index--] = leftpower; l++; } else { result[index--] = rightpower; r--; } } return result; } };</description></item><item><title>100.Same Tree</title><link>https://jackeryli.github.io/leetcode/binary-tree/100/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-tree/100/</guid><description>class Solution { public: bool isSameTree(TreeNode* p, TreeNode* q) { if(p == nullptr &amp;amp;&amp;amp; q == nullptr) return true; if(p == nullptr || q == nullptr) return false; if(p-&amp;gt;val != q-&amp;gt;val) return false; return isSameTree(p-&amp;gt;left, q-&amp;gt;left) &amp;amp;&amp;amp; isSameTree(p-&amp;gt;right, q-&amp;gt;right); } };</description></item><item><title>1011. Capacity To Ship Packages Within D Days</title><link>https://jackeryli.github.io/leetcode/binary-search/1011/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/1011/</guid><description>class Solution { public: int countShipDays(vector&amp;lt;int&amp;gt;&amp;amp; weights, int capacity){ int usedDays = 1; int current = capacity; for(int&amp;amp; weight : weights){ if(weight &amp;gt; capacity){ return INT_MAX; } if(current &amp;gt;= weight){ current -= weight; } else { usedDays++; current = capacity - weight; } } return usedDays; } int shipWithinDays(vector&amp;lt;int&amp;gt;&amp;amp; weights, int days) { int l = 0; int r = *max_element(weights.begin(), weights.end()); int usedDays; int mid; while(l &amp;lt; r){ usedDays = countShipDays(weights, r); if(usedDays &amp;lt;= days) break; l = r; r = r &amp;lt;&amp;lt; 1; } while(l &amp;lt;= r){ mid = l + (r - l) / 2; usedDays = countShipDays(weights, mid); if(usedDays == days){ r = mid-1; } else if(usedDays &amp;gt; days){ l = mid + 1; } else { r = mid-1; } } return l; } };</description></item><item><title>104. Maximum Depth of Binary Tree</title><link>https://jackeryli.github.io/leetcode/binary-tree/104/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-tree/104/</guid><description>class Solution { public: int maxDepth(TreeNode* root) { if(root == nullptr) return 0; return max(maxDepth(root-&amp;gt;left), maxDepth(root-&amp;gt;right)) + 1; } };</description></item><item><title>1283. Find the Smallest Divisor Given a Threshold</title><link>https://jackeryli.github.io/leetcode/binary-search/1283/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/1283/</guid><description>class Solution { public: int calDivisionSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int divisor){ int result = 0; for(int&amp;amp; num : nums){ result += (num / divisor) + (num % divisor != 0); } return result; } int smallestDivisor(vector&amp;lt;int&amp;gt;&amp;amp; nums, int threshold) { int l = 1; int r = *max_element(nums.begin(), nums.end()); int m; int pivot; while(l &amp;lt;= r){ m = l + (r - l) / 2; pivot = calDivisionSum(nums, m); if(pivot == threshold){ r = m - 1; } else if(pivot &amp;gt; threshold){ l = m + 1; } else { r = m - 1; } } return l; } };</description></item><item><title>1351. Count Negative Numbers in a Sorted Matrix</title><link>https://jackeryli.github.io/leetcode/binary-search/1351/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/1351/</guid><description>class Solution { public: int binarySearch(vector&amp;lt;int&amp;gt;&amp;amp; arr){ int left = 0; int right = arr.size() - 1; int mid; while(left &amp;lt;= right){ mid = left + (right - left) / 2; if(arr[mid] &amp;gt;= 0){ left = mid + 1; } else { right = mid - 1; } } return arr.size() - left; } int countNegatives(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) { int m = grid.size(); int n = grid[0].size(); int ans = 0; for(auto&amp;amp; arr: grid){ ans += binarySearch(arr); } return ans; } }; class Solution { public: int countNegatives(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) { int m = grid.</description></item><item><title>1870. Minimum Speed to Arrive on Time</title><link>https://jackeryli.github.io/leetcode/binary-search/1870/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/1870/</guid><description>class Solution { public: double calHourSpent(vector&amp;lt;int&amp;gt;&amp;amp; dist, int speed) { int n = dist.size() - 1; double hourSpent = 0; for(int i = 0; i &amp;lt; n; i++) { hourSpent += (dist[i] / speed + (dist[i] % speed != 0)); } return hourSpent + (double) dist[n] / speed; } int minSpeedOnTime(vector&amp;lt;int&amp;gt;&amp;amp; dist, double hour) { if(hour &amp;lt;= dist.size() - 1){ return -1; } int l = 1; int r = 10e7; // two digit decimal after 10e5 int m; double pivot; while(l &amp;lt; r) { m = l + (r - l) / 2; pivot = calHourSpent(dist, m); if(pivot == hour){ r = m; } else if (pivot &amp;gt; hour){ l = m + 1; } else { r = m; } } return r; } };</description></item><item><title>2300. Successful Pairs of Spells and Potions</title><link>https://jackeryli.github.io/leetcode/binary-search/2300/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/2300/</guid><description>class Solution { public: int binarySearch(vector&amp;lt;int&amp;gt;&amp;amp; potions, long long target) { int n = potions.size(); int l = 0; int r = n - 1; while(l &amp;lt;= r) { long long m = l + (r - l) / 2; if(potions[m] == target) { r = m - 1; } else if (potions[m] &amp;gt; target) { r = m - 1; } else { l = m + 1; } } // 1 2 3 4 5 // lr // r l return n - l; } vector&amp;lt;int&amp;gt; successfulPairs(vector&amp;lt;int&amp;gt;&amp;amp; spells, vector&amp;lt;int&amp;gt;&amp;amp; potions, long long success) { vector&amp;lt;int&amp;gt; result; sort(potions.</description></item><item><title>2966. Divide Array Into Arrays With Max Difference</title><link>https://jackeryli.github.io/leetcode/array/2966/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/array/2966/</guid><description>class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; divideArray(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { // sort array from small to large // divide into 3 part // iterate and check if part[0] - part[2] is bigger than k // if yes, return empty vector // if no, assign part[0], part[1], part[2] to one vector sort(nums.begin(), nums.end()); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; ans = {nums.size()/3, vector&amp;lt;int&amp;gt;{}}; for(int i = 0; i &amp;lt; nums.size(); i+=3){ if((nums[i+2] - nums[i]) &amp;lt;= k) { ans[i/3] = {nums[i], nums[i+1], nums[i+2]}; } else { return vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;{}; } } return ans; } };</description></item><item><title>58. Length of Last Word</title><link>https://jackeryli.github.io/leetcode/string/0058/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/string/0058/</guid><description>class Solution { public: int lengthOfLastWord(string s) { int n = s.size(); int l = n-1; int r = l; while(r &amp;gt;= 0 &amp;amp;&amp;amp; s[r] == &amp;#39; &amp;#39;) r--; l = r; while(l &amp;gt;= 0 &amp;amp;&amp;amp; s[l] != &amp;#39; &amp;#39;) l--; return r - l; } };</description></item><item><title>How TCP establish and close connection?</title><link>https://jackeryli.github.io/network/tcp-connection/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/network/tcp-connection/</guid><description>TCP establish connection # sequenceDiagram participant Client participant Server Note over Client, Server: CLOSED Note right of Server: LISTEN Client->>Server: SYN seq=100 Note left of Client: SYN-SENT Server->>Client: SYN ACK seq=300 ack=101 Note right of Server: SYN_RCVD Note left of Client: ESTABLISHED Client->>Server: ACK seq=101 ack=301 Note right of Server: ESTABLISHED TCP close connection # sequenceDiagram participant Client participant Server Note left of Client: ESTABLISHED Note right of Server: ESTABLISHED Client->>Server: FIN seq=300 Note left of Client: FIN_WAIT Note right of Server: CLOSE_WAIT Server->>Client: ACK ack=301 Note right of Server: LAST_ACK Note left of Client: FIN_WAIT2 Server->>Client: FIN seq=500 ack=301 Note left of Client: TIME_WAIT Client->>Server: ACK seq=301 ack=501 Note right of Server: CLOSED Note left of Client: CLOSED Why TCP has TIME_WAIT?</description></item></channel></rss>