<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title/><link>https://jackeryli.github.io/leetcode/divide_conquer/</link><description>Recent content on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://jackeryli.github.io/leetcode/divide_conquer/index.xml" rel="self" type="application/rss+xml"/><item><title>0108. Convert Sorted Array to Binary Search Tree</title><link>https://jackeryli.github.io/leetcode/divide_conquer/0108/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/divide_conquer/0108/</guid><description>class Solution { public: TreeNode* sortedArrayToBST(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if(nums.size() == 0) return nullptr; int mid = nums.size() / 2; TreeNode* root = new TreeNode(nums[mid]); vector&amp;lt;int&amp;gt; leftNodes(nums.begin(), nums.begin() + mid); vector&amp;lt;int&amp;gt; rightNodes(nums.begin() + mid + 1, nums.end()); root-&amp;gt;left = sortedArrayToBST(leftNodes); root-&amp;gt;right = sortedArrayToBST(rightNodes); return root; } }; class Solution { public: TreeNode* helper(vector&amp;lt;int&amp;gt;&amp;amp; nums, int left, int right) { if(left &amp;gt; right) return nullptr; int mid = left + (right - left) / 2; TreeNode* root = new TreeNode(nums[mid]); root-&amp;gt;left = helper(nums, left, mid - 1); root-&amp;gt;right = helper(nums, mid + 1, right); return root; } TreeNode* sortedArrayToBST(vector&amp;lt;int&amp;gt;&amp;amp; nums) { if(nums.</description></item><item><title>0148. Sort List</title><link>https://jackeryli.github.io/leetcode/divide_conquer/0148/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/divide_conquer/0148/</guid><description>/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode() : val(0), next(nullptr) {} * ListNode(int x) : val(x), next(nullptr) {} * ListNode(int x, ListNode *next) : val(x), next(next) {} * }; */ class Solution { public: ListNode* findMiddle(ListNode* head) { ListNode* fast = head; ListNode* slow = nullptr; while(fast != nullptr &amp;amp;&amp;amp; fast-&amp;gt;next != nullptr) { fast = fast-&amp;gt;next-&amp;gt;next; slow = (slow == nullptr) ?</description></item><item><title>0427. Construct Quad Tree</title><link>https://jackeryli.github.io/leetcode/divide_conquer/0427/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/divide_conquer/0427/</guid><description>/* // Definition for a QuadTree node. class Node { public: bool val; bool isLeaf; Node* topLeft; Node* topRight; Node* bottomLeft; Node* bottomRight; Node() { val = false; isLeaf = false; topLeft = NULL; topRight = NULL; bottomLeft = NULL; bottomRight = NULL; } Node(bool _val, bool _isLeaf) { val = _val; isLeaf = _isLeaf; topLeft = NULL; topRight = NULL; bottomLeft = NULL; bottomRight = NULL; } Node(bool _val, bool _isLeaf, Node* _topLeft, Node* _topRight, Node* _bottomLeft, Node* _bottomRight) { val = _val; isLeaf = _isLeaf; topLeft = _topLeft; topRight = _topRight; bottomLeft = _bottomLeft; bottomRight = _bottomRight; } }; */ class Solution { public: bool isDifferent(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid, int rowStart, int rowEnd, int colStart, int colEnd) { int curr = grid[rowStart][colStart]; for(int i = rowStart; i &amp;lt;= rowEnd; i++) { for(int j = colStart; j &amp;lt;= colEnd; j++) { if(grid[i][j] !</description></item></channel></rss>