<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title/><link>https://jackeryli.github.io/leetcode/binary-search/</link><description>Recent content on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://jackeryli.github.io/leetcode/binary-search/index.xml" rel="self" type="application/rss+xml"/><item><title>1011. Capacity To Ship Packages Within D Days</title><link>https://jackeryli.github.io/leetcode/binary-search/1011/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/1011/</guid><description>class Solution { public: int countShipDays(vector&amp;lt;int&amp;gt;&amp;amp; weights, int capacity){ int usedDays = 1; int current = capacity; for(int&amp;amp; weight : weights){ if(weight &amp;gt; capacity){ return INT_MAX; } if(current &amp;gt;= weight){ current -= weight; } else { usedDays++; current = capacity - weight; } } return usedDays; } int shipWithinDays(vector&amp;lt;int&amp;gt;&amp;amp; weights, int days) { int l = 0; int r = *max_element(weights.begin(), weights.end()); int usedDays; int mid; while(l &amp;lt; r){ usedDays = countShipDays(weights, r); if(usedDays &amp;lt;= days) break; l = r; r = r &amp;lt;&amp;lt; 1; } while(l &amp;lt;= r){ mid = l + (r - l) / 2; usedDays = countShipDays(weights, mid); if(usedDays == days){ r = mid-1; } else if(usedDays &amp;gt; days){ l = mid + 1; } else { r = mid-1; } } return l; } };</description></item><item><title>1283. Find the Smallest Divisor Given a Threshold</title><link>https://jackeryli.github.io/leetcode/binary-search/1283/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/1283/</guid><description>class Solution { public: int calDivisionSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int divisor){ int result = 0; for(int&amp;amp; num : nums){ result += (num / divisor) + (num % divisor != 0); } return result; } int smallestDivisor(vector&amp;lt;int&amp;gt;&amp;amp; nums, int threshold) { int l = 1; int r = *max_element(nums.begin(), nums.end()); int m; int pivot; while(l &amp;lt;= r){ m = l + (r - l) / 2; pivot = calDivisionSum(nums, m); if(pivot == threshold){ r = m - 1; } else if(pivot &amp;gt; threshold){ l = m + 1; } else { r = m - 1; } } return l; } };</description></item><item><title>1351. Count Negative Numbers in a Sorted Matrix</title><link>https://jackeryli.github.io/leetcode/binary-search/1351/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/1351/</guid><description>class Solution { public: int binarySearch(vector&amp;lt;int&amp;gt;&amp;amp; arr){ int left = 0; int right = arr.size() - 1; int mid; while(left &amp;lt;= right){ mid = left + (right - left) / 2; if(arr[mid] &amp;gt;= 0){ left = mid + 1; } else { right = mid - 1; } } return arr.size() - left; } int countNegatives(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) { int m = grid.size(); int n = grid[0].size(); int ans = 0; for(auto&amp;amp; arr: grid){ ans += binarySearch(arr); } return ans; } }; class Solution { public: int countNegatives(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) { int m = grid.</description></item><item><title>1870. Minimum Speed to Arrive on Time</title><link>https://jackeryli.github.io/leetcode/binary-search/1870/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/1870/</guid><description>class Solution { public: double calHourSpent(vector&amp;lt;int&amp;gt;&amp;amp; dist, int speed) { int n = dist.size() - 1; double hourSpent = 0; for(int i = 0; i &amp;lt; n; i++) { hourSpent += (dist[i] / speed + (dist[i] % speed != 0)); } return hourSpent + (double) dist[n] / speed; } int minSpeedOnTime(vector&amp;lt;int&amp;gt;&amp;amp; dist, double hour) { if(hour &amp;lt;= dist.size() - 1){ return -1; } int l = 1; int r = 10e7; // two digit decimal after 10e5 int m; double pivot; while(l &amp;lt; r) { m = l + (r - l) / 2; pivot = calHourSpent(dist, m); if(pivot == hour){ r = m; } else if (pivot &amp;gt; hour){ l = m + 1; } else { r = m; } } return r; } };</description></item><item><title>2300. Successful Pairs of Spells and Potions</title><link>https://jackeryli.github.io/leetcode/binary-search/2300/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/2300/</guid><description>class Solution { public: int binarySearch(vector&amp;lt;int&amp;gt;&amp;amp; potions, long long target) { int n = potions.size(); int l = 0; int r = n - 1; while(l &amp;lt;= r) { long long m = l + (r - l) / 2; if(potions[m] == target) { r = m - 1; } else if (potions[m] &amp;gt; target) { r = m - 1; } else { l = m + 1; } } // 1 2 3 4 5 // lr // r l return n - l; } vector&amp;lt;int&amp;gt; successfulPairs(vector&amp;lt;int&amp;gt;&amp;amp; spells, vector&amp;lt;int&amp;gt;&amp;amp; potions, long long success) { vector&amp;lt;int&amp;gt; result; sort(potions.</description></item><item><title>34. Find First and Last Position of Element in Sorted Array</title><link>https://jackeryli.github.io/leetcode/binary-search/0034/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/0034/</guid><description>class Solution { public: int binarySearch(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target, bool isSame){ int left = 0; int right = nums.size() - 1; int mid; int index = -1; while(left &amp;lt;= right){ mid = left + (right - left) / 2; if(nums[mid] == target){ index = mid; if(isSame) right = mid - 1; else left = mid + 1; } else if (nums[mid] &amp;gt; target){ right = mid - 1; } else { left = mid + 1; } } return index; } vector&amp;lt;int&amp;gt; searchRange(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int left = binarySearch(nums, target, true); if(left == -1) return {-1, -1}; int right = binarySearch(nums, target, false); return {left, right}; } };</description></item><item><title>35. Search Insert Position</title><link>https://jackeryli.github.io/leetcode/binary-search/0035/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/0035/</guid><description>class Solution { public: int searchInsert(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int left = 0; int right = nums.size() - 1; while(left &amp;lt;= right){ int mid = left + (right - left) / 2; if(target == nums[mid]){ return mid; } else if (target &amp;gt; nums[mid]){ left = mid + 1; } else { right = mid - 1; } } return left; } };</description></item><item><title>436. Find Right Interval</title><link>https://jackeryli.github.io/leetcode/binary-search/0436/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/0436/</guid><description>class Solution { public: int binarySearch(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; intervals, int target){ int left = 0; int right = intervals.size() - 1; int mid; // [[1,4], [2,3], [6,7]] while(left &amp;lt;= right){ mid = left + (right - left) / 2; if(target == intervals[mid][0]){ right = mid - 1; } else if (target &amp;gt; intervals[mid][0]){ left = mid + 1; } else { right = mid - 1; } } return left == intervals.size() ?</description></item><item><title>611. Valid Triangle Number</title><link>https://jackeryli.github.io/leetcode/binary-search/0611/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/0611/</guid><description>class Solution { public: int binarySearch(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target, int left){ // find the number that smaller than a + b // for example: 2 2 3 3 4 4 // final: r l // return (l - left) number are smaller than a + b int l = left; int r = nums.size() - 1; int mid; while(l &amp;lt;= r){ mid = l + (r - l) / 2; if(nums[mid] == target){ r = mid - 1; } else if(nums[mid] &amp;gt; target){ r = mid - 1; } else { l = mid + 1; } } return l - left; } int triangleNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.</description></item><item><title>702. Search in a Sorted Array of Unknown Size</title><link>https://jackeryli.github.io/leetcode/binary-search/0702/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/0702/</guid><description>/** * // This is the ArrayReader&amp;#39;s API interface. * // You should not implement it, or speculate about its implementation * class ArrayReader { * public: * int get(int index); * }; */ class Solution { public: int search(const ArrayReader&amp;amp; reader, int target) { int l = 0; int r = 1; int mid; int num; // Find right most point which covered by 2^right-1 and 2^right while(reader.get(r) != INT_MAX){ l = r; r = r &amp;lt;&amp;lt; 1; } // Find right most point while(l &amp;lt;= r){ mid = l + (r - l) / 2; if(reader.</description></item><item><title>704. Binary Search</title><link>https://jackeryli.github.io/leetcode/binary-search/0704/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/0704/</guid><description>class Solution { public: int search(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int left = 0; int right = nums.size()-1; while(left &amp;lt;= right){ int mid = left + (right - left) / 2; if(nums[mid] == target) { return mid; } else if(target &amp;gt; nums[mid]) { left = mid + 1; } else { right = mid - 1; } } return -1; } };</description></item><item><title>74. Search a 2D Matrix</title><link>https://jackeryli.github.io/leetcode/binary-search/0074/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/0074/</guid><description>class Solution { public: bool searchMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix, int target) { int m = matrix.size(); int n = matrix[0].size(); int left = 0; int right = m*n - 1; int mid; while(left &amp;lt;= right){ mid = left + (right - left) / 2; int row = mid / n; int col = mid % n; if(matrix[row][col] == target) return true; else if(target &amp;gt; matrix[row][col]){ left = mid + 1; } else { right = mid - 1; } } return false; } };</description></item><item><title>744. Find Smallest Letter Greater Than Target</title><link>https://jackeryli.github.io/leetcode/binary-search/0744/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/0744/</guid><description>class Solution { public: char nextGreatestLetter(vector&amp;lt;char&amp;gt;&amp;amp; letters, char target) { int left = 0; int right = letters.size() - 1; int mid; while(left &amp;lt;= right){ mid = left + (right - left) / 2; if(letters[mid] &amp;lt;= target){ left = mid + 1; } else { right = mid - 1; } } return left == letters.size() ? letters[0] : letters[left]; } };</description></item><item><title>852. Peak Index in a Mountatin Array</title><link>https://jackeryli.github.io/leetcode/binary-search/0852/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/0852/</guid><description>class Solution { public: int peakIndexInMountainArray(vector&amp;lt;int&amp;gt;&amp;amp; arr) { int l = 0; int r = arr.size() - 1; int mid; // Use l &amp;lt; r rather than l &amp;lt;= r because I want to stop at l == r // Seems like no effect in this question while(l &amp;lt; r){ mid = l + (r - l) / 2; // Current is peak if left and right are smaller than mid if(arr[mid-1] &amp;lt; arr[mid] &amp;amp;&amp;amp; arr[mid] &amp;gt; arr[mid+1]){ return mid; } // Only move to mid to avoid illegal condition if(arr[mid-1] &amp;lt; arr[mid]){ l = mid; } else { r = mid; } } return l; } };</description></item><item><title>875. Koko Eating Bananas</title><link>https://jackeryli.github.io/leetcode/binary-search/0875/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/0875/</guid><description>If we set l &amp;lt; r and r = m
state n-1 3 4 5 6 7 l r m state n 3 4 5 6 7 l r class Solution { public: int minEatingSpeed(vector&amp;lt;int&amp;gt;&amp;amp; piles, int h) { int l = 1; int r = *max_element(piles.begin(), piles.end()); int m; long long hours; while(l &amp;lt;= r){ m = l + (r - l) / 2; hours = 0; for(int&amp;amp; pile : piles){ hours += ((pile / m) + (pile % m !</description></item></channel></rss>