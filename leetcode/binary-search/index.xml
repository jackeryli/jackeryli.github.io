<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title/><link>https://jackeryli.github.io/leetcode/binary-search/</link><description>Recent content on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://jackeryli.github.io/leetcode/binary-search/index.xml" rel="self" type="application/rss+xml"/><item><title>1011. Capacity To Ship Packages Within D Days</title><link>https://jackeryli.github.io/leetcode/binary-search/1011/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/1011/</guid><description>class Solution { public: int countShipDays(vector&amp;lt;int&amp;gt;&amp;amp; weights, int capacity){ int usedDays = 1; int current = capacity; for(int&amp;amp; weight : weights){ if(weight &amp;gt; capacity){ return INT_MAX; } if(current &amp;gt;= weight){ current -= weight; } else { usedDays++; current = capacity - weight; } } return usedDays; } int shipWithinDays(vector&amp;lt;int&amp;gt;&amp;amp; weights, int days) { int l = 0; int r = *max_element(weights.begin(), weights.end()); int usedDays; int mid; while(l &amp;lt; r){ usedDays = countShipDays(weights, r); if(usedDays &amp;lt;= days) break; l = r; r = r &amp;lt;&amp;lt; 1; } while(l &amp;lt;= r){ mid = l + (r - l) / 2; usedDays = countShipDays(weights, mid); if(usedDays == days){ r = mid-1; } else if(usedDays &amp;gt; days){ l = mid + 1; } else { r = mid-1; } } return l; } };</description></item><item><title>1351. Count Negative Numbers in a Sorted Matrix</title><link>https://jackeryli.github.io/leetcode/binary-search/1351/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/1351/</guid><description>class Solution { public: int binarySearch(vector&amp;lt;int&amp;gt;&amp;amp; arr){ int left = 0; int right = arr.size() - 1; int mid; while(left &amp;lt;= right){ mid = left + (right - left) / 2; if(arr[mid] &amp;gt;= 0){ left = mid + 1; } else { right = mid - 1; } } return arr.size() - left; } int countNegatives(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) { int m = grid.size(); int n = grid[0].size(); int ans = 0; for(auto&amp;amp; arr: grid){ ans += binarySearch(arr); } return ans; } }; class Solution { public: int countNegatives(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) { int m = grid.</description></item><item><title>34. Find First and Last Position of Element in Sorted Array</title><link>https://jackeryli.github.io/leetcode/binary-search/34/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/34/</guid><description>class Solution { public: int binarySearch(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target, bool isSame){ int left = 0; int right = nums.size() - 1; int mid; int index = -1; while(left &amp;lt;= right){ mid = left + (right - left) / 2; if(nums[mid] == target){ index = mid; if(isSame) right = mid - 1; else left = mid + 1; } else if (nums[mid] &amp;gt; target){ right = mid - 1; } else { left = mid + 1; } } return index; } vector&amp;lt;int&amp;gt; searchRange(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int left = binarySearch(nums, target, true); if(left == -1) return {-1, -1}; int right = binarySearch(nums, target, false); return {left, right}; } };</description></item><item><title>35. Search Insert Position</title><link>https://jackeryli.github.io/leetcode/binary-search/35/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/35/</guid><description>class Solution { public: int searchInsert(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int left = 0; int right = nums.size() - 1; while(left &amp;lt;= right){ int mid = left + (right - left) / 2; if(target == nums[mid]){ return mid; } else if (target &amp;gt; nums[mid]){ left = mid + 1; } else { right = mid - 1; } } return left; } };</description></item><item><title>436. Find Right Interval</title><link>https://jackeryli.github.io/leetcode/binary-search/436/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/436/</guid><description>class Solution { public: int binarySearch(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; intervals, int target){ int left = 0; int right = intervals.size() - 1; int mid; // [[1,4], [2,3], [6,7]] while(left &amp;lt;= right){ mid = left + (right - left) / 2; if(target == intervals[mid][0]){ right = mid - 1; } else if (target &amp;gt; intervals[mid][0]){ left = mid + 1; } else { right = mid - 1; } } return left == intervals.size() ?</description></item><item><title>611. Valid Triangle Number</title><link>https://jackeryli.github.io/leetcode/binary-search/611/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/611/</guid><description>class Solution { public: int binarySearch(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target, int left){ // find the number that smaller than a + b // for example: 2 2 3 3 4 4 // final: r l // return (l - left) number are smaller than a + b int l = left; int r = nums.size() - 1; int mid; while(l &amp;lt;= r){ mid = l + (r - l) / 2; if(nums[mid] == target){ r = mid - 1; } else if(nums[mid] &amp;gt; target){ r = mid - 1; } else { l = mid + 1; } } return l - left; } int triangleNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.</description></item><item><title>702. Search in a Sorted Array of Unknown Size</title><link>https://jackeryli.github.io/leetcode/binary-search/702/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/702/</guid><description>/** * // This is the ArrayReader&amp;#39;s API interface. * // You should not implement it, or speculate about its implementation * class ArrayReader { * public: * int get(int index); * }; */ class Solution { public: int search(const ArrayReader&amp;amp; reader, int target) { int l = 0; int r = 1; int mid; int num; // Find right most point which covered by 2^right-1 and 2^right while(reader.get(r) != INT_MAX){ l = r; r = r &amp;lt;&amp;lt; 1; } // Find right most point while(l &amp;lt;= r){ mid = l + (r - l) / 2; if(reader.</description></item><item><title>704. Binary Search</title><link>https://jackeryli.github.io/leetcode/binary-search/704/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/704/</guid><description>class Solution { public: int search(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target) { int left = 0; int right = nums.size()-1; while(left &amp;lt;= right){ int mid = left + (right - left) / 2; if(nums[mid] == target) { return mid; } else if(target &amp;gt; nums[mid]) { left = mid + 1; } else { right = mid - 1; } } return -1; } };</description></item><item><title>74. Search a 2D Matrix</title><link>https://jackeryli.github.io/leetcode/binary-search/74/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/74/</guid><description>class Solution { public: bool searchMatrix(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; matrix, int target) { int m = matrix.size(); int n = matrix[0].size(); int left = 0; int right = m*n - 1; int mid; while(left &amp;lt;= right){ mid = left + (right - left) / 2; int row = mid / n; int col = mid % n; if(matrix[row][col] == target) return true; else if(target &amp;gt; matrix[row][col]){ left = mid + 1; } else { right = mid - 1; } } return false; } };</description></item><item><title>744. Find Smallest Letter Greater Than Target</title><link>https://jackeryli.github.io/leetcode/binary-search/744/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/744/</guid><description>class Solution { public: char nextGreatestLetter(vector&amp;lt;char&amp;gt;&amp;amp; letters, char target) { int left = 0; int right = letters.size() - 1; int mid; while(left &amp;lt;= right){ mid = left + (right - left) / 2; if(letters[mid] &amp;lt;= target){ left = mid + 1; } else { right = mid - 1; } } return left == letters.size() ? letters[0] : letters[left]; } };</description></item><item><title>852. Peak Index in a Mountatin Array</title><link>https://jackeryli.github.io/leetcode/binary-search/852/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/852/</guid><description>class Solution { public: int peakIndexInMountainArray(vector&amp;lt;int&amp;gt;&amp;amp; arr) { int l = 0; int r = arr.size() - 1; int mid; // Use l &amp;lt; r rather than l &amp;lt;= r because I want to stop at l == r // Seems like no effect in this question while(l &amp;lt; r){ mid = l + (r - l) / 2; // Current is peak if left and right are smaller than mid if(arr[mid-1] &amp;lt; arr[mid] &amp;amp;&amp;amp; arr[mid] &amp;gt; arr[mid+1]){ return mid; } // Only move to mid to avoid illegal condition if(arr[mid-1] &amp;lt; arr[mid]){ l = mid; } else { r = mid; } } return l; } };</description></item><item><title>875. Koko Eating Bananas</title><link>https://jackeryli.github.io/leetcode/binary-search/875/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-search/875/</guid><description>If we set l &amp;lt; r and r = m
state n-1 3 4 5 6 7 l r m state n 3 4 5 6 7 l r class Solution { public: int minEatingSpeed(vector&amp;lt;int&amp;gt;&amp;amp; piles, int h) { int l = 1; int r = *max_element(piles.begin(), piles.end()); int m; long long hours; while(l &amp;lt;= r){ m = l + (r - l) / 2; hours = 0; for(int&amp;amp; pile : piles){ hours += ((pile / m) + (pile % m !</description></item></channel></rss>