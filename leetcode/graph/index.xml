<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title/><link>https://jackeryli.github.io/leetcode/graph/</link><description>Recent content on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://jackeryli.github.io/leetcode/graph/index.xml" rel="self" type="application/rss+xml"/><item><title>0133.Clone Graph</title><link>https://jackeryli.github.io/leetcode/graph/0133/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/graph/0133/</guid><description>DFS # class Solution { public: unordered_map&amp;lt;int, Node*&amp;gt; visited; Node* cloneGraph(Node* node) { if(node == nullptr) return nullptr; if(visited.find(node-&amp;gt;val) != visited.end()) { return visited[node-&amp;gt;val]; } Node* newNode = new Node(node-&amp;gt;val); visited[node-&amp;gt;val] = newNode; for(auto neighbor : node-&amp;gt;neighbors) { newNode-&amp;gt;neighbors.emplace_back(cloneGraph(neighbor)); } return newNode; } }; BFS # class Solution { public: Node* cloneGraph(Node* node) { if(node == nullptr) return nullptr; queue&amp;lt;Node*&amp;gt; que; unordered_map&amp;lt;int, Node*&amp;gt; visited; Node* newNode = new Node(node-&amp;gt;val); visited[node-&amp;gt;val] = newNode; que.</description></item><item><title>0200.Number of Islands</title><link>https://jackeryli.github.io/leetcode/graph/0200/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/graph/0200/</guid><description>DFS # class Solution { public: void dfs(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; grid, int i, int j) { if(i &amp;lt; 0 || i &amp;gt;= grid.size() || j &amp;lt; 0 || j &amp;gt;= grid[0].size() || grid[i][j] != &amp;#39;1&amp;#39;) return; grid[i][j] = &amp;#39;2&amp;#39;; dfs(grid, i+1, j); dfs(grid, i-1, j); dfs(grid, i, j+1); dfs(grid, i, j-1); } int numIslands(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; grid) { int m = grid.size(); int n = grid[0].size(); int result = 0; for(int i = 0; i &amp;lt; m; i++) { for(int j = 0; j &amp;lt; n; j++) { if(grid[i][j] == &amp;#39;1&amp;#39;) { result++; dfs(grid, i, j); } } } return result; } }; BFS # class Solution { public: int numIslands(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; grid) { int result = 0; int m = grid.</description></item><item><title>0797.All Paths From Source to Target</title><link>https://jackeryli.github.io/leetcode/graph/0797/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/graph/0797/</guid><description>class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result; vector&amp;lt;int&amp;gt; path; void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; graph, int current) { if(current == graph.size() - 1) { result.emplace_back(path); return; } for(int i = 0; i &amp;lt; graph[current].size(); i++) { path.emplace_back(graph[current][i]); dfs(graph, graph[current][i]); path.pop_back(); } } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; allPathsSourceTarget(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; graph) { path.emplace_back(0); dfs(graph, 0); return result; } };</description></item><item><title>130.Surrounded Regions</title><link>https://jackeryli.github.io/leetcode/graph/0130/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/graph/0130/</guid><description> DFS # class Solution { public: void dfs(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board, int i, int j, char c) { if(i &amp;lt; 0 || i &amp;gt;= board.size() || j &amp;lt; 0 || j &amp;gt;= board[0].size() || board[i][j] != &amp;#39;O&amp;#39;) return; board[i][j] = c; dfs(board, i-1, j, c); dfs(board, i+1, j, c); dfs(board, i, j-1, c); dfs(board, i, j+1, c); } void solve(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board) { int m = board.size(); int n = board[0].size(); for(int i = 0; i &amp;lt; m; i++) { if(board[i][0] == &amp;#39;O&amp;#39;) dfs(board, i , 0, &amp;#39;A&amp;#39;); if(board[i][n-1] == &amp;#39;O&amp;#39;) dfs(board, i, n-1, &amp;#39;A&amp;#39;); } for(int j = 0; j &amp;lt; n; j++) { if(board[0][j] == &amp;#39;O&amp;#39;) dfs(board, 0, j, &amp;#39;A&amp;#39;); if(board[m-1][j] == &amp;#39;O&amp;#39;) dfs(board, m-1, j, &amp;#39;A&amp;#39;); } for(int i = 0; i &amp;lt; m; i++) { for(int j = 0; j &amp;lt; n; j++) { if(board[i][j] == &amp;#39;O&amp;#39;) { board[i][j] = &amp;#39;X&amp;#39;; } if(board[i][j] == &amp;#39;A&amp;#39;) { board[i][j] = &amp;#39;O&amp;#39;; } } } } };</description></item></channel></rss>