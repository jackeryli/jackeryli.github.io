<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title/><link>https://jackeryli.github.io/leetcode/graph/</link><description>Recent content on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://jackeryli.github.io/leetcode/graph/index.xml" rel="self" type="application/rss+xml"/><item><title>0133.Clone Graph</title><link>https://jackeryli.github.io/leetcode/graph/0133/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/graph/0133/</guid><description>DFS # class Solution { public: unordered_map&amp;lt;int, Node*&amp;gt; visited; Node* cloneGraph(Node* node) { if(node == nullptr) return nullptr; if(visited.find(node-&amp;gt;val) != visited.end()) { return visited[node-&amp;gt;val]; } Node* newNode = new Node(node-&amp;gt;val); visited[node-&amp;gt;val] = newNode; for(auto neighbor : node-&amp;gt;neighbors) { newNode-&amp;gt;neighbors.emplace_back(cloneGraph(neighbor)); } return newNode; } }; BFS # class Solution { public: Node* cloneGraph(Node* node) { if(node == nullptr) return nullptr; queue&amp;lt;Node*&amp;gt; que; unordered_map&amp;lt;int, Node*&amp;gt; visited; Node* newNode = new Node(node-&amp;gt;val); visited[node-&amp;gt;val] = newNode; que.</description></item><item><title>0200.Number of Islands</title><link>https://jackeryli.github.io/leetcode/graph/0200/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/graph/0200/</guid><description>DFS # Time Complexity: O(M*N) Space Complexity: O(M*N) class Solution { public: void dfs(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; grid, int i, int j) { if(i &amp;lt; 0 || i &amp;gt;= grid.size() || j &amp;lt; 0 || j &amp;gt;= grid[0].size() || grid[i][j] != &amp;#39;1&amp;#39;) return; grid[i][j] = &amp;#39;2&amp;#39;; dfs(grid, i+1, j); dfs(grid, i-1, j); dfs(grid, i, j+1); dfs(grid, i, j-1); } int numIslands(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; grid) { int m = grid.size(); int n = grid[0].size(); int result = 0; for(int i = 0; i &amp;lt; m; i++) { for(int j = 0; j &amp;lt; n; j++) { if(grid[i][j] == &amp;#39;1&amp;#39;) { result++; dfs(grid, i, j); } } } return result; } }; BFS # Time Complexity: O(M*N) Space Complexity: class Solution { public: int numIslands(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; grid) { int result = 0; int m = grid.</description></item><item><title>0207.Course Schedule</title><link>https://jackeryli.github.io/leetcode/graph/0207/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/graph/0207/</guid><description>DFS # Draw colors
0: unvisited 1: visiting 2: visited class Solution { public: bool isCycle(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; graph, vector&amp;lt;int&amp;gt;&amp;amp; visited, int current) { if(visited[current] == 1) return true; if(visited[current] == 2) return false; visited[current] = 1; for(int&amp;amp; edge : graph[current]) { if(isCycle(graph, visited, edge) == true) return true; } visited[current] = 2; return false; } bool canFinish(int numCourses, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; prerequisites) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; graph(numCourses, vector&amp;lt;int&amp;gt;(0)); // Establish graph for(auto pre : prerequisites) { graph[pre[1]].</description></item><item><title>0210. Course Schedule II</title><link>https://jackeryli.github.io/leetcode/graph/0201/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/graph/0201/</guid><description>class Solution { public: vector&amp;lt;int&amp;gt; findOrder(int numCourses, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; prerequisites) { vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; graph(numCourses); vector&amp;lt;int&amp;gt; indegree(numCourses); vector&amp;lt;int&amp;gt; result; queue&amp;lt;int&amp;gt; que; for(auto&amp;amp; pre : prerequisites) { graph[pre[1]].push_back(pre[0]); indegree[pre[0]]++; } for(int i = 0; i &amp;lt; numCourses; i++) { if(indegree[i] == 0) que.push(i); } if(que.empty() == true) return {}; int nodeVisited = 0; while(que.empty() == false) { int current = que.front(); que.pop(); nodeVisited++; result.push_back(current); for(auto&amp;amp; edge : graph[current]) { indegree[edge]--; if(indegree[edge] == 0) que.push(edge); } } if(nodeVisited !</description></item><item><title>0695. Max Area of Island</title><link>https://jackeryli.github.io/leetcode/graph/0695/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/graph/0695/</guid><description>DFS # class Solution { public: int space; int result = 0; void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid, int i, int j) { if(i &amp;lt; 0 || i &amp;gt;= grid.size() || j &amp;lt; 0 || j &amp;gt;= grid[0].size() || grid[i][j] != 1) return; grid[i][j] = 2; space++; dfs(grid, i+1, j); dfs(grid, i-1, j); dfs(grid, i, j-1); dfs(grid, i, j+1); } int maxAreaOfIsland(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; grid) { for(int i = 0; i &amp;lt; grid.size(); i++) { for(int j = 0; j &amp;lt; grid[0].</description></item><item><title>0797.All Paths From Source to Target</title><link>https://jackeryli.github.io/leetcode/graph/0797/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/graph/0797/</guid><description>class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result; vector&amp;lt;int&amp;gt; path; void dfs(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; graph, int current) { if(current == graph.size() - 1) { result.emplace_back(path); return; } for(int i = 0; i &amp;lt; graph[current].size(); i++) { path.emplace_back(graph[current][i]); dfs(graph, graph[current][i]); path.pop_back(); } } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; allPathsSourceTarget(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; graph) { path.emplace_back(0); dfs(graph, 0); return result; } };</description></item><item><title>130.Surrounded Regions</title><link>https://jackeryli.github.io/leetcode/graph/0130/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/graph/0130/</guid><description> DFS # class Solution { public: void dfs(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board, int i, int j, char c) { if(i &amp;lt; 0 || i &amp;gt;= board.size() || j &amp;lt; 0 || j &amp;gt;= board[0].size() || board[i][j] != &amp;#39;O&amp;#39;) return; board[i][j] = c; dfs(board, i-1, j, c); dfs(board, i+1, j, c); dfs(board, i, j-1, c); dfs(board, i, j+1, c); } void solve(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board) { int m = board.size(); int n = board[0].size(); for(int i = 0; i &amp;lt; m; i++) { if(board[i][0] == &amp;#39;O&amp;#39;) dfs(board, i , 0, &amp;#39;A&amp;#39;); if(board[i][n-1] == &amp;#39;O&amp;#39;) dfs(board, i, n-1, &amp;#39;A&amp;#39;); } for(int j = 0; j &amp;lt; n; j++) { if(board[0][j] == &amp;#39;O&amp;#39;) dfs(board, 0, j, &amp;#39;A&amp;#39;); if(board[m-1][j] == &amp;#39;O&amp;#39;) dfs(board, m-1, j, &amp;#39;A&amp;#39;); } for(int i = 0; i &amp;lt; m; i++) { for(int j = 0; j &amp;lt; n; j++) { if(board[i][j] == &amp;#39;O&amp;#39;) { board[i][j] = &amp;#39;X&amp;#39;; } if(board[i][j] == &amp;#39;A&amp;#39;) { board[i][j] = &amp;#39;O&amp;#39;; } } } } };</description></item></channel></rss>