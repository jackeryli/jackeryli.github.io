<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title/><link>https://jackeryli.github.io/leetcode/binary-tree/</link><description>Recent content on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://jackeryli.github.io/leetcode/binary-tree/index.xml" rel="self" type="application/rss+xml"/><item><title>0100.Same Tree</title><link>https://jackeryli.github.io/leetcode/binary-tree/0100/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-tree/0100/</guid><description>class Solution { public: bool isSameTree(TreeNode* p, TreeNode* q) { if(p == nullptr &amp;amp;&amp;amp; q == nullptr) return true; if(p == nullptr || q == nullptr) return false; if(p-&amp;gt;val != q-&amp;gt;val) return false; return isSameTree(p-&amp;gt;left, q-&amp;gt;left) &amp;amp;&amp;amp; isSameTree(p-&amp;gt;right, q-&amp;gt;right); } };</description></item><item><title>0104. Maximum Depth of Binary Tree</title><link>https://jackeryli.github.io/leetcode/binary-tree/0104/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-tree/0104/</guid><description>class Solution { public: int maxDepth(TreeNode* root) { if(root == nullptr) return 0; return max(maxDepth(root-&amp;gt;left), maxDepth(root-&amp;gt;right)) + 1; } };</description></item></channel></rss>