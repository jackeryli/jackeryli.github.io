<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title/><link>https://jackeryli.github.io/leetcode/binary-tree/</link><description>Recent content on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://jackeryli.github.io/leetcode/binary-tree/index.xml" rel="self" type="application/rss+xml"/><item><title>0100.Same Tree</title><link>https://jackeryli.github.io/leetcode/binary-tree/0100/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-tree/0100/</guid><description>class Solution { public: bool isSameTree(TreeNode* p, TreeNode* q) { if(p == nullptr &amp;amp;&amp;amp; q == nullptr) return true; if(p == nullptr || q == nullptr) return false; if(p-&amp;gt;val != q-&amp;gt;val) return false; return isSameTree(p-&amp;gt;left, q-&amp;gt;left) &amp;amp;&amp;amp; isSameTree(p-&amp;gt;right, q-&amp;gt;right); } };</description></item><item><title>0101.Symmetric Tree</title><link>https://jackeryli.github.io/leetcode/binary-tree/0101/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-tree/0101/</guid><description>Recursive # class Solution { public: bool compare(TreeNode* left, TreeNode* right) { if(left == nullptr &amp;amp;&amp;amp; right == nullptr) return true; if(left != nullptr &amp;amp;&amp;amp; right == nullptr) return false; if(left == nullptr &amp;amp;&amp;amp; right != nullptr) return false; if(left-&amp;gt;val != right-&amp;gt;val) return false; bool c1 = compare(left-&amp;gt;left, right-&amp;gt;right); bool c2 = compare(left-&amp;gt;right, right-&amp;gt;left); return c1 &amp;amp;&amp;amp; c2; } bool isSymmetric(TreeNode* root) { if(root == nullptr) return true; return compare(root-&amp;gt;left, root-&amp;gt;right); } }; Queue # class Solution { public: bool isSymmetric(TreeNode* root) { if(root == nullptr) return true; queue&amp;lt;TreeNode*&amp;gt; que; que.</description></item><item><title>0104. Maximum Depth of Binary Tree</title><link>https://jackeryli.github.io/leetcode/binary-tree/0104/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-tree/0104/</guid><description>class Solution { public: int maxDepth(TreeNode* root) { if(root == nullptr) return 0; return max(maxDepth(root-&amp;gt;left), maxDepth(root-&amp;gt;right)) + 1; } };</description></item><item><title>0105.Construct Binary Tree from Preorder and Inorder Traversal</title><link>https://jackeryli.github.io/leetcode/binary-tree/0105/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-tree/0105/</guid><description>struct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode() : val(0), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {} }; class Solution { public: TreeNode* traverse(vector&amp;lt;int&amp;gt;&amp;amp; preorder, vector&amp;lt;int&amp;gt;&amp;amp; inorder, int pl, int pr, int il, int ir) { if(pl == pr) return nullptr; TreeNode* root = new TreeNode(preorder[pl]); if(pr - pl == 1) return root; int delimeter = 0; for(delimeter = il; delimeter &amp;lt; ir; delimeter++) { if(inorder[delimeter] == preorder[pl]) { break; } } root-&amp;gt;left = traverse(preorder, inorder, pl+1, pl+1+delimeter-il, il, delimeter); root-&amp;gt;right = traverse(preorder, inorder, pl+1+delimeter-il, pr, delimeter+1, ir); return root; } TreeNode* buildTree(vector&amp;lt;int&amp;gt;&amp;amp; preorder, vector&amp;lt;int&amp;gt;&amp;amp; inorder) { if(preorder.</description></item><item><title>0106.Construct Binary Tree from Inorder and Postorder Traversal</title><link>https://jackeryli.github.io/leetcode/binary-tree/0106/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-tree/0106/</guid><description>struct TreeNode { int val; TreeNode* left; TreeNode* right; TreeNode() : val(-1), left(nullptr), right(nullptr) {} TreeNode(int x) : val(x), left(nullptr), right(nullptr) {} TreeNode(int x, TreeNode* left, TreeNode* right) : val(x), left(left), right(right) {} }; class Solution { public: TreeNode* traverse(vector&amp;lt;int&amp;gt;&amp;amp; inorder, vector&amp;lt;int&amp;gt;&amp;amp; postorder, int inorderBegin, int inorderEnd, int postorderBegin, int postorderEnd) { if(postorderBegin == postorderEnd) return nullptr; TreeNode* root = new TreeNode(postorder[postorderEnd-1]); if(postorderEnd - postorderBegin == 1) return root; int delimeter = 0; for(delimeter = inorderBegin; delimeter &amp;lt; inorderEnd; delimeter++) { if(inorder[delimeter] == root-&amp;gt;val) break; } root-&amp;gt;left = traverse(inorder, postorder, inorderBegin, delimeter, postorderBegin, postorderBegin + (delimeter - inorderBegin)); root-&amp;gt;right = traverse(inorder, postorder, delimeter + 1, inorderEnd, postorderBegin + (delimeter - inorderBegin), postorderEnd-1); return root; } TreeNode* buildTree(vector&amp;lt;int&amp;gt;&amp;amp; inorder, vector&amp;lt;int&amp;gt;&amp;amp; postorder) { if(inorder.</description></item><item><title>0112.Path Sum</title><link>https://jackeryli.github.io/leetcode/binary-tree/0112/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-tree/0112/</guid><description>Recursive # class Solution { public: bool traverse(TreeNode* root, int targetSum, int currentSum) { if(root == nullptr) return false; currentSum += root-&amp;gt;val; if(root-&amp;gt;left == nullptr &amp;amp;&amp;amp; root-&amp;gt;right == nullptr) { return currentSum == targetSum; } return traverse(root-&amp;gt;left, targetSum, currentSum) || traverse(root-&amp;gt;right, targetSum, currentSum); } bool hasPathSum(TreeNode* root, int targetSum) { if(root == nullptr) return false; return traverse(root, targetSum, 0); } }; Stack # class Solution { public: bool hasPathSum(TreeNode* root, int targetSum) { if(root == nullptr) return false; stack&amp;lt;pair&amp;lt;TreeNode*, int&amp;gt;&amp;gt; sta; sta.</description></item><item><title>0114. Flatten Binary Tree to Linked List</title><link>https://jackeryli.github.io/leetcode/binary-tree/0114/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-tree/0114/</guid><description>Recursion # class Solution { public: TreeNode* traverse(TreeNode* root) { if(root == nullptr) return nullptr; if(root-&amp;gt;left == nullptr &amp;amp;&amp;amp; root-&amp;gt;right == nullptr) { return root; } TreeNode* leftTail = traverse(root-&amp;gt;left); TreeNode* rightTail = traverse(root-&amp;gt;right); if(leftTail != nullptr) { leftTail-&amp;gt;right = root-&amp;gt;right; root-&amp;gt;right = root-&amp;gt;left; root-&amp;gt;left = nullptr; } return rightTail != nullptr ? rightTail : leftTail; } void flatten(TreeNode* root) { if(root == nullptr) return; traverse(root); } }; Linkedlist # class Solution { public: void flatten(TreeNode* root) { if(root == nullptr) return; TreeNode* node = root; while(node !</description></item><item><title>0117.Populating Next Right Pointers in Each Node</title><link>https://jackeryli.github.io/leetcode/binary-tree/0117/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-tree/0117/</guid><description>Level Order Traversal # Time Comlexity: O(n) Space Complexity: O(n) class Solution { public: Node* connect(Node* root) { if(root == nullptr) return nullptr; queue&amp;lt;Node*&amp;gt; que; que.push(root); while(!que.empty()) { int size = que.size(); Node* node = que.front(); if(que.front()-&amp;gt;left != nullptr) que.push(que.front()-&amp;gt;left); if(que.front()-&amp;gt;right != nullptr) que.push(que.front()-&amp;gt;right); que.pop(); for(int i = 1; i &amp;lt; size; i++){ node-&amp;gt;next = que.front(); node = que.front(); if(que.front()-&amp;gt;left != nullptr) que.push(que.front()-&amp;gt;left); if(que.front()-&amp;gt;right != nullptr) que.push(que.front()-&amp;gt;right); que.pop(); } } return root; } }; Linkedlist # Time Complexity: O(n) Space Complexity: O(1) class Solution { public: Node* prev; Node* leftmost; void processChild(Node* childNode) { if(childNode !</description></item><item><title>0129. Sum Root to Leaf Numbers</title><link>https://jackeryli.github.io/leetcode/binary-tree/0129/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-tree/0129/</guid><description>Recursion # class Solution { public: int result = 0; void traverse(TreeNode* root, int sum) { if(root == nullptr) return; int newSum = sum + root-&amp;gt;val; if(root-&amp;gt;left == nullptr &amp;amp;&amp;amp; root-&amp;gt;right == nullptr) { // leaf, add sum to result result += newSum; return; } newSum *= 10; if(root-&amp;gt;left != nullptr) traverse(root-&amp;gt;left, newSum); if(root-&amp;gt;right != nullptr) traverse(root-&amp;gt;right, newSum); } int sumNumbers(TreeNode* root) { traverse(root, 0); return result; } }; Stack # class Solution { public: int sumNumbers(TreeNode* root) { if(root == nullptr) return 0; int result = 0; int currentSum = 0; stack&amp;lt;pair&amp;lt;TreeNode*,int&amp;gt;&amp;gt; sta; sta.</description></item><item><title>0222.Count Complete Tree Nodes</title><link>https://jackeryli.github.io/leetcode/binary-tree/0222/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-tree/0222/</guid><description>class Solution { public: int countNodes(TreeNode* root) { if(root == nullptr) return 0; return countNodes(root-&amp;gt;left) + countNodes(root-&amp;gt;right) + 1; } };</description></item><item><title>0226.Invert Binary Tree</title><link>https://jackeryli.github.io/leetcode/binary-tree/0226/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-tree/0226/</guid><description> Recursive # class Solution { public: TreeNode* invertTree(TreeNode* root) { if(root == nullptr) return nullptr; swap(root-&amp;gt;left, root-&amp;gt;right); invertTree(root-&amp;gt;left); invertTree(root-&amp;gt;right); return root; } }; Stack # class Solution { public: TreeNode* invertTree(TreeNode* root) { if(root == nullptr) return nullptr; stack&amp;lt;TreeNode*&amp;gt; sta; sta.push(root); while(!sta.empty()){ TreeNode* node = sta.top(); sta.pop(); swap(node-&amp;gt;left, node-&amp;gt;right); if(node-&amp;gt;right != nullptr) sta.push(node-&amp;gt;right); if(node-&amp;gt;left != nullptr) sta.push(node-&amp;gt;left); } return root; } };</description></item><item><title>0236. Lowest Common Ancestor of a Binary Tree</title><link>https://jackeryli.github.io/leetcode/binary-tree/0236/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/binary-tree/0236/</guid><description>class Solution { public: TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) { if(root == nullptr) return nullptr; if(root == p || root == q) return root; TreeNode* left = lowestCommonAncestor(root-&amp;gt;left, p, q); TreeNode* right = lowestCommonAncestor(root-&amp;gt;right, p, q); if(left != nullptr &amp;amp;&amp;amp; right != nullptr) { return root; } return left != nullptr ? left : right; } };</description></item></channel></rss>