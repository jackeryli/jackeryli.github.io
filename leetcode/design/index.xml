<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title/><link>https://jackeryli.github.io/leetcode/design/</link><description>Recent content on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://jackeryli.github.io/leetcode/design/index.xml" rel="self" type="application/rss+xml"/><item><title>0146.LRU Cache</title><link>https://jackeryli.github.io/leetcode/design/0146/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/design/0146/</guid><description>struct Node { int key; int val; Node* next; Node* prev; Node(int key, int val) : key(key), val(val), next(nullptr), prev(nullptr){} }; class LRUCache { public: int cap; Node* head = new Node(-1, -1); Node* tail = new Node(-1, -1); unordered_map&amp;lt;int, Node*&amp;gt; kv; LRUCache(int capacity) { this-&amp;gt;cap = capacity; head-&amp;gt;next = tail; tail-&amp;gt;prev = head; } void removeNode(Node* curr) { // prev -&amp;gt; curr -&amp;gt; next; Node* prev = curr-&amp;gt;prev; Node* next = curr-&amp;gt;next; prev-&amp;gt;next = next; next-&amp;gt;prev = prev; } void addNode(Node* curr) { // head -&amp;gt; next; Node* next = head-&amp;gt;next; head-&amp;gt;next = curr; curr-&amp;gt;prev = head; curr-&amp;gt;next = next; next-&amp;gt;prev = curr; } // If not found, return -1 // If found, // 1.</description></item></channel></rss>