<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title/><link>https://jackeryli.github.io/leetcode/dp/</link><description>Recent content on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://jackeryli.github.io/leetcode/dp/index.xml" rel="self" type="application/rss+xml"/><item><title>0063. Unique Path II</title><link>https://jackeryli.github.io/leetcode/dp/0063/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/dp/0063/</guid><description>class Solution { public: int uniquePathsWithObstacles(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; obstacleGrid) { int m = obstacleGrid.size(); int n = obstacleGrid[0].size(); int dp[m][n]; memset(dp, 0, sizeof(dp)); for(int i = 0; i &amp;lt; m &amp;amp;&amp;amp; obstacleGrid[i][0] == 0; i++) dp[i][0] = 1; for(int j = 0; j &amp;lt; n &amp;amp;&amp;amp; obstacleGrid[0][j] == 0; j++) dp[0][j] = 1; for(int i = 1; i &amp;lt; m; i++) { for(int j = 1; j &amp;lt; n; j++) { if(obstacleGrid[i][j] !</description></item><item><title>0279. Perfect Squares</title><link>https://jackeryli.github.io/leetcode/dp/0279/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/dp/0279/</guid><description>class Solution { public: int numSquares(int n) { // dp[i] = least number of perfect square numbers vector&amp;lt;int&amp;gt; dp(n+1, 10001); dp[0] = 0; for(int i = 0; i &amp;lt;= n; i++) { for(int j = 1; j * j &amp;lt;= i; j++) { dp[i] = min(dp[i], dp[i - j*j] + 1); } } return dp[n] == 10001 ? 0 : dp[n]; } };</description></item><item><title>0322. Coin Change</title><link>https://jackeryli.github.io/leetcode/dp/0322/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/dp/0322/</guid><description>class Solution { public: int coinChange(vector&amp;lt;int&amp;gt;&amp;amp; coins, int amount) { // dp[j]: fewest number of coins to make amount=j // dp[j] = min(dp[j], dp[j - coins[i]] + 1) // max will be amount+1 because the min value of coin is 1 // only possible amount of coins is amount vector&amp;lt;int&amp;gt; dp(amount+1, amount+1); dp[0] = 0; for(int coin : coins) { for(int j = coin; j &amp;lt;= amount; j++) { dp[j] = min(dp[j], dp[j - coin] + 1); } } if(dp[amount] &amp;gt; amount) return -1; return dp[amount]; } };</description></item><item><title>0518. Coin Change II</title><link>https://jackeryli.github.io/leetcode/dp/0518/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/dp/0518/</guid><description>class Solution { public: int change(int amount, vector&amp;lt;int&amp;gt;&amp;amp; coins) { // dp[j] = number of combination to make amount = j int dp[amount+1]; memset(dp, 0, sizeof(dp)); dp[0] = 1; for(int coin : coins) { for(int j = coin; j &amp;lt;= amount; j++) { dp[j] += dp[j - coin]; } } return dp[amount]; } };</description></item></channel></rss>