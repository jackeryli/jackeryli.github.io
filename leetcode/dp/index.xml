<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title/><link>https://jackeryli.github.io/leetcode/dp/</link><description>Recent content on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://jackeryli.github.io/leetcode/dp/index.xml" rel="self" type="application/rss+xml"/><item><title>0053.Maximum Subarray</title><link>https://jackeryli.github.io/leetcode/dp/0053/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/dp/0053/</guid><description>DP # class Solution { public: int maxSubArray(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.size(); // dp[i]: subarray with largest sum end at i vector&amp;lt;int&amp;gt; dp(n); int result = nums[0]; dp[0] = nums[0]; for(int i = 1; i &amp;lt; n; i++) { dp[i] = max(dp[i-1] + nums[i], nums[i]); result = max(result, dp[i]); } return result; } }; Greedy # class Solution { public: int maxSubArray(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int sum = 0; int n = nums.</description></item><item><title>0063. Unique Path II</title><link>https://jackeryli.github.io/leetcode/dp/0063/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/dp/0063/</guid><description>class Solution { public: int uniquePathsWithObstacles(vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; obstacleGrid) { int m = obstacleGrid.size(); int n = obstacleGrid[0].size(); int dp[m][n]; memset(dp, 0, sizeof(dp)); for(int i = 0; i &amp;lt; m &amp;amp;&amp;amp; obstacleGrid[i][0] == 0; i++) dp[i][0] = 1; for(int j = 0; j &amp;lt; n &amp;amp;&amp;amp; obstacleGrid[0][j] == 0; j++) dp[0][j] = 1; for(int i = 1; i &amp;lt; m; i++) { for(int j = 1; j &amp;lt; n; j++) { if(obstacleGrid[i][j] !</description></item><item><title>0123. Best Time to Buy and Sell Stock III</title><link>https://jackeryli.github.io/leetcode/dp/0123/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/dp/0123/</guid><description>class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices) { int firstBuy = -prices[0]; int firstSell = 0; int secondBuy = -prices[0]; int secondSell = 0; for(int i = 1; i &amp;lt; prices.size(); i++) { firstBuy = max(firstBuy, -prices[i]); firstSell = max(firstSell, prices[i] + firstBuy); secondBuy = max(secondBuy, -prices[i] + firstSell); secondSell = max(secondSell, prices[i] + secondBuy); } return secondSell; } };</description></item><item><title>0139. Word Break</title><link>https://jackeryli.github.io/leetcode/dp/0139/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/dp/0139/</guid><description>class Solution { public: bool wordBreak(string s, vector&amp;lt;string&amp;gt;&amp;amp; wordDict) { unordered_set&amp;lt;string&amp;gt; wordSet(wordDict.begin(), wordDict.end()); int n = s.size(); // dp[i]: sub string length i can be segament in Dict vector&amp;lt;bool&amp;gt; dp(n + 1, false); dp[0] = true; // Because the order of the string is important // Iterate bag then iterate items for(int i = 1; i &amp;lt;= n; i++) { for(int j = 0; j &amp;lt; i; j++) { string sub = s.</description></item><item><title>0188. Best Time to Buy and Sell Stock IV</title><link>https://jackeryli.github.io/leetcode/dp/0188/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/dp/0188/</guid><description>class Solution { public: int maxProfit(int k, vector&amp;lt;int&amp;gt;&amp;amp; prices) { // Do nothing, firstBuy, firstSell, secondBuy, secondSell, ... vector&amp;lt;int&amp;gt; dp(2 * k + 1); for(int i = 1; i &amp;lt; 2 * k + 1; i += 2) { dp[i] = -prices[0]; } for(int i = 1; i &amp;lt; prices.size(); i++) { for(int j = 1; j &amp;lt; 2 * k + 1; j++) { if(j % 2 == 1) { // buy score // last day sell score - today stock price dp[j] = max(dp[j], dp[j-1] - prices[i]); } else { // sell score // today stock price + last day buy score dp[j] = max(dp[j], prices[i] + dp[j-1]); } } } return dp[2 * k]; } };</description></item><item><title>0279. Perfect Squares</title><link>https://jackeryli.github.io/leetcode/dp/0279/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/dp/0279/</guid><description>class Solution { public: int numSquares(int n) { // dp[i] = least number of perfect square numbers vector&amp;lt;int&amp;gt; dp(n+1, 10001); dp[0] = 0; for(int i = 0; i &amp;lt;= n; i++) { for(int j = 1; j * j &amp;lt;= i; j++) { dp[i] = min(dp[i], dp[i - j*j] + 1); } } return dp[n] == 10001 ? 0 : dp[n]; } };</description></item><item><title>0300.Longest Increasing Subsequence</title><link>https://jackeryli.github.io/leetcode/dp/0300/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/dp/0300/</guid><description>class Solution { public: int lengthOfLIS(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.size(); if(n == 1) return 1; int result = 0; // dp[i]: max length end at i vector&amp;lt;int&amp;gt; dp(n, 1); for(int i = 0; i &amp;lt; nums.size(); i++) { for(int j = 0; j &amp;lt; i; j++) { if(nums[i] &amp;gt; nums[j]) { dp[i] = max(dp[i], dp[j] + 1); } } result = max(result, dp[i]); } return result; } };</description></item><item><title>0309. Best Time to Buy and Sell Stock with Cooldown</title><link>https://jackeryli.github.io/leetcode/dp/0309/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/dp/0309/</guid><description>2-DP # class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices) { int n = prices.size(); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(n, vector&amp;lt;int&amp;gt;(4)); for(int i = 0; i &amp;lt; n; i++) { dp[i][0] = -prices[0]; } for(int i = 1; i &amp;lt; n; i++) { dp[i][0] = max(dp[i-1][0], max(dp[i-1][1] - prices[i], dp[i-1][3] - prices[i])); dp[i][1] = max(dp[i-1][3], dp[i-1][1]); dp[i][2] = dp[i-1][0] + prices[i]; dp[i][3] = dp[i-1][2]; } return max(dp[n-1][1], max(dp[n-1][2], dp[n-1][3])); } }; 1-DP # class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices) { int n = prices.</description></item><item><title>0322. Coin Change</title><link>https://jackeryli.github.io/leetcode/dp/0322/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/dp/0322/</guid><description>class Solution { public: int coinChange(vector&amp;lt;int&amp;gt;&amp;amp; coins, int amount) { // dp[j]: fewest number of coins to make amount=j // dp[j] = min(dp[j], dp[j - coins[i]] + 1) // max will be amount+1 because the min value of coin is 1 // only possible amount of coins is amount vector&amp;lt;int&amp;gt; dp(amount+1, amount+1); dp[0] = 0; for(int coin : coins) { for(int j = coin; j &amp;lt;= amount; j++) { dp[j] = min(dp[j], dp[j - coin] + 1); } } if(dp[amount] &amp;gt; amount) return -1; return dp[amount]; } };</description></item><item><title>0518. Coin Change II</title><link>https://jackeryli.github.io/leetcode/dp/0518/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/dp/0518/</guid><description>class Solution { public: int change(int amount, vector&amp;lt;int&amp;gt;&amp;amp; coins) { // dp[j] = number of combination to make amount = j int dp[amount+1]; memset(dp, 0, sizeof(dp)); dp[0] = 1; for(int coin : coins) { for(int j = coin; j &amp;lt;= amount; j++) { dp[j] += dp[j - coin]; } } return dp[amount]; } };</description></item><item><title>0674.Longest Continuous Increasing Subsequence</title><link>https://jackeryli.github.io/leetcode/dp/0674/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/dp/0674/</guid><description> DP # class Solution { public: int findLengthOfLCIS(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.size(); if(n == 1) return 1; int result = 1; vector&amp;lt;int&amp;gt; dp(n, 1); for(int i = 1; i &amp;lt; n; i++) { if(nums[i] &amp;gt; nums[i-1]) { dp[i] = dp[i-1] + 1; } result = max(result, dp[i]); } return result; } }; Greedy # class Solution { public: int findLengthOfLCIS(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.size(); if(n == 1) return 1; int result = 1; int count = 1; for(int i = 1; i &amp;lt; n; i++) { if(nums[i] &amp;gt; nums[i-1]) { count++; } else { count = 1; } result = max(result, count); } return result; } };</description></item><item><title>0714.Best Time to Buy and Sell Stock with Transaction Fee</title><link>https://jackeryli.github.io/leetcode/dp/0714/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/dp/0714/</guid><description>2-DP # class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices, int fee) { int n = prices.size(); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(n, vector&amp;lt;int&amp;gt;(2)); for(int i = 0; i &amp;lt; n; i++) { dp[i][0] = -prices[0]; } for(int i = 1; i &amp;lt; n; i++) { // buy score // i-1 day no buy and buy in i day // i-1 already buy dp[i][0] = max(dp[i-1][1] - prices[i], dp[i-1][0]); // sell score // i-1 buy and sell at i day // i-1 no buy dp[i][1] = max(dp[i-1][0] + prices[i] - fee, dp[i-1][1]); } return dp[n-1][1]; } }; 1-DP # class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices, int fee) { int n = prices.</description></item><item><title>0718.Maximum Length of Repeated Subarray</title><link>https://jackeryli.github.io/leetcode/dp/0718/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/dp/0718/</guid><description>2-DP # class Solution { public: int findLength(vector&amp;lt;int&amp;gt;&amp;amp; nums1, vector&amp;lt;int&amp;gt;&amp;amp; nums2) { int m = nums1.size(); int n = nums2.size(); int result = 0; // dp[i][j]: max length when (i,j) vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(m+1, vector&amp;lt;int&amp;gt;(n+1)); for(int i = 1; i &amp;lt;= m; i++) { for(int j = 1; j &amp;lt;= n; j++) { if(nums1[i-1] == nums2[j-1]) { // (i,j) depends on (i-1, j-1) is valid dp[i][j] = dp[i-1][j-1] + 1; } result = max(result, dp[i][j]); } } return result; } }; 1-DP # class Solution { public: int findLength(vector&amp;lt;int&amp;gt;&amp;amp; nums1, vector&amp;lt;int&amp;gt;&amp;amp; nums2) { int m = nums1.</description></item><item><title>1035.Uncrossed Lines</title><link>https://jackeryli.github.io/leetcode/dp/1035/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/dp/1035/</guid><description>class Solution { public: int maxUncrossedLines(vector&amp;lt;int&amp;gt;&amp;amp; nums1, vector&amp;lt;int&amp;gt;&amp;amp; nums2) { int m = nums1.size(); int n = nums2.size(); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(m+1, vector&amp;lt;int&amp;gt;(n+1)); for(int i = 1; i &amp;lt;= m; i++) { for(int j = 1; j &amp;lt;= n; j++) { if(nums1[i-1] == nums2[j-1]) { dp[i][j] = dp[i-1][j-1] + 1; } else { dp[i][j] = max(dp[i-1][j], dp[i][j-1]); } } } return dp[m][n]; } };</description></item><item><title>1143.Longest Common Subsequence</title><link>https://jackeryli.github.io/leetcode/dp/1143/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/dp/1143/</guid><description>class Solution { public: int maxUncrossedLines(vector&amp;lt;int&amp;gt;&amp;amp; nums1, vector&amp;lt;int&amp;gt;&amp;amp; nums2) { int m = nums1.size(); int n = nums2.size(); vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; dp(m+1, vector&amp;lt;int&amp;gt;(n+1)); for(int i = 1; i &amp;lt;= m; i++) { for(int j = 1; j &amp;lt;= n; j++) { if(nums1[i-1] == nums2[j-1]) { dp[i][j] = dp[i-1][j-1] + 1; } else { dp[i][j] = max(dp[i-1][j], dp[i][j-1]); } } } return dp[m][n]; } };</description></item></channel></rss>