<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title/><link>https://jackeryli.github.io/leetcode/sliding-window/</link><description>Recent content on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://jackeryli.github.io/leetcode/sliding-window/index.xml" rel="self" type="application/rss+xml"/><item><title>0003.Longest Substring Without Repeating Character</title><link>https://jackeryli.github.io/leetcode/sliding-window/0003/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/sliding-window/0003/</guid><description>class Solution { public int lengthOfLongestSubstring(String s) { int n = s.length(); int i = 0; int ans = 0; Set&amp;lt;Character&amp;gt; existSet = new HashSet&amp;lt;&amp;gt;(); for(int j = 0; j &amp;lt; n; j++) { Character c = s.charAt(j); while(existSet.contains(c)) { existSet.remove(s.charAt(i)); i++; } existSet.add(c); ans = Math.max(ans, j - i + 1); } return ans; } }</description></item><item><title>0209. Minimum Size Subarray Sum</title><link>https://jackeryli.github.io/leetcode/sliding-window/0209/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/sliding-window/0209/</guid><description>C++ # class Solution { public: int minSubArrayLen(int target, vector&amp;lt;int&amp;gt;&amp;amp; nums) { int left = 0; int sum = 0; int ans = INT_MAX; for(int right = 0; right &amp;lt; nums.size(); right++) { sum += nums[right]; while(sum &amp;gt;= target) { ans = min(ans, right - left + 1); sum -= nums[left++]; } } return ans == INT_MAX ? 0 : ans; } }; Java # class Solution { public int minSubArrayLen(int target, int[] nums) { int i = 0; int n = nums.</description></item></channel></rss>