<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title/><link>https://jackeryli.github.io/leetcode/greedy/</link><description>Recent content on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://jackeryli.github.io/leetcode/greedy/index.xml" rel="self" type="application/rss+xml"/><item><title>0053.Maximum Subarray</title><link>https://jackeryli.github.io/leetcode/greedy/0053/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/greedy/0053/</guid><description>class Solution { public int maxSubArray(int[] nums) { int ans = nums[0]; int n = nums.length; int currentSum = nums[0]; for(int i = 1; i &amp;lt; n; i++) { if(currentSum + nums[i] &amp;lt; nums[i]) { currentSum = nums[i]; } else { currentSum += nums[i]; } ans = Math.max(ans, currentSum); } return ans; } } class Solution { public int maxSubArray(int[] nums) { int ans = Integer.MIN_VALUE; int sum = 0; int n = nums.</description></item><item><title>0056.Merge Intervals</title><link>https://jackeryli.github.io/leetcode/greedy/0056/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/greedy/0056/</guid><description>class Solution { public int[][] merge(int[][] intervals) { int n = intervals.length; List&amp;lt;int[]&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); Arrays.sort(intervals, (a, b) -&amp;gt; Integer.compare(a[0], b[0])); int start = intervals[0][0]; int end = intervals[0][1]; for(int i = 1; i &amp;lt; n; i++) { if(end &amp;gt;= intervals[i][0]) { end = Math.max(end, intervals[i][1]); } else { res.add(new int[]{start, end}); start = intervals[i][0]; end = intervals[i][1]; } } res.add(new int[]{start, end}); return res.toArray(new int[res.size()][]); } }</description></item><item><title>0057.Insert Interval</title><link>https://jackeryli.github.io/leetcode/greedy/0057/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/greedy/0057/</guid><description>class Solution { public int[][] insert(int[][] intervals, int[] newInterval) { int n = intervals.length; List&amp;lt;int[]&amp;gt; res = new ArrayList&amp;lt;&amp;gt;(); int i = 0; // Add non-overlap part into result while(i &amp;lt; n &amp;amp;&amp;amp; intervals[i][1] &amp;lt; newInterval[0]) { res.add(intervals[i]); i++; } int start = newInterval[0]; int end = newInterval[1]; // merge overlap part while(i &amp;lt; n &amp;amp;&amp;amp; intervals[i][0] &amp;lt;= end) { start = Math.min(start, intervals[i][0]); end = Math.max(end, intervals[i][1]); i++; } res.</description></item><item><title>0121.Best Time to Buy and Sell Stock</title><link>https://jackeryli.github.io/leetcode/greedy/0121/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/greedy/0121/</guid><description>class Solution { public: int maxProfit(vector&amp;lt;int&amp;gt;&amp;amp; prices) { int result = 0; int minPrice = 100000; for(int&amp;amp; price : prices) { // find minPrice // if price is smaller than minPrice, replace minPrice // else, stock can be selled, compare to the result if(price &amp;lt; minPrice){ minPrice = price; } else { result = max(result, price - minPrice); } } return result; } };</description></item><item><title>0134. Gas Station</title><link>https://jackeryli.github.io/leetcode/greedy/0134/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/greedy/0134/</guid><description>Naive (TLE) # class Solution { public int canCompleteCircuit(int[] gas, int[] cost) { // 1 2 3 4 5 1 2 3 4 5 // 3 4 5 1 2 3 4 5 1 2 // 2 3 4 2 3 4 // 3 4 3 3 4 3 int n = gas.length; int[] circleGas = new int[n*2]; int[] circleCost = new int[n*2]; for(int i = 0; i &amp;lt; n; i++) { circleGas[i] = gas[i]; circleGas[i + n] = gas[i]; circleCost[i] = cost[i]; circleCost[i + n] = cost[i]; } for(int i = 0; i &amp;lt; n; i++) { if(gas[i] &amp;gt;= cost[i]) { // start checking int gasSum = gas[i]; int costSum = cost[i]; boolean isFailed = false; for(int j = i+1; j &amp;lt; i + n; j++) { gasSum += circleGas[j]; costSum += circleCost[j]; if(costSum &amp;gt; gasSum) { // failed isFailed = true; break; } } if(!</description></item><item><title>0376.Wiggle Subsequence</title><link>https://jackeryli.github.io/leetcode/greedy/0376/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/greedy/0376/</guid><description>class Solution { public int wiggleMaxLength(int[] nums) { int n = nums.length; int count = 1; int dir = 0; // 0 decrease 1 increase 2 no move for(int i = 1; i &amp;lt; n; i++) { if(i == 1) { if(nums[i] &amp;gt; nums[0]) { dir = 1; count++; } else if(nums[i] &amp;lt; nums[0]) { dir = 0; count++; } else dir = 2; continue; } if(nums[i] &amp;gt; nums[i-1]) { if(dir !</description></item><item><title>0452.Minimum Number of Arrows to Burst Balloons</title><link>https://jackeryli.github.io/leetcode/greedy/0452/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/greedy/0452/</guid><description>class Solution { public int findMinArrowShots(int[][] points) { int count = 1; int n = points.length; Arrays.sort(points, (a, b) -&amp;gt; Integer.compare(a[0], b[0])); int end = points[0][1]; for(int i = 1; i &amp;lt; n; i++) { if(end &amp;gt;= points[i][0]) { end = Math.min(end, points[i][1]); } else { count++; end = points[i][1]; } } return count; } }</description></item><item><title>0455.Assign Cookies</title><link>https://jackeryli.github.io/leetcode/greedy/0455/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/greedy/0455/</guid><description>class Solution { public int findContentChildren(int[] g, int[] s) { Arrays.sort(g); Arrays.sort(s); int i = g.length - 1; int j = s.length - 1; int count = 0; while(i &amp;gt;= 0 &amp;amp;&amp;amp; j &amp;gt;= 0) { if(s[j] &amp;gt;= g[i]) { j--; i--; count++; } else { i--; } } return count; } }</description></item></channel></rss>