<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title/><link>https://jackeryli.github.io/leetcode/hashmap/</link><description>Recent content on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://jackeryli.github.io/leetcode/hashmap/index.xml" rel="self" type="application/rss+xml"/><item><title>0036.Valid Sudoku</title><link>https://jackeryli.github.io/leetcode/hashmap/0036/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/hashmap/0036/</guid><description>class Solution { public: bool isValidSudoku(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board) { int m = board.size(); int n = board[0].size(); int columnMap[9][9]; int rowMap[9][9]; int threeMap[9][9]; memset(rowMap, 0, sizeof(rowMap)); memset(columnMap, 0, sizeof(columnMap)); memset(threeMap, 0, sizeof(threeMap)); for(int i = 0; i &amp;lt; m; i++){ for(int j = 0; j &amp;lt; n; j++){ if(isdigit(board[i][j])) { int idx = board[i][j] - &amp;#39;1&amp;#39;; // columnMap if(columnMap[j][idx] != 0) return false; columnMap[j][idx] = 1; // rowMap if(rowMap[i][idx] != 0) return false; rowMap[i][idx] = 1; // threeMap int threeIdx = i/3 * 3 + j/3; if(threeMap[threeIdx][idx] !</description></item><item><title>0242. Valid Anagrams</title><link>https://jackeryli.github.io/leetcode/hashmap/0242/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/hashmap/0242/</guid><description>class Solution { public: bool isAnagram(string s, string t) { // If size different, it isn&amp;#39;t anagram if(s.size() != t.size()) return false; unordered_map&amp;lt;char, int&amp;gt; charToCount; for(char c : s) { charToCount[c]++; } for(char c : t) { charToCount[c]--; } for(int i = 0; i &amp;lt; 26; i++) { char c = &amp;#39;a&amp;#39; + i; if(charToCount[c] != 0) return false; } return true; } }; class Solution { public: bool isAnagram(string s, string t) { int mapS2count[26]; memset(mapS2count, 0, sizeof(mapS2count)); for(char c : s){ mapS2count[c - &amp;#39;a&amp;#39;]++; } for(char c : t){ mapS2count[c - &amp;#39;a&amp;#39;]--; } for(int i = 0; i &amp;lt; 26; i++){ if(mapS2count[i] !</description></item><item><title>0382.Rawsom Note</title><link>https://jackeryli.github.io/leetcode/hashmap/0383/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/hashmap/0383/</guid><description>class Solution { public: bool canConstruct(string ransomNote, string magazine) { // put magazine in hashmap, key: character, value: count // check each character in ransomNote and minus count // If unvalid situation, return false // return true if completely iterates ransomNote int magazineCharToCount[26]; memset(magazineCharToCount, 0, sizeof(magazineCharToCount)); for(char c : magazine){ magazineCharToCount[c - &amp;#39;a&amp;#39;]++; } for(char c : ransomNote){ int idx = c - &amp;#39;a&amp;#39;; if(magazineCharToCount[idx] == 0){ return false; } magazineCharToCount[idx]--; } return true; } };</description></item><item><title>202.Happy Number</title><link>https://jackeryli.github.io/leetcode/hashmap/202/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/hashmap/202/</guid><description>class Solution { public: bool isHappy(int n) { int sum = 0; unordered_set&amp;lt;int&amp;gt; sumSet; while(1){ sum = 0; while(n &amp;gt; 0){ int digit = n % 10; sum += (digit * digit); n /= 10; } if(sum == 1) return true; if(sumSet.find(sum) != sumSet.end()) return false; else sumSet.insert(sum); n = sum; } return false; } }; class Solution { public: unordered_set&amp;lt;int&amp;gt; sumSet; int getNext(int num){ int sum = 0; while(num &amp;gt; 0){ int digit = num % 10; sum += (digit * digit); num /= 10; } return sum; } bool isHappy(int n) { while(n !</description></item><item><title>290.Word Pattern</title><link>https://jackeryli.github.io/leetcode/hashmap/0290/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/hashmap/0290/</guid><description>class Solution { public: bool wordPattern(string pattern, string s) { unordered_map&amp;lt;char, string&amp;gt; mapP2S; unordered_map&amp;lt;string, char&amp;gt; mapS2P; int i = 0; int l = 0, r = 0; int n = s.size(); while(l &amp;lt; n &amp;amp;&amp;amp; r &amp;lt; n){ // Split the string by space while(s[r] != &amp;#39; &amp;#39; &amp;amp;&amp;amp; r &amp;lt; n) r++; // ensure r range string sub = s.substr(l, r - l); // blank index to left index // if pattern and string are all not recorded before, record it if(mapP2S.</description></item><item><title>49.Group Anagrams</title><link>https://jackeryli.github.io/leetcode/hashmap/0049/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/hashmap/0049/</guid><description>class Solution { public: vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; groupAnagrams(vector&amp;lt;string&amp;gt;&amp;amp; strs) { unordered_map&amp;lt;string, vector&amp;lt;string&amp;gt;&amp;gt; map1; vector&amp;lt;vector&amp;lt;string&amp;gt;&amp;gt; result; for(string str : strs){ string key = str; sort(key.begin(), key.end()); map1[key].push_back(str); } for(auto it = map1.begin(); it != map1.end(); it++){ result.push_back(it-&amp;gt;second); } return result; } };</description></item></channel></rss>