<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title/><link>https://jackeryli.github.io/leetcode/two-pointer/</link><description>Recent content on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://jackeryli.github.io/leetcode/two-pointer/index.xml" rel="self" type="application/rss+xml"/><item><title>0011.Container With Most Water</title><link>https://jackeryli.github.io/leetcode/two-pointer/0011/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/two-pointer/0011/</guid><description>class Solution { public: int maxArea(vector&amp;lt;int&amp;gt;&amp;amp; height) { int l = 0; int r = height.size() - 1; int result = 0; while(l &amp;lt; r) { result = max(result, (r - l) * min(height[l], height[r])); if(height[l] &amp;lt; height[r]) l++; else r--; } return result; } };</description></item><item><title>0015. Three Sum</title><link>https://jackeryli.github.io/leetcode/two-pointer/0015/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/two-pointer/0015/</guid><description>class Solution { public: void twoSum(vector&amp;lt;int&amp;gt;&amp;amp; nums, int target, int left, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; result) { int l = left; int r = nums.size() - 1; while(l &amp;lt; r) { int sum = nums[l] + nums[r]; if(target &amp;gt; sum) { l++; } else if (target &amp;lt; sum) { r--; } else { result.push_back({-target, nums[l], nums[r]}); l++; r--; while(nums[l] == nums[l-1] &amp;amp;&amp;amp; l &amp;lt; r) l++; while(nums[r] == nums[r+1] &amp;amp;&amp;amp; l &amp;lt; r) r--; } } } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; threeSum(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int n = nums.</description></item><item><title>0026. Remove Duplicates from Sorted Array</title><link>https://jackeryli.github.io/leetcode/two-pointer/0026/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/two-pointer/0026/</guid><description>class Solution { public: int removeDuplicates(vector&amp;lt;int&amp;gt;&amp;amp; nums) { // fast and slow start from 0 // fast go first // if nums[fast] != nums[slow], slow++ and swap // return slow int fast = 1, slow = 0; // 0 1 0 1 1 2 2 3 3 4 // 0 1 2 1 1 0 2 3 3 4 // s f for(; fast &amp;lt; nums.size(); fast++) { if(nums[fast] != nums[slow]) { slow++; nums[slow] = nums[fast]; } } return slow + 1; } };</description></item><item><title>0125. Valid Palindrome</title><link>https://jackeryli.github.io/leetcode/two-pointer/0125/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/two-pointer/0125/</guid><description>class Solution { public: bool isPalindrome(string s) { // two point left and right // if meet not alpha or number, skip // compare s[left] and s[right] // if equal, continue // if not equal return false // if left == right, return true int left = 0, right = s.size() - 1; for(; left &amp;lt; right; left++, right--) { while(left &amp;lt; right &amp;amp;&amp;amp; !isalnum(s[left])) { left++; } while(left &amp;lt; right &amp;amp;&amp;amp; !</description></item><item><title>0141. Linked List Cycle</title><link>https://jackeryli.github.io/leetcode/two-pointer/0141/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/two-pointer/0141/</guid><description>/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: bool hasCycle(ListNode *head) { ListNode* fast = head; ListNode* slow = head; while(fast != nullptr &amp;amp;&amp;amp; fast-&amp;gt;next != nullptr){ fast = fast-&amp;gt;next-&amp;gt;next; slow = slow-&amp;gt;next; if(fast == slow) { return true; } } return false; } };</description></item><item><title>0142. Linked List Cycle II</title><link>https://jackeryli.github.io/leetcode/two-pointer/0142/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/two-pointer/0142/</guid><description>/** * Definition for singly-linked list. * struct ListNode { * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) {} * }; */ class Solution { public: ListNode *detectCycle(ListNode *head) { // fast move 2 pos // slow move 1 pos // pos count: 2(x+y) = x + y + n(y + z) // n = 1, x = z ListNode* fast = head; ListNode* slow = head; while(fast !</description></item><item><title>0167. Two Sum - Input Array is Sorted</title><link>https://jackeryli.github.io/leetcode/two-pointer/0167/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/two-pointer/0167/</guid><description>class Solution { public: vector&amp;lt;int&amp;gt; twoSum(vector&amp;lt;int&amp;gt;&amp;amp; numbers, int target) { int l = 0; int r = numbers.size() - 1; int sum; while(l &amp;lt; r) { sum = numbers[l] + numbers[r]; if(sum == target) return {l+1, r+1}; else if (sum &amp;gt; target) r--; else l++; } return {}; } };</description></item><item><title>0189.Rotate Array</title><link>https://jackeryli.github.io/leetcode/two-pointer/0189/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/two-pointer/0189/</guid><description>class Solution { public: void rotate(vector&amp;lt;int&amp;gt;&amp;amp; nums, int k) { reverse(nums.begin(), nums.end()); if(k &amp;gt; nums.size()) k = k % nums.size(); reverse(nums.begin(), nums.begin() + k); reverse(nums.begin() + k, nums.end()); } };</description></item><item><title>0392. Is Subsequence</title><link>https://jackeryli.github.io/leetcode/two-pointer/0392/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/two-pointer/0392/</guid><description>class Solution { public: bool isSubsequence(string s, string t) { if(t.size() &amp;lt; s.size()) return false; int index1 = 0; int index2 = 0; while(index1 &amp;lt; s.size() &amp;amp;&amp;amp; index2 &amp;lt; t.size()) { if(s[index1] == t[index2]){ index1++; index2++; } else { index2++; } } return index1 == s.size(); } };</description></item><item><title>0977. Squares of a Sorted Array</title><link>https://jackeryli.github.io/leetcode/two-pointer/0977/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/two-pointer/0977/</guid><description> Method 1 # Time Complexity: O(n) Space Complexity: O(n) class Solution { public: vector&amp;lt;int&amp;gt; sortedSquares(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int l = 0; int r = nums.size() - 1; int index = nums.size() - 1; vector&amp;lt;int&amp;gt; result(nums.size(), 1); while(l &amp;lt;= r) { int leftpower = nums[l] * nums[l]; int rightpower = nums[r] * nums[r]; if(leftpower &amp;gt; rightpower) { result[index--] = leftpower; l++; } else { result[index--] = rightpower; r--; } } return result; } };</description></item></channel></rss>