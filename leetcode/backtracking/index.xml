<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title/><link>https://jackeryli.github.io/leetcode/backtracking/</link><description>Recent content on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://jackeryli.github.io/leetcode/backtracking/index.xml" rel="self" type="application/rss+xml"/><item><title>0017.Letter Combination</title><link>https://jackeryli.github.io/leetcode/backtracking/0017/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/backtracking/0017/</guid><description>class Solution { public: vector&amp;lt;string&amp;gt; result; string path = &amp;#34;&amp;#34;; unordered_map&amp;lt;char, string&amp;gt; num2alpha; void backtracking(const string&amp;amp; digits, int index) { if(index == digits.size()) { result.emplace_back(path); return; } for(char c : num2alpha[digits[index]]) { path.push_back(c); backtracking(digits, index + 1); path.pop_back(); } } vector&amp;lt;string&amp;gt; letterCombinations(string digits) { if(digits.size() == 0) return {}; num2alpha[&amp;#39;2&amp;#39;] = &amp;#34;abc&amp;#34;; num2alpha[&amp;#39;3&amp;#39;] = &amp;#34;def&amp;#34;; num2alpha[&amp;#39;4&amp;#39;] = &amp;#34;ghi&amp;#34;; num2alpha[&amp;#39;5&amp;#39;] = &amp;#34;jkl&amp;#34;; num2alpha[&amp;#39;6&amp;#39;] = &amp;#34;mno&amp;#34;; num2alpha[&amp;#39;7&amp;#39;] = &amp;#34;pqrs&amp;#34;; num2alpha[&amp;#39;8&amp;#39;] = &amp;#34;tuv&amp;#34;; num2alpha[&amp;#39;9&amp;#39;] = &amp;#34;wxyz&amp;#34;; backtracking(digits, 0); return result; } };</description></item><item><title>0022.Generate Parentheses</title><link>https://jackeryli.github.io/leetcode/backtracking/0022/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/backtracking/0022/</guid><description>class Solution { public: vector&amp;lt;string&amp;gt; result; string path; void backtracking(int left, int right, int n) { if(left &amp;gt; n || right &amp;gt; n) return; if(left == n &amp;amp;&amp;amp; right == n) { result.push_back(path); return; } if(left &amp;gt;= right) { path.push_back(&amp;#39;(&amp;#39;); backtracking(left+1, right, n); path.pop_back(); } if(left &amp;gt; right) { path.push_back(&amp;#39;)&amp;#39;); backtracking(left, right+1, n); path.pop_back(); } } vector&amp;lt;string&amp;gt; generateParenthesis(int n) { path = &amp;#34;(&amp;#34;; backtracking(1, 0, n); return result; } };</description></item><item><title>0039. Combination Sum</title><link>https://jackeryli.github.io/leetcode/backtracking/0039/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/backtracking/0039/</guid><description>class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result; vector&amp;lt;int&amp;gt; path; void backtracking(vector&amp;lt;int&amp;gt;&amp;amp; candidates, int target, int sum) { if(target == sum) { result.push_back(path); return; } else if(sum &amp;gt; target) { return; } for(int i = 0; i &amp;lt; candidates.size(); i++) { if(path.size() == 0 || path[path.size()-1] &amp;lt;= candidates[i]) { path.push_back(candidates[i]); backtracking(candidates, target, sum + candidates[i]); path.pop_back(); } } } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; combinationSum(vector&amp;lt;int&amp;gt;&amp;amp; candidates, int target) { backtracking(candidates, target, 0); return result; } }; class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result; vector&amp;lt;int&amp;gt; path; void backtracking(vector&amp;lt;int&amp;gt;&amp;amp; candidates, int target, int sum, int startIndex) { if(target == sum) { result.</description></item><item><title>0046.Permutations</title><link>https://jackeryli.github.io/leetcode/backtracking/0046/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/backtracking/0046/</guid><description>class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result; vector&amp;lt;int&amp;gt; path; void backtracking(vector&amp;lt;int&amp;gt;&amp;amp; nums, vector&amp;lt;bool&amp;gt;&amp;amp; visited) { if(path.size() == nums.size()) { result.push_back(path); return; } for(int i = 0; i &amp;lt; nums.size(); i++) { if(visited[i] == false) { path.push_back(nums[i]); visited[i] = true; backtracking(nums, visited); path.pop_back(); visited[i] = false; } } } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; permute(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;bool&amp;gt; visited(nums.size(), false); backtracking(nums, visited); return result; } };</description></item><item><title>0077.Combinations</title><link>https://jackeryli.github.io/leetcode/backtracking/0077/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/backtracking/0077/</guid><description>class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result; vector&amp;lt;int&amp;gt; path; void backtracking(int n, int k, int start) { if(path.size() == k) { result.push_back(path); return; } for(int i = start; i &amp;lt;= n; i++) { path.push_back(i); backtracking(n, k, i + 1); path.pop_back(); } } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; combine(int n, int k) { backtracking(n, k, 1); return result; } };</description></item><item><title>0079. Word Search</title><link>https://jackeryli.github.io/leetcode/backtracking/0079/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/backtracking/0079/</guid><description>class Solution { public: bool backtracking(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board, string&amp;amp; word, int index, int row, int col) { if(index == word.size()) { return true; } if(row &amp;lt; 0 || row == board.size() || col &amp;lt; 0 || col == board[0].size() || word[index] != board[row][col]) { return false; } board[row][col] = &amp;#39;#&amp;#39;; bool r1 = backtracking(board, word, index + 1, row + 1, col); bool r2 = backtracking(board, word, index + 1, row - 1, col); bool r3 = backtracking(board, word, index + 1, row, col + 1); bool r4 = backtracking(board, word, index + 1, row, col - 1); board[row][col] = word[index]; return r1 || r2 || r3 || r4; } bool exist(vector&amp;lt;vector&amp;lt;char&amp;gt;&amp;gt;&amp;amp; board, string word) { for(int i = 0; i &amp;lt; board.</description></item></channel></rss>