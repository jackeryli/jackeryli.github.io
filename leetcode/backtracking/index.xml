<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title/><link>https://jackeryli.github.io/leetcode/backtracking/</link><description>Recent content on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://jackeryli.github.io/leetcode/backtracking/index.xml" rel="self" type="application/rss+xml"/><item><title>0017.Letter Combination</title><link>https://jackeryli.github.io/leetcode/backtracking/0017/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/backtracking/0017/</guid><description>class Solution { public: vector&amp;lt;string&amp;gt; result; string path = &amp;#34;&amp;#34;; unordered_map&amp;lt;char, string&amp;gt; num2alpha; void backtracking(const string&amp;amp; digits, int index) { if(index == digits.size()) { result.emplace_back(path); return; } for(char c : num2alpha[digits[index]]) { path.push_back(c); backtracking(digits, index + 1); path.pop_back(); } } vector&amp;lt;string&amp;gt; letterCombinations(string digits) { if(digits.size() == 0) return {}; num2alpha[&amp;#39;2&amp;#39;] = &amp;#34;abc&amp;#34;; num2alpha[&amp;#39;3&amp;#39;] = &amp;#34;def&amp;#34;; num2alpha[&amp;#39;4&amp;#39;] = &amp;#34;ghi&amp;#34;; num2alpha[&amp;#39;5&amp;#39;] = &amp;#34;jkl&amp;#34;; num2alpha[&amp;#39;6&amp;#39;] = &amp;#34;mno&amp;#34;; num2alpha[&amp;#39;7&amp;#39;] = &amp;#34;pqrs&amp;#34;; num2alpha[&amp;#39;8&amp;#39;] = &amp;#34;tuv&amp;#34;; num2alpha[&amp;#39;9&amp;#39;] = &amp;#34;wxyz&amp;#34;; backtracking(digits, 0); return result; } };</description></item><item><title>0046.Permutations</title><link>https://jackeryli.github.io/leetcode/backtracking/0046/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/backtracking/0046/</guid><description>class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result; vector&amp;lt;int&amp;gt; path; void backtracking(vector&amp;lt;int&amp;gt;&amp;amp; nums, vector&amp;lt;bool&amp;gt;&amp;amp; visited) { if(path.size() == nums.size()) { result.push_back(path); return; } for(int i = 0; i &amp;lt; nums.size(); i++) { if(visited[i] == false) { path.push_back(nums[i]); visited[i] = true; backtracking(nums, visited); path.pop_back(); visited[i] = false; } } } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; permute(vector&amp;lt;int&amp;gt;&amp;amp; nums) { vector&amp;lt;bool&amp;gt; visited(nums.size(), false); backtracking(nums, visited); return result; } };</description></item><item><title>0077.Combinations</title><link>https://jackeryli.github.io/leetcode/backtracking/0077/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/backtracking/0077/</guid><description>class Solution { public: vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; result; vector&amp;lt;int&amp;gt; path; void backtracking(int n, int k, int start) { if(path.size() == k) { result.push_back(path); return; } for(int i = start; i &amp;lt;= n; i++) { path.push_back(i); backtracking(n, k, i + 1); path.pop_back(); } } vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt; combine(int n, int k) { backtracking(n, k, 1); return result; } };</description></item></channel></rss>