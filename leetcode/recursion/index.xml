<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title/><link>https://jackeryli.github.io/leetcode/recursion/</link><description>Recent content on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://jackeryli.github.io/leetcode/recursion/index.xml" rel="self" type="application/rss+xml"/><item><title>0227. Basic Calculator II</title><link>https://jackeryli.github.io/leetcode/recursion/227/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/recursion/227/</guid><description>class Solution { public: int getNumber(string&amp;amp; expression, int&amp;amp; pos){ int result = 0; while((isdigit(expression[pos]) || expression[pos] == &amp;#39; &amp;#39;) &amp;amp;&amp;amp; pos &amp;lt; expression.size()){ if(isdigit(expression[pos])){ result = result * 10 + (expression[pos] - &amp;#39;0&amp;#39;); } pos++; } return result; } int parseTerm(string&amp;amp; expression, int&amp;amp; pos){ int result = getNumber(expression, pos); while(pos &amp;lt; expression.size() &amp;amp;&amp;amp; (expression[pos] == &amp;#39;*&amp;#39; || expression[pos] == &amp;#39;/&amp;#39;)){ char op = expression[pos++]; int nextNumber = getNumber(expression, pos); if(op == &amp;#39;*&amp;#39;){ result *= nextNumber; } else if(op == &amp;#39;/&amp;#39;){ result /= nextNumber; } } return result; } int parseExpression(string&amp;amp; expression, int&amp;amp; pos){ int result = parseTerm(expression, pos); while(pos &amp;lt; expression.</description></item><item><title>0268. Missing Number</title><link>https://jackeryli.github.io/leetcode/recursion/268/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/recursion/268/</guid><description>class Solution { public: int missingNumber(vector&amp;lt;int&amp;gt;&amp;amp; nums) { int size = nums.size(); int expect_sum = size * (size+1) / 2; int actual_sum = 0; for(int i = 0; i &amp;lt; size; i++) { actual_sum += nums[i]; } return expect_sum - actual_sum; } };</description></item><item><title>0285. Inorder Successor in BST</title><link>https://jackeryli.github.io/leetcode/recursion/285/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/recursion/285/</guid><description>class Solution { public: bool isTarget = false; TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) { if(root == nullptr) return nullptr; TreeNode* left = inorderSuccessor(root-&amp;gt;left, p); if(left != nullptr) return left; if(isTarget){ return root; } if(p-&amp;gt;val == root-&amp;gt;val){ isTarget = true; } TreeNode* right = inorderSuccessor(root-&amp;gt;right, p); if(right != nullptr) return right; return nullptr; } }; class Solution { public: TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) { TreeNode* sucessor = nullptr; while(root != nullptr){ if(root-&amp;gt;val &amp;lt;= p-&amp;gt;val){ root = root-&amp;gt;right; } else { sucessor = root; root = root-&amp;gt;left; } } return sucessor; } };</description></item><item><title>0772. Basic Calculator III</title><link>https://jackeryli.github.io/leetcode/recursion/772/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/leetcode/recursion/772/</guid><description>class Solution { public: int getNumber(string&amp;amp; expression, int&amp;amp; pos){ int result = 0; while(isdigit(expression[pos]) &amp;amp;&amp;amp; pos &amp;lt; expression.size()){ result = result * 10 + (expression[pos] - &amp;#39;0&amp;#39;); pos++; } return result; } int parseFactor(string&amp;amp; expression, int&amp;amp; pos){ if(expression[pos] == &amp;#39;(&amp;#39;){ pos++; int result = parseExpression(expression, pos); pos++; return result; } return getNumber(expression, pos); } int parseTerm(string&amp;amp; expression, int&amp;amp; pos){ int result = parseFactor(expression, pos); while(pos &amp;lt; expression.size() &amp;amp;&amp;amp; (expression[pos] == &amp;#39;*&amp;#39; || expression[pos] == &amp;#39;/&amp;#39;)){ char op = expression[pos++]; int nextFactor = parseFactor(expression, pos); if(op == &amp;#39;*&amp;#39;){ result *= nextFactor; } else if(op == &amp;#39;/&amp;#39;){ result /= nextFactor; } } return result; } int parseExpression(string&amp;amp; expression, int&amp;amp; pos){ int result = parseTerm(expression, pos); while(pos &amp;lt; expression.</description></item></channel></rss>