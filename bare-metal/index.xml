<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title/><link>https://jackeryli.github.io/bare-metal/</link><description>Recent content on</description><generator>Hugo -- gohugo.io</generator><atom:link href="https://jackeryli.github.io/bare-metal/index.xml" rel="self" type="application/rss+xml"/><item><title>Configure gdb for qemu</title><link>https://jackeryli.github.io/bare-metal/qemu-gdb/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/bare-metal/qemu-gdb/</guid><description> Compile code with gdb # Enable layout src when you use gdb.
CFLAGS = -ggdb Add flag to qemu # qemu-system-aarch64 -M raspi3b -s -S -kernel kernel.img Create .gdbinit under project folders # Connect gdb on 127.0.0.1:1234 Symbol-file enables breakpoint in gdb set architecture aarch64 target remote 127.0.0.1:1234 symbol-file kernel.elf Run qemu with gdb # make qemu-gdb # Run on another window gdb-multiarch -x .gdbinit # Start using gdb b printk layout src c</description></item><item><title>Write bootloader for raspberry pi 3</title><link>https://jackeryli.github.io/bare-metal/bootloader/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/bare-metal/bootloader/</guid><description>We need three files:
kernel.ld: define the memory layout and tell the hardware where to find entry.S. entry.S: run on single core, do initialization and jump to start.c. start.c: first code. Compile to the kernel image:
Link entry.S and kernel.ld to create kernel.elf Build kernel.img by kernel.elf Boot qemu with kernel.img kernel.ld # ENTRY( _xxx ): tell system to find _entry for the following execution 0x80000: first code will put at 0x800000 because 0 ~ 0x80000 are for io-mapping in arm64 text: put codes data: initialized variable bss: uinitialized variable ENTRY( _entry ) SECTIONS { .</description></item><item><title>Configure miniUART to print characters to terminal</title><link>https://jackeryli.github.io/bare-metal/uart/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/bare-metal/uart/</guid><description>From rpi3 docs, IO physical address started from 0x3F000000.
Physical addresses range from 0x3F000000 to 0x3FFFFFFF for peripherals. The bus addresses for peripherals are set up to map onto the peripheral bus address range starting at 0x7E000000. Thus a peripheral advertised here at bus address 0x7Ennnnnn is available at physical address 0x3Fnnnnnn. And the docs said miniuart register virtual address is at:
Address Reg Name Description 0x7E21 5000 AUX_IRQ Auxiliary Interrupt status 0x7E21 5004 AUX_ENABLES Auxiliary enables 0x7E21 5040 AUX_MU_IO_REG Mini Uart I/O Data So we define the registers we need for miniuart:</description></item><item><title>Write a simple shell</title><link>https://jackeryli.github.io/bare-metal/shell/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://jackeryli.github.io/bare-metal/shell/</guid><description>We write a shell that can run the following commands:
help hello timestamp reboot typedef struct cmd_struct { char* name; char* msg; int (*func)(char**); } cmd_struct; int help(char**); int hello(char**); int timestamp(char**); int reboot(char**); // TODO: argv for each commands char* argv[10]; cmd_struct cmds[NCOMMANDS] = { { .name = &amp;#34;help&amp;#34;, .msg = &amp;#34;print available commands&amp;#34;, .func = help }, { .name = &amp;#34;hello&amp;#34;, .msg = &amp;#34;print hello world&amp;#34;, .func = hello }, { .</description></item></channel></rss>